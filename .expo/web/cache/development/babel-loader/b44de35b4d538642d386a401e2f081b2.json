{"ast":null,"code":"'use strict';\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nif (__DEV__) {\n  (function () {\n    \"use strict\";\n\n    require(\"../../Core/InitializeCore\");\n\n    var ReactNativeViewConfigRegistry = require(\"../shims/ReactNativeViewConfigRegistry\");\n\n    var UIManager = require(\"../../ReactNative/UIManager\");\n\n    var RCTEventEmitter = require(\"../../EventEmitter/RCTEventEmitter\");\n\n    var React = require(\"react\");\n\n    var deepFreezeAndThrowOnMutationInDev = require(\"../../Utilities/deepFreezeAndThrowOnMutationInDev\");\n\n    var deepDiffer = require(\"../../Utilities/differ/deepDiffer\");\n\n    var flattenStyle = require(\"../../StyleSheet/flattenStyle\");\n\n    var TextInputState = require(\"../../Components/TextInput/TextInputState\");\n\n    var checkPropTypes = require(\"prop-types/checkPropTypes\");\n\n    var tracking = require(\"schedule/tracking\");\n\n    var ExceptionsManager = require(\"../../Core/ExceptionsManager\");\n\n    var validateFormat = function validateFormat() {};\n\n    {\n      validateFormat = function validateFormat(format) {\n        if (format === undefined) {\n          throw new Error(\"invariant requires an error message argument\");\n        }\n      };\n    }\n\n    function invariant(condition, format, a, b, c, d, e, f) {\n      validateFormat(format);\n\n      if (!condition) {\n        var error = void 0;\n\n        if (format === undefined) {\n          error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n        } else {\n          var args = [a, b, c, d, e, f];\n          var argIndex = 0;\n          error = new Error(format.replace(/%s/g, function () {\n            return args[argIndex++];\n          }));\n          error.name = \"Invariant Violation\";\n        }\n\n        error.framesToPop = 1;\n        throw error;\n      }\n    }\n\n    var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        this.onError(error);\n      }\n    };\n\n    {\n      if (typeof window !== \"undefined\" && typeof window.dispatchEvent === \"function\" && typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\n        var fakeNode = document.createElement(\"react\");\n\n        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n          invariant(typeof document !== \"undefined\", \"The `document` global was defined when React was initialized, but is not \" + \"defined anymore. This can happen in a test environment if a component \" + \"schedules an update from an asynchronous callback, but the test has already \" + \"finished running. To solve this, you can either unmount the component at \" + \"the end of your test (and ensure that any asynchronous operations get \" + \"canceled in `componentWillUnmount`), or you can change the test itself \" + \"to be asynchronous.\");\n          var evt = document.createEvent(\"Event\");\n          var didError = true;\n          var windowEvent = window.event;\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n          function callCallback() {\n            fakeNode.removeEventListener(evtType, callCallback, false);\n\n            if (typeof window.event !== \"undefined\" && window.hasOwnProperty(\"event\")) {\n              window.event = windowEvent;\n            }\n\n            func.apply(context, funcArgs);\n            didError = false;\n          }\n\n          var error = void 0;\n          var didSetError = false;\n          var isCrossOriginError = false;\n\n          function handleWindowError(event) {\n            error = event.error;\n            didSetError = true;\n\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n\n            if (event.defaultPrevented) {\n              if (error != null && typeof error === \"object\") {\n                try {\n                  error._suppressLogging = true;\n                } catch (inner) {}\n              }\n            }\n          }\n\n          var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n          window.addEventListener(\"error\", handleWindowError);\n          fakeNode.addEventListener(evtType, callCallback, false);\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n\n          if (didError) {\n            if (!didSetError) {\n              error = new Error(\"An error was thrown inside one of your components, but React \" + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + \"your browser. Try triggering the error in production mode, \" + \"or switching to a modern browser. If you suspect that this is \" + \"actually an issue with React, please file an issue.\");\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + \"the actual error object in development. \" + \"See https://fb.me/react-crossorigin-error for more information.\");\n            }\n\n            this.onError(error);\n          }\n\n          window.removeEventListener(\"error\", handleWindowError);\n        };\n\n        invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n      }\n    }\n    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n    var hasError = false;\n    var caughtError = null;\n    var hasRethrowError = false;\n    var rethrowError = null;\n    var reporter = {\n      onError: function onError(error) {\n        hasError = true;\n        caughtError = error;\n      }\n    };\n\n    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n      hasError = false;\n      caughtError = null;\n      invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n    }\n\n    function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n      invokeGuardedCallback.apply(this, arguments);\n\n      if (hasError) {\n        var error = clearCaughtError();\n\n        if (!hasRethrowError) {\n          hasRethrowError = true;\n          rethrowError = error;\n        }\n      }\n    }\n\n    function rethrowCaughtError() {\n      if (hasRethrowError) {\n        var error = rethrowError;\n        hasRethrowError = false;\n        rethrowError = null;\n        throw error;\n      }\n    }\n\n    function hasCaughtError() {\n      return hasError;\n    }\n\n    function clearCaughtError() {\n      if (hasError) {\n        var error = caughtError;\n        hasError = false;\n        caughtError = null;\n        return error;\n      } else {\n        invariant(false, \"clearCaughtError was called but no error was captured. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n      }\n    }\n\n    var eventPluginOrder = null;\n    var namesToPlugins = {};\n\n    function recomputePluginOrdering() {\n      if (!eventPluginOrder) {\n        return;\n      }\n\n      for (var pluginName in namesToPlugins) {\n        var pluginModule = namesToPlugins[pluginName];\n        var pluginIndex = eventPluginOrder.indexOf(pluginName);\n        invariant(pluginIndex > -1, \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" + \"the plugin ordering, `%s`.\", pluginName);\n\n        if (plugins[pluginIndex]) {\n          continue;\n        }\n\n        invariant(pluginModule.extractEvents, \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" + \"method, but `%s` does not.\", pluginName);\n        plugins[pluginIndex] = pluginModule;\n        var publishedEvents = pluginModule.eventTypes;\n\n        for (var eventName in publishedEvents) {\n          invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\", eventName, pluginName);\n        }\n      }\n    }\n\n    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n      invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), \"EventPluginHub: More than one plugin attempted to publish the same \" + \"event name, `%s`.\", eventName);\n      eventNameDispatchConfigs[eventName] = dispatchConfig;\n      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n\n      if (phasedRegistrationNames) {\n        for (var phaseName in phasedRegistrationNames) {\n          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n            var phasedRegistrationName = phasedRegistrationNames[phaseName];\n            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n          }\n        }\n\n        return true;\n      } else if (dispatchConfig.registrationName) {\n        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n        return true;\n      }\n\n      return false;\n    }\n\n    function publishRegistrationName(registrationName, pluginModule, eventName) {\n      invariant(!registrationNameModules[registrationName], \"EventPluginHub: More than one plugin attempted to publish the same \" + \"registration name, `%s`.\", registrationName);\n      registrationNameModules[registrationName] = pluginModule;\n      registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n      {\n        var lowerCasedName = registrationName.toLowerCase();\n      }\n    }\n\n    var plugins = [];\n    var eventNameDispatchConfigs = {};\n    var registrationNameModules = {};\n    var registrationNameDependencies = {};\n\n    function injectEventPluginOrder(injectedEventPluginOrder) {\n      invariant(!eventPluginOrder, \"EventPluginRegistry: Cannot inject event plugin ordering more than \" + \"once. You are likely trying to load more than one copy of React.\");\n      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n      recomputePluginOrdering();\n    }\n\n    function injectEventPluginsByName(injectedNamesToPlugins) {\n      var isOrderingDirty = false;\n\n      for (var pluginName in injectedNamesToPlugins) {\n        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n          continue;\n        }\n\n        var pluginModule = injectedNamesToPlugins[pluginName];\n\n        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n          invariant(!namesToPlugins[pluginName], \"EventPluginRegistry: Cannot inject two different event plugins \" + \"using the same name, `%s`.\", pluginName);\n          namesToPlugins[pluginName] = pluginModule;\n          isOrderingDirty = true;\n        }\n      }\n\n      if (isOrderingDirty) {\n        recomputePluginOrdering();\n      }\n    }\n\n    var warningWithoutStack = function warningWithoutStack() {};\n\n    {\n      warningWithoutStack = function warningWithoutStack(condition, format) {\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error(\"`warningWithoutStack(condition, format, ...args)` requires a warning \" + \"message argument\");\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== \"undefined\") {\n          var _console;\n\n          var stringArgs = args.map(function (item) {\n            return \"\" + item;\n          });\n\n          (_console = console).error.apply(_console, [\"Warning: \" + format].concat(stringArgs));\n        }\n\n        try {\n          var argIndex = 0;\n          var message = \"Warning: \" + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n          throw new Error(message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n    var getFiberCurrentPropsFromNode = null;\n    var getInstanceFromNode = null;\n    var getNodeFromInstance = null;\n\n    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n      getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n      getInstanceFromNode = getInstanceFromNodeImpl;\n      getNodeFromInstance = getNodeFromInstanceImpl;\n      {\n        !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, \"EventPluginUtils.setComponentTree(...): Injected \" + \"module is missing getNodeFromInstance or getInstanceFromNode.\") : void 0;\n      }\n    }\n\n    var validateEventDispatches = void 0;\n    {\n      validateEventDispatches = function validateEventDispatches(event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, \"EventPluginUtils: Invalid `event`.\") : void 0;\n      };\n    }\n\n    function executeDispatch(event, simulated, listener, inst) {\n      var type = event.type || \"unknown-event\";\n      event.currentTarget = getNodeFromInstance(inst);\n      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n      event.currentTarget = null;\n    }\n\n    function executeDispatchesInOrder(event, simulated) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          }\n\n          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n        }\n      } else if (dispatchListeners) {\n        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n      }\n\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n    }\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          }\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n\n      return null;\n    }\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n      invariant(!Array.isArray(dispatchListener), \"executeDirectDispatch(...): Invalid `event`.\");\n      event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    }\n\n    function accumulateInto(current, next) {\n      invariant(next != null, \"accumulateInto(...): Accumulated items must not be null or undefined.\");\n\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    var eventQueue = null;\n\n    var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {\n      if (event) {\n        executeDispatchesInOrder(event, simulated);\n\n        if (!event.isPersistent()) {\n          event.constructor.release(event);\n        }\n      }\n    };\n\n    var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {\n      return executeDispatchesAndRelease(e, true);\n    };\n\n    var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {\n      return executeDispatchesAndRelease(e, false);\n    };\n\n    function isInteractive(tag) {\n      return tag === \"button\" || tag === \"input\" || tag === \"select\" || tag === \"textarea\";\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case \"onClick\":\n        case \"onClickCapture\":\n        case \"onDoubleClick\":\n        case \"onDoubleClickCapture\":\n        case \"onMouseDown\":\n        case \"onMouseDownCapture\":\n        case \"onMouseMove\":\n        case \"onMouseMoveCapture\":\n        case \"onMouseUp\":\n        case \"onMouseUpCapture\":\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n\n    var injection = {\n      injectEventPluginOrder: injectEventPluginOrder,\n      injectEventPluginsByName: injectEventPluginsByName\n    };\n\n    function getListener(inst, registrationName) {\n      var listener = void 0;\n      var stateNode = inst.stateNode;\n\n      if (!stateNode) {\n        return null;\n      }\n\n      var props = getFiberCurrentPropsFromNode(stateNode);\n\n      if (!props) {\n        return null;\n      }\n\n      listener = props[registrationName];\n\n      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n        return null;\n      }\n\n      invariant(!listener || typeof listener === \"function\", \"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\n      return listener;\n    }\n\n    function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var events = null;\n\n      for (var i = 0; i < plugins.length; i++) {\n        var possiblePlugin = plugins[i];\n\n        if (possiblePlugin) {\n          var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n          if (extractedEvents) {\n            events = accumulateInto(events, extractedEvents);\n          }\n        }\n      }\n\n      return events;\n    }\n\n    function runEventsInBatch(events, simulated) {\n      if (events !== null) {\n        eventQueue = accumulateInto(eventQueue, events);\n      }\n\n      var processingEventQueue = eventQueue;\n      eventQueue = null;\n\n      if (!processingEventQueue) {\n        return;\n      }\n\n      if (simulated) {\n        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n      } else {\n        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n      }\n\n      invariant(!eventQueue, \"processEventQueue(): Additional events were enqueued while processing \" + \"an event queue. Support for this has not yet been implemented.\");\n      rethrowCaughtError();\n    }\n\n    function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      runEventsInBatch(events, false);\n    }\n\n    var FunctionalComponent = 0;\n    var FunctionalComponentLazy = 1;\n    var ClassComponent = 2;\n    var ClassComponentLazy = 3;\n    var IndeterminateComponent = 4;\n    var HostRoot = 5;\n    var HostPortal = 6;\n    var HostComponent = 7;\n    var HostText = 8;\n    var Fragment = 9;\n    var Mode = 10;\n    var ContextConsumer = 11;\n    var ContextProvider = 12;\n    var ForwardRef = 13;\n    var ForwardRefLazy = 14;\n    var Profiler = 15;\n    var PlaceholderComponent = 16;\n\n    function getParent(inst) {\n      do {\n        inst = inst.return;\n      } while (inst && inst.tag !== HostComponent);\n\n      if (inst) {\n        return inst;\n      }\n\n      return null;\n    }\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      }\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      }\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      }\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n\n        instB = getParent(instB);\n      }\n\n      return false;\n    }\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i = void 0;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], \"captured\", arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], \"bubbled\", arg);\n      }\n    }\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        !inst ? warningWithoutStack$1(false, \"Dispatching inst must not be null\") : void 0;\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? getParentInstance(targetInst) : null;\n        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n        }\n      }\n    }\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated(events, accumulateDirectDispatchesSingle);\n    }\n\n    var EVENT_POOL_SIZE = 10;\n    var EventInterface = {\n      type: null,\n      target: null,\n      currentTarget: function currentTarget() {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function timeStamp(event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n\n    function functionThatReturnsTrue() {\n      return true;\n    }\n\n    function functionThatReturnsFalse() {\n      return false;\n    }\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName];\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === \"target\") {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n\n    _extends(SyntheticEvent.prototype, {\n      preventDefault: function preventDefault() {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== \"unknown\") {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function stopPropagation() {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== \"unknown\") {\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n      persist: function persist() {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n      isPersistent: functionThatReturnsFalse,\n      destructor: function destructor() {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, \"nativeEvent\", getPooledWarningPropertyDefinition(\"nativeEvent\", null));\n          Object.defineProperty(this, \"isDefaultPrevented\", getPooledWarningPropertyDefinition(\"isDefaultPrevented\", functionThatReturnsFalse));\n          Object.defineProperty(this, \"isPropagationStopped\", getPooledWarningPropertyDefinition(\"isPropagationStopped\", functionThatReturnsFalse));\n          Object.defineProperty(this, \"preventDefault\", getPooledWarningPropertyDefinition(\"preventDefault\", function () {}));\n          Object.defineProperty(this, \"stopPropagation\", getPooledWarningPropertyDefinition(\"stopPropagation\", function () {}));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n\n      var E = function E() {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n\n      _extends(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _extends({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n\n    addEventPoolingTo(SyntheticEvent);\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === \"function\";\n      return {\n        configurable: true,\n        set: set,\n        get: get$$1\n      };\n\n      function set(val) {\n        var action = isFunction ? \"setting the method\" : \"setting the property\";\n        warn(action, \"This is effectively a no-op\");\n        return val;\n      }\n\n      function get$$1() {\n        var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n        var result = isFunction ? \"This is a no-op function\" : \"This is set to null\";\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + \"If you must keep the original synthetic event around, use event.persist(). \" + \"See https://fb.me/react-event-pooling for more information.\", action, propName, result) : void 0;\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n      invariant(event instanceof EventConstructor, \"Trying to release an event instance into a pool of a different type.\");\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n\n    var ResponderSyntheticEvent = SyntheticEvent.extend({\n      touchHistory: function touchHistory(nativeEvent) {\n        return null;\n      }\n    });\n    var TOP_TOUCH_START = \"topTouchStart\";\n    var TOP_TOUCH_MOVE = \"topTouchMove\";\n    var TOP_TOUCH_END = \"topTouchEnd\";\n    var TOP_TOUCH_CANCEL = \"topTouchCancel\";\n    var TOP_SCROLL = \"topScroll\";\n    var TOP_SELECTION_CHANGE = \"topSelectionChange\";\n\n    function isStartish(topLevelType) {\n      return topLevelType === TOP_TOUCH_START;\n    }\n\n    function isMoveish(topLevelType) {\n      return topLevelType === TOP_TOUCH_MOVE;\n    }\n\n    function isEndish(topLevelType) {\n      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;\n    }\n\n    var startDependencies = [TOP_TOUCH_START];\n    var moveDependencies = [TOP_TOUCH_MOVE];\n    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];\n    var MAX_TOUCH_BANK = 20;\n    var touchBank = [];\n    var touchHistory = {\n      touchBank: touchBank,\n      numberActiveTouches: 0,\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n\n    function timestampForTouch(touch) {\n      return touch.timeStamp || touch.timestamp;\n    }\n\n    function createTouchRecord(touch) {\n      return {\n        touchActive: true,\n        startPageX: touch.pageX,\n        startPageY: touch.pageY,\n        startTimeStamp: timestampForTouch(touch),\n        currentPageX: touch.pageX,\n        currentPageY: touch.pageY,\n        currentTimeStamp: timestampForTouch(touch),\n        previousPageX: touch.pageX,\n        previousPageY: touch.pageY,\n        previousTimeStamp: timestampForTouch(touch)\n      };\n    }\n\n    function resetTouchRecord(touchRecord, touch) {\n      touchRecord.touchActive = true;\n      touchRecord.startPageX = touch.pageX;\n      touchRecord.startPageY = touch.pageY;\n      touchRecord.startTimeStamp = timestampForTouch(touch);\n      touchRecord.currentPageX = touch.pageX;\n      touchRecord.currentPageY = touch.pageY;\n      touchRecord.currentTimeStamp = timestampForTouch(touch);\n      touchRecord.previousPageX = touch.pageX;\n      touchRecord.previousPageY = touch.pageY;\n      touchRecord.previousTimeStamp = timestampForTouch(touch);\n    }\n\n    function getTouchIdentifier(_ref) {\n      var identifier = _ref.identifier;\n      invariant(identifier != null, \"Touch object is missing identifier.\");\n      {\n        !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, \"Touch identifier %s is greater than maximum supported %s which causes \" + \"performance issues backfilling array locations for all of the indices.\", identifier, MAX_TOUCH_BANK) : void 0;\n      }\n      return identifier;\n    }\n\n    function recordTouchStart(touch) {\n      var identifier = getTouchIdentifier(touch);\n      var touchRecord = touchBank[identifier];\n\n      if (touchRecord) {\n        resetTouchRecord(touchRecord, touch);\n      } else {\n        touchBank[identifier] = createTouchRecord(touch);\n      }\n\n      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n    }\n\n    function recordTouchMove(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = true;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.error(\"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\", \"Touch Bank: %s\", printTouch(touch), printTouchBank());\n      }\n    }\n\n    function recordTouchEnd(touch) {\n      var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n      if (touchRecord) {\n        touchRecord.touchActive = false;\n        touchRecord.previousPageX = touchRecord.currentPageX;\n        touchRecord.previousPageY = touchRecord.currentPageY;\n        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n        touchRecord.currentPageX = touch.pageX;\n        touchRecord.currentPageY = touch.pageY;\n        touchRecord.currentTimeStamp = timestampForTouch(touch);\n        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n      } else {\n        console.error(\"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\", \"Touch Bank: %s\", printTouch(touch), printTouchBank());\n      }\n    }\n\n    function printTouch(touch) {\n      return JSON.stringify({\n        identifier: touch.identifier,\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        timestamp: timestampForTouch(touch)\n      });\n    }\n\n    function printTouchBank() {\n      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n      if (touchBank.length > MAX_TOUCH_BANK) {\n        printed += \" (original size: \" + touchBank.length + \")\";\n      }\n\n      return printed;\n    }\n\n    var ResponderTouchHistoryStore = {\n      recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n        if (isMoveish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchMove);\n        } else if (isStartish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchStart);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n          }\n        } else if (isEndish(topLevelType)) {\n          nativeEvent.changedTouches.forEach(recordTouchEnd);\n          touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n          if (touchHistory.numberActiveTouches === 1) {\n            for (var i = 0; i < touchBank.length; i++) {\n              var touchTrackToCheck = touchBank[i];\n\n              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n                touchHistory.indexOfSingleActiveTouch = i;\n                break;\n              }\n            }\n\n            {\n              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n              !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, \"Cannot find single active touch.\") : void 0;\n            }\n          }\n        }\n      },\n      touchHistory: touchHistory\n    };\n\n    function accumulate(current, next) {\n      invariant(next != null, \"accumulate(...): Accumulated items must be not be null or undefined.\");\n\n      if (current == null) {\n        return next;\n      }\n\n      if (Array.isArray(current)) {\n        return current.concat(next);\n      }\n\n      if (Array.isArray(next)) {\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n\n    var responderInst = null;\n    var trackedTouchCount = 0;\n\n    var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {\n      var oldResponderInst = responderInst;\n      responderInst = nextResponderInst;\n\n      if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n      }\n    };\n\n    var eventTypes$1 = {\n      startShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: \"onStartShouldSetResponder\",\n          captured: \"onStartShouldSetResponderCapture\"\n        },\n        dependencies: startDependencies\n      },\n      scrollShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: \"onScrollShouldSetResponder\",\n          captured: \"onScrollShouldSetResponderCapture\"\n        },\n        dependencies: [TOP_SCROLL]\n      },\n      selectionChangeShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: \"onSelectionChangeShouldSetResponder\",\n          captured: \"onSelectionChangeShouldSetResponderCapture\"\n        },\n        dependencies: [TOP_SELECTION_CHANGE]\n      },\n      moveShouldSetResponder: {\n        phasedRegistrationNames: {\n          bubbled: \"onMoveShouldSetResponder\",\n          captured: \"onMoveShouldSetResponderCapture\"\n        },\n        dependencies: moveDependencies\n      },\n      responderStart: {\n        registrationName: \"onResponderStart\",\n        dependencies: startDependencies\n      },\n      responderMove: {\n        registrationName: \"onResponderMove\",\n        dependencies: moveDependencies\n      },\n      responderEnd: {\n        registrationName: \"onResponderEnd\",\n        dependencies: endDependencies\n      },\n      responderRelease: {\n        registrationName: \"onResponderRelease\",\n        dependencies: endDependencies\n      },\n      responderTerminationRequest: {\n        registrationName: \"onResponderTerminationRequest\",\n        dependencies: []\n      },\n      responderGrant: {\n        registrationName: \"onResponderGrant\",\n        dependencies: []\n      },\n      responderReject: {\n        registrationName: \"onResponderReject\",\n        dependencies: []\n      },\n      responderTerminate: {\n        registrationName: \"onResponderTerminate\",\n        dependencies: []\n      }\n    };\n\n    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;\n      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);\n      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n      if (skipOverBubbleShouldSetFrom) {\n        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n      } else {\n        accumulateTwoPhaseDispatches(shouldSetEvent);\n      }\n\n      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n\n      if (!shouldSetEvent.isPersistent()) {\n        shouldSetEvent.constructor.release(shouldSetEvent);\n      }\n\n      if (!wantsResponderInst || wantsResponderInst === responderInst) {\n        return null;\n      }\n\n      var extracted = void 0;\n      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(grantEvent);\n      var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n\n      if (responderInst) {\n        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n        accumulateDirectDispatches(terminationRequestEvent);\n        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n\n        if (!terminationRequestEvent.isPersistent()) {\n          terminationRequestEvent.constructor.release(terminationRequestEvent);\n        }\n\n        if (shouldSwitch) {\n          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(terminateEvent);\n          extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n          changeResponder(wantsResponderInst, blockHostResponder);\n        } else {\n          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(rejectEvent);\n          extracted = accumulate(extracted, rejectEvent);\n        }\n      } else {\n        extracted = accumulate(extracted, grantEvent);\n        changeResponder(wantsResponderInst, blockHostResponder);\n      }\n\n      return extracted;\n    }\n\n    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n      return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));\n    }\n\n    function noResponderTouches(nativeEvent) {\n      var touches = nativeEvent.touches;\n\n      if (!touches || touches.length === 0) {\n        return true;\n      }\n\n      for (var i = 0; i < touches.length; i++) {\n        var activeTouch = touches[i];\n        var target = activeTouch.target;\n\n        if (target !== null && target !== undefined && target !== 0) {\n          var targetInst = getInstanceFromNode(target);\n\n          if (isAncestor(responderInst, targetInst)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    var ResponderEventPlugin = {\n      _getResponder: function _getResponder() {\n        return responderInst;\n      },\n      eventTypes: eventTypes$1,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        if (isStartish(topLevelType)) {\n          trackedTouchCount += 1;\n        } else if (isEndish(topLevelType)) {\n          if (trackedTouchCount >= 0) {\n            trackedTouchCount -= 1;\n          } else {\n            console.error(\"Ended a touch event which was not counted in `trackedTouchCount`.\");\n            return null;\n          }\n        }\n\n        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;\n        var isResponderTouchStart = responderInst && isStartish(topLevelType);\n        var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n        var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n        var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;\n\n        if (incrementalTouch) {\n          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(gesture);\n          extracted = accumulate(extracted, gesture);\n        }\n\n        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;\n        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n        var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;\n\n        if (finalTouch) {\n          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n          accumulateDirectDispatches(finalEvent);\n          extracted = accumulate(extracted, finalEvent);\n          changeResponder(null);\n        }\n\n        return extracted;\n      },\n      GlobalResponderHandler: null,\n      injection: {\n        injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {\n          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n        }\n      }\n    };\n    var customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes;\n    var customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes;\n    var eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;\n    var ReactNativeBridgeEventPlugin = {\n      eventTypes: eventTypes$2,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        if (targetInst == null) {\n          return null;\n        }\n\n        var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];\n        var directDispatchConfig = customDirectEventTypes$1[topLevelType];\n        invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type \"%s\" dispatched', topLevelType);\n        var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n\n        if (bubbleDispatchConfig) {\n          accumulateTwoPhaseDispatches(event);\n        } else if (directDispatchConfig) {\n          accumulateDirectDispatches(event);\n        } else {\n          return null;\n        }\n\n        return event;\n      }\n    };\n    var ReactNativeEventPluginOrder = [\"ResponderEventPlugin\", \"ReactNativeBridgeEventPlugin\"];\n    injection.injectEventPluginOrder(ReactNativeEventPluginOrder);\n    injection.injectEventPluginsByName({\n      ResponderEventPlugin: ResponderEventPlugin,\n      ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n    });\n    var instanceCache = {};\n    var instanceProps = {};\n\n    function precacheFiberNode(hostInst, tag) {\n      instanceCache[tag] = hostInst;\n    }\n\n    function uncacheFiberNode(tag) {\n      delete instanceCache[tag];\n      delete instanceProps[tag];\n    }\n\n    function getInstanceFromTag(tag) {\n      return instanceCache[tag] || null;\n    }\n\n    function getTagFromInstance(inst) {\n      var tag = inst.stateNode._nativeTag;\n\n      if (tag === undefined) {\n        tag = inst.stateNode.canonical._nativeTag;\n      }\n\n      invariant(tag, \"All native instances should have a tag.\");\n      return tag;\n    }\n\n    function getFiberCurrentPropsFromNode$1(stateNode) {\n      return instanceProps[stateNode._nativeTag] || null;\n    }\n\n    function updateFiberProps(tag, props) {\n      instanceProps[tag] = props;\n    }\n\n    var restoreImpl = null;\n    var restoreTarget = null;\n    var restoreQueue = null;\n\n    function restoreStateOfTarget(target) {\n      var internalInstance = getInstanceFromNode(target);\n\n      if (!internalInstance) {\n        return;\n      }\n\n      invariant(typeof restoreImpl === \"function\", \"setRestoreImplementation() needs to be called to handle a target for controlled \" + \"events. This error is likely caused by a bug in React. Please file an issue.\");\n      var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n      restoreImpl(internalInstance.stateNode, internalInstance.type, props);\n    }\n\n    function needsStateRestore() {\n      return restoreTarget !== null || restoreQueue !== null;\n    }\n\n    function restoreStateIfNeeded() {\n      if (!restoreTarget) {\n        return;\n      }\n\n      var target = restoreTarget;\n      var queuedTargets = restoreQueue;\n      restoreTarget = null;\n      restoreQueue = null;\n      restoreStateOfTarget(target);\n\n      if (queuedTargets) {\n        for (var i = 0; i < queuedTargets.length; i++) {\n          restoreStateOfTarget(queuedTargets[i]);\n        }\n      }\n    }\n\n    var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {\n      return fn(bookkeeping);\n    };\n\n    var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};\n\n    var isBatching = false;\n\n    function batchedUpdates(fn, bookkeeping) {\n      if (isBatching) {\n        return fn(bookkeeping);\n      }\n\n      isBatching = true;\n\n      try {\n        return _batchedUpdatesImpl(fn, bookkeeping);\n      } finally {\n        isBatching = false;\n        var controlledComponentsHavePendingUpdates = needsStateRestore();\n\n        if (controlledComponentsHavePendingUpdates) {\n          _flushInteractiveUpdatesImpl();\n\n          restoreStateIfNeeded();\n        }\n      }\n    }\n\n    function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {\n      _batchedUpdatesImpl = batchedUpdatesImpl;\n      _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\n    }\n\n    var EMPTY_NATIVE_EVENT = {};\n\n    var touchSubsequence = function touchSubsequence(touches, indices) {\n      var ret = [];\n\n      for (var i = 0; i < indices.length; i++) {\n        ret.push(touches[indices[i]]);\n      }\n\n      return ret;\n    };\n\n    var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {\n      var rippedOut = [];\n      var temp = touches;\n\n      for (var i = 0; i < indices.length; i++) {\n        var index = indices[i];\n        rippedOut.push(touches[index]);\n        temp[index] = null;\n      }\n\n      var fillAt = 0;\n\n      for (var j = 0; j < temp.length; j++) {\n        var cur = temp[j];\n\n        if (cur !== null) {\n          temp[fillAt++] = cur;\n        }\n      }\n\n      temp.length = fillAt;\n      return rippedOut;\n    };\n\n    function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n      var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n      var inst = getInstanceFromTag(rootNodeID);\n      batchedUpdates(function () {\n        runExtractedEventsInBatch(topLevelType, inst, nativeEvent, nativeEvent.target);\n      });\n    }\n\n    function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n    }\n\n    function receiveTouches(eventTopLevelType, touches, changedIndices) {\n      var changedTouches = eventTopLevelType === \"topTouchEnd\" || eventTopLevelType === \"topTouchCancel\" ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);\n\n      for (var jj = 0; jj < changedTouches.length; jj++) {\n        var touch = changedTouches[jj];\n        touch.changedTouches = changedTouches;\n        touch.touches = touches;\n        var nativeEvent = touch;\n        var rootNodeID = null;\n        var target = nativeEvent.target;\n\n        if (target !== null && target !== undefined) {\n          if (target < 1) {\n            {\n              warningWithoutStack$1(false, \"A view is reporting that a touch occurred on tag zero.\");\n            }\n          } else {\n            rootNodeID = target;\n          }\n        }\n\n        _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n      }\n    }\n\n    var ReactNativeEventEmitter = Object.freeze({\n      getListener: getListener,\n      registrationNames: registrationNameModules,\n      _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n      receiveEvent: receiveEvent,\n      receiveTouches: receiveTouches\n    });\n    var ReactNativeGlobalResponderHandler = {\n      onChange: function onChange(from, to, blockNativeResponder) {\n        if (to !== null) {\n          var tag = to.stateNode._nativeTag;\n          UIManager.setJSResponder(tag, blockNativeResponder);\n        } else {\n          UIManager.clearJSResponder();\n        }\n      }\n    };\n    RCTEventEmitter.register(ReactNativeEventEmitter);\n    setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromTag, getTagFromInstance);\n    ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);\n\n    function get$1(key) {\n      return key._reactInternalFiber;\n    }\n\n    function set(key, value) {\n      key._reactInternalFiber = value;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace;\n    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n    var REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for(\"react.placeholder\") : 0xead1;\n    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === \"function\") {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n\n    function getResultFromResolvedThenable(thenable) {\n      return thenable._reactResult;\n    }\n\n    function refineResolvedThenable(thenable) {\n      return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n    }\n\n    function getComponentName(type) {\n      if (type == null) {\n        return null;\n      }\n\n      {\n        if (typeof type.tag === \"number\") {\n          warningWithoutStack$1(false, \"Received an unexpected object in getComponentName(). \" + \"This is likely a bug in React. Please file an issue.\");\n        }\n      }\n\n      if (typeof type === \"function\") {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === \"string\") {\n        return type;\n      }\n\n      switch (type) {\n        case REACT_ASYNC_MODE_TYPE:\n          return \"AsyncMode\";\n\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n\n        case REACT_PLACEHOLDER_TYPE:\n          return \"Placeholder\";\n      }\n\n      if (typeof type === \"object\") {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            return \"Context.Consumer\";\n\n          case REACT_PROVIDER_TYPE:\n            return \"Context.Provider\";\n\n          case REACT_FORWARD_REF_TYPE:\n            var renderFn = type.render;\n            var functionName = renderFn.displayName || renderFn.name || \"\";\n            return functionName !== \"\" ? \"ForwardRef(\" + functionName + \")\" : \"ForwardRef\";\n        }\n\n        if (typeof type.then === \"function\") {\n          var thenable = type;\n          var resolvedThenable = refineResolvedThenable(thenable);\n\n          if (resolvedThenable) {\n            return getComponentName(resolvedThenable);\n          }\n        }\n      }\n\n      return null;\n    }\n\n    var NoEffect = 0;\n    var PerformedWork = 1;\n    var Placement = 2;\n    var Update = 4;\n    var PlacementAndUpdate = 6;\n    var Deletion = 8;\n    var ContentReset = 16;\n    var Callback = 32;\n    var DidCapture = 64;\n    var Ref = 128;\n    var Snapshot = 256;\n    var LifecycleEffectMask = 420;\n    var HostEffectMask = 511;\n    var Incomplete = 512;\n    var ShouldCapture = 1024;\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node.return) {\n          node = node.return;\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node.return) {\n          node = node.return;\n        }\n      }\n\n      if (node.tag === HostRoot) {\n        return MOUNTED;\n      }\n\n      return UNMOUNTED;\n    }\n\n    function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner$1.current;\n\n        if (owner !== null && (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, \"%s is accessing isMounted inside its render() function. \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentName(ownerFiber.type) || \"A component\") : void 0;\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = get$1(component);\n\n      if (!fiber) {\n        return false;\n      }\n\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    }\n\n    function assertIsMounted(fiber) {\n      invariant(isFiberMountedImpl(fiber) === MOUNTED, \"Unable to find node on an unmounted component.\");\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        var state = isFiberMountedImpl(fiber);\n        invariant(state !== UNMOUNTED, \"Unable to find node on an unmounted component.\");\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      }\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a.return;\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          break;\n        }\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          }\n\n          invariant(false, \"Unable to find node on an unmounted component.\");\n        }\n\n        if (a.return !== b.return) {\n          a = parentA;\n          b = parentB;\n        } else {\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            invariant(didFindChild, \"Child was not found in either parent set. This indicates a bug \" + \"in React related to the return pointer. Please file an issue.\");\n          }\n        }\n\n        invariant(a.alternate === b, \"Return fibers should always be each others' alternates. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n      }\n\n      invariant(a.tag === HostRoot, \"Unable to find node on an unmounted component.\");\n\n      if (a.stateNode.current === a) {\n        return fiber;\n      }\n\n      return alternate;\n    }\n\n    function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      }\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        } else if (node.child) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node.return || node.return === currentParent) {\n            return null;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n\n      return null;\n    }\n\n    var emptyObject = {};\n    var removedKeys = null;\n    var removedKeyCount = 0;\n\n    function defaultDiffer(prevProp, nextProp) {\n      if (typeof nextProp !== \"object\" || nextProp === null) {\n        return true;\n      } else {\n        return deepDiffer(prevProp, nextProp);\n      }\n    }\n\n    function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {\n      if (Array.isArray(node)) {\n        var i = node.length;\n\n        while (i-- && removedKeyCount > 0) {\n          restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);\n        }\n      } else if (node && removedKeyCount > 0) {\n        var obj = node;\n\n        for (var propKey in removedKeys) {\n          if (!removedKeys[propKey]) {\n            continue;\n          }\n\n          var nextProp = obj[propKey];\n\n          if (nextProp === undefined) {\n            continue;\n          }\n\n          var attributeConfig = validAttributes[propKey];\n\n          if (!attributeConfig) {\n            continue;\n          }\n\n          if (typeof nextProp === \"function\") {\n            nextProp = true;\n          }\n\n          if (typeof nextProp === \"undefined\") {\n            nextProp = null;\n          }\n\n          if (typeof attributeConfig !== \"object\") {\n            updatePayload[propKey] = nextProp;\n          } else if (typeof attributeConfig.diff === \"function\" || typeof attributeConfig.process === \"function\") {\n            var nextValue = typeof attributeConfig.process === \"function\" ? attributeConfig.process(nextProp) : nextProp;\n            updatePayload[propKey] = nextValue;\n          }\n\n          removedKeys[propKey] = false;\n          removedKeyCount--;\n        }\n      }\n    }\n\n    function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {\n      var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n      var i = void 0;\n\n      for (i = 0; i < minLength; i++) {\n        updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);\n      }\n\n      for (; i < prevArray.length; i++) {\n        updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);\n      }\n\n      for (; i < nextArray.length; i++) {\n        updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);\n      }\n\n      return updatePayload;\n    }\n\n    function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {\n      if (!updatePayload && prevProp === nextProp) {\n        return updatePayload;\n      }\n\n      if (!prevProp || !nextProp) {\n        if (nextProp) {\n          return addNestedProperty(updatePayload, nextProp, validAttributes);\n        }\n\n        if (prevProp) {\n          return clearNestedProperty(updatePayload, prevProp, validAttributes);\n        }\n\n        return updatePayload;\n      }\n\n      if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n        return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n      }\n\n      if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n        return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);\n      }\n\n      if (Array.isArray(prevProp)) {\n        return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);\n      }\n\n      return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);\n    }\n\n    function addNestedProperty(updatePayload, nextProp, validAttributes) {\n      if (!nextProp) {\n        return updatePayload;\n      }\n\n      if (!Array.isArray(nextProp)) {\n        return addProperties(updatePayload, nextProp, validAttributes);\n      }\n\n      for (var i = 0; i < nextProp.length; i++) {\n        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);\n      }\n\n      return updatePayload;\n    }\n\n    function clearNestedProperty(updatePayload, prevProp, validAttributes) {\n      if (!prevProp) {\n        return updatePayload;\n      }\n\n      if (!Array.isArray(prevProp)) {\n        return clearProperties(updatePayload, prevProp, validAttributes);\n      }\n\n      for (var i = 0; i < prevProp.length; i++) {\n        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);\n      }\n\n      return updatePayload;\n    }\n\n    function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n      var attributeConfig = void 0;\n      var nextProp = void 0;\n      var prevProp = void 0;\n\n      for (var propKey in nextProps) {\n        attributeConfig = validAttributes[propKey];\n\n        if (!attributeConfig) {\n          continue;\n        }\n\n        prevProp = prevProps[propKey];\n        nextProp = nextProps[propKey];\n\n        if (typeof nextProp === \"function\") {\n          nextProp = true;\n\n          if (typeof prevProp === \"function\") {\n            prevProp = true;\n          }\n        }\n\n        if (typeof nextProp === \"undefined\") {\n          nextProp = null;\n\n          if (typeof prevProp === \"undefined\") {\n            prevProp = null;\n          }\n        }\n\n        if (removedKeys) {\n          removedKeys[propKey] = false;\n        }\n\n        if (updatePayload && updatePayload[propKey] !== undefined) {\n          if (typeof attributeConfig !== \"object\") {\n            updatePayload[propKey] = nextProp;\n          } else if (typeof attributeConfig.diff === \"function\" || typeof attributeConfig.process === \"function\") {\n            var nextValue = typeof attributeConfig.process === \"function\" ? attributeConfig.process(nextProp) : nextProp;\n            updatePayload[propKey] = nextValue;\n          }\n\n          continue;\n        }\n\n        if (prevProp === nextProp) {\n          continue;\n        }\n\n        if (typeof attributeConfig !== \"object\") {\n          if (defaultDiffer(prevProp, nextProp)) {\n            (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n          }\n        } else if (typeof attributeConfig.diff === \"function\" || typeof attributeConfig.process === \"function\") {\n          var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === \"function\" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));\n\n          if (shouldUpdate) {\n            var _nextValue = typeof attributeConfig.process === \"function\" ? attributeConfig.process(nextProp) : nextProp;\n\n            (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n          }\n        } else {\n          removedKeys = null;\n          removedKeyCount = 0;\n          updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);\n\n          if (removedKeyCount > 0 && updatePayload) {\n            restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);\n            removedKeys = null;\n          }\n        }\n      }\n\n      for (var _propKey in prevProps) {\n        if (nextProps[_propKey] !== undefined) {\n          continue;\n        }\n\n        attributeConfig = validAttributes[_propKey];\n\n        if (!attributeConfig) {\n          continue;\n        }\n\n        if (updatePayload && updatePayload[_propKey] !== undefined) {\n          continue;\n        }\n\n        prevProp = prevProps[_propKey];\n\n        if (prevProp === undefined) {\n          continue;\n        }\n\n        if (typeof attributeConfig !== \"object\" || typeof attributeConfig.diff === \"function\" || typeof attributeConfig.process === \"function\") {\n          (updatePayload || (updatePayload = {}))[_propKey] = null;\n\n          if (!removedKeys) {\n            removedKeys = {};\n          }\n\n          if (!removedKeys[_propKey]) {\n            removedKeys[_propKey] = true;\n            removedKeyCount++;\n          }\n        } else {\n          updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);\n        }\n      }\n\n      return updatePayload;\n    }\n\n    function addProperties(updatePayload, props, validAttributes) {\n      return diffProperties(updatePayload, emptyObject, props, validAttributes);\n    }\n\n    function clearProperties(updatePayload, prevProps, validAttributes) {\n      return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n    }\n\n    function create(props, validAttributes) {\n      return addProperties(null, props, validAttributes);\n    }\n\n    function diff(prevProps, nextProps, validAttributes) {\n      return diffProperties(null, prevProps, nextProps, validAttributes);\n    }\n\n    function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {\n      return function () {\n        if (!callback) {\n          return undefined;\n        }\n\n        if (typeof context.__isMounted === \"boolean\") {\n          if (!context.__isMounted) {\n            return undefined;\n          }\n        }\n\n        return callback.apply(context, arguments);\n      };\n    }\n\n    function throwOnStylesProp(component, props) {\n      if (props.styles !== undefined) {\n        var owner = component._owner || null;\n        var name = component.constructor.displayName;\n        var msg = \"`styles` is not a supported property of `\" + name + \"`, did \" + \"you mean `style` (singular)?\";\n\n        if (owner && owner.constructor && owner.constructor.displayName) {\n          msg += \"\\n\\nCheck the `\" + owner.constructor.displayName + \"` parent \" + \" component.\";\n        }\n\n        throw new Error(msg);\n      }\n    }\n\n    function warnForStyleProps(props, validAttributes) {\n      for (var key in validAttributes.style) {\n        if (!(validAttributes[key] || props[key] === undefined)) {\n          console.error(\"You are setting the style `{ \" + key + \": ... }` as a prop. You \" + \"should nest it in a style object. \" + \"E.g. `{ style: { \" + key + \": ... } }`\");\n        }\n      }\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    var ReactNativeFiberHostComponent = function () {\n      function ReactNativeFiberHostComponent(tag, viewConfig) {\n        _classCallCheck(this, ReactNativeFiberHostComponent);\n\n        this._nativeTag = tag;\n        this._children = [];\n        this.viewConfig = viewConfig;\n      }\n\n      ReactNativeFiberHostComponent.prototype.blur = function blur() {\n        TextInputState.blurTextInput(this._nativeTag);\n      };\n\n      ReactNativeFiberHostComponent.prototype.focus = function focus() {\n        TextInputState.focusTextInput(this._nativeTag);\n      };\n\n      ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n        UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n      };\n\n      ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(callback) {\n        UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n      };\n\n      ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {\n        UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));\n      };\n\n      ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {\n        {\n          warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n        }\n        var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n        if (updatePayload != null) {\n          UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);\n        }\n      };\n\n      return ReactNativeFiberHostComponent;\n    }();\n\n    var hasNativePerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n    var now$1 = hasNativePerformanceNow ? function () {\n      return performance.now();\n    } : function () {\n      return Date.now();\n    };\n    var scheduledCallback = null;\n    var frameDeadline = 0;\n    var frameDeadlineObject = {\n      timeRemaining: function timeRemaining() {\n        return frameDeadline - now$1();\n      },\n      didTimeout: false\n    };\n\n    function setTimeoutCallback() {\n      frameDeadline = now$1() + 5;\n      var callback = scheduledCallback;\n      scheduledCallback = null;\n\n      if (callback !== null) {\n        callback(frameDeadlineObject);\n      }\n    }\n\n    function scheduleDeferredCallback$1(callback, options) {\n      scheduledCallback = callback;\n      var timeoutId = setTimeout(setTimeoutCallback, 1);\n      return timeoutId;\n    }\n\n    function cancelDeferredCallback$1(callbackID) {\n      scheduledCallback = null;\n      clearTimeout(callbackID);\n    }\n\n    function shim() {\n      invariant(false, \"The current renderer does not support persistence. \" + \"This error is likely caused by a bug in React. \" + \"Please file an issue.\");\n    }\n\n    var supportsPersistence = false;\n    var cloneInstance = shim;\n    var createContainerChildSet = shim;\n    var appendChildToContainerChildSet = shim;\n    var finalizeContainerChildren = shim;\n    var replaceContainerChildren = shim;\n\n    function shim$1() {\n      invariant(false, \"The current renderer does not support hyration. \" + \"This error is likely caused by a bug in React. \" + \"Please file an issue.\");\n    }\n\n    var supportsHydration = false;\n    var canHydrateInstance = shim$1;\n    var canHydrateTextInstance = shim$1;\n    var getNextHydratableSibling = shim$1;\n    var getFirstHydratableChild = shim$1;\n    var hydrateInstance = shim$1;\n    var hydrateTextInstance = shim$1;\n    var didNotMatchHydratedContainerTextInstance = shim$1;\n    var didNotMatchHydratedTextInstance = shim$1;\n    var didNotHydrateContainerInstance = shim$1;\n    var didNotHydrateInstance = shim$1;\n    var didNotFindHydratableContainerInstance = shim$1;\n    var didNotFindHydratableContainerTextInstance = shim$1;\n    var didNotFindHydratableInstance = shim$1;\n    var didNotFindHydratableTextInstance = shim$1;\n    var UPDATE_SIGNAL = {};\n    {\n      Object.freeze(UPDATE_SIGNAL);\n    }\n    var nextReactTag = 3;\n\n    function allocateTag() {\n      var tag = nextReactTag;\n\n      if (tag % 10 === 1) {\n        tag += 2;\n      }\n\n      nextReactTag = tag + 2;\n      return tag;\n    }\n\n    function recursivelyUncacheFiberNode(node) {\n      if (typeof node === \"number\") {\n        uncacheFiberNode(node);\n      } else {\n        uncacheFiberNode(node._nativeTag);\n\n        node._children.forEach(recursivelyUncacheFiberNode);\n      }\n    }\n\n    function appendInitialChild(parentInstance, child) {\n      parentInstance._children.push(child);\n    }\n\n    function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      var tag = allocateTag();\n      var viewConfig = ReactNativeViewConfigRegistry.get(type);\n      {\n        for (var key in viewConfig.validAttributes) {\n          if (props.hasOwnProperty(key)) {\n            deepFreezeAndThrowOnMutationInDev(props[key]);\n          }\n        }\n      }\n      invariant(type !== \"RCTView\" || !hostContext.isInAParentText, \"Nesting of <View> within <Text> is not currently supported.\");\n      var updatePayload = create(props, viewConfig.validAttributes);\n      UIManager.createView(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload);\n      var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n      precacheFiberNode(internalInstanceHandle, tag);\n      updateFiberProps(tag, props);\n      return component;\n    }\n\n    function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n      invariant(hostContext.isInAParentText, \"Text strings must be rendered within a <Text> component.\");\n      var tag = allocateTag();\n      UIManager.createView(tag, \"RCTRawText\", rootContainerInstance, {\n        text: text\n      });\n      precacheFiberNode(internalInstanceHandle, tag);\n      return tag;\n    }\n\n    function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {\n      if (parentInstance._children.length === 0) {\n        return false;\n      }\n\n      var nativeTags = parentInstance._children.map(function (child) {\n        return typeof child === \"number\" ? child : child._nativeTag;\n      });\n\n      UIManager.setChildren(parentInstance._nativeTag, nativeTags);\n      return false;\n    }\n\n    function getRootHostContext(rootContainerInstance) {\n      return {\n        isInAParentText: false\n      };\n    }\n\n    function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n      var prevIsInAParentText = parentHostContext.isInAParentText;\n      var isInAParentText = type === \"AndroidTextInput\" || type === \"RCTMultilineTextInputView\" || type === \"RCTSinglelineTextInputView\" || type === \"RCTText\" || type === \"RCTVirtualText\";\n\n      if (prevIsInAParentText !== isInAParentText) {\n        return {\n          isInAParentText: isInAParentText\n        };\n      } else {\n        return parentHostContext;\n      }\n    }\n\n    function getPublicInstance(instance) {\n      return instance;\n    }\n\n    function prepareForCommit(containerInfo) {}\n\n    function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {\n      return UPDATE_SIGNAL;\n    }\n\n    function resetAfterCommit(containerInfo) {}\n\n    var now = now$1;\n    var isPrimaryRenderer = true;\n    var scheduleDeferredCallback = scheduleDeferredCallback$1;\n    var cancelDeferredCallback = cancelDeferredCallback$1;\n    var scheduleTimeout = setTimeout;\n    var cancelTimeout = clearTimeout;\n    var noTimeout = -1;\n\n    function shouldDeprioritizeSubtree(type, props) {\n      return false;\n    }\n\n    function shouldSetTextContent(type, props) {\n      return false;\n    }\n\n    var supportsMutation = true;\n\n    function appendChild(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      if (index >= 0) {\n        children.splice(index, 1);\n        children.push(child);\n        UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], []);\n      } else {\n        children.push(child);\n        UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []);\n      }\n    }\n\n    function appendChildToContainer(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      UIManager.setChildren(parentInstance, [childTag]);\n    }\n\n    function commitTextUpdate(textInstance, oldText, newText) {\n      UIManager.updateView(textInstance, \"RCTRawText\", {\n        text: newText\n      });\n    }\n\n    function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps, internalInstanceHandle) {\n      var viewConfig = instance.viewConfig;\n      updateFiberProps(instance._nativeTag, newProps);\n      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n      if (updatePayload != null) {\n        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);\n      }\n    }\n\n    function insertBefore(parentInstance, child, beforeChild) {\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      if (index >= 0) {\n        children.splice(index, 1);\n        var beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(beforeChildIndex, 0, child);\n        UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChildIndex], [], [], []);\n      } else {\n        var _beforeChildIndex = children.indexOf(beforeChild);\n\n        children.splice(_beforeChildIndex, 0, child);\n        var childTag = typeof child === \"number\" ? child : child._nativeTag;\n        UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [_beforeChildIndex], []);\n      }\n    }\n\n    function insertInContainerBefore(parentInstance, child, beforeChild) {\n      invariant(typeof parentInstance !== \"number\", \"Container does not support insertBefore operation\");\n    }\n\n    function removeChild(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n      children.splice(index, 1);\n      UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [index]);\n    }\n\n    function removeChildFromContainer(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      UIManager.manageChildren(parentInstance, [], [], [], [], [0]);\n    }\n\n    function resetTextContent(instance) {}\n\n    var BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\n    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {\n      var sourceInfo = \"\";\n\n      if (source) {\n        var path = source.fileName;\n        var fileName = path.replace(BEFORE_SLASH_RE, \"\");\n        {\n          if (/^index\\./.test(fileName)) {\n            var match = path.match(BEFORE_SLASH_RE);\n\n            if (match) {\n              var pathBeforeSlash = match[1];\n\n              if (pathBeforeSlash) {\n                var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, \"\");\n                fileName = folderName + \"/\" + fileName;\n              }\n            }\n          }\n        }\n        sourceInfo = \" (at \" + fileName + \":\" + source.lineNumber + \")\";\n      } else if (ownerName) {\n        sourceInfo = \" (created by \" + ownerName + \")\";\n      }\n\n      return \"\\n    in \" + (name || \"Unknown\") + sourceInfo;\n    };\n\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case FunctionalComponentLazy:\n        case ClassComponent:\n        case ClassComponentLazy:\n        case HostComponent:\n        case Mode:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName(fiber.type);\n          var ownerName = null;\n\n          if (owner) {\n            ownerName = getComponentName(owner.type);\n          }\n\n          return describeComponentFrame(name, source, ownerName);\n\n        default:\n          return \"\";\n      }\n    }\n\n    function getStackByFiberInDevAndProd(workInProgress) {\n      var info = \"\";\n      var node = workInProgress;\n\n      do {\n        info += describeFiber(node);\n        node = node.return;\n      } while (node);\n\n      return info;\n    }\n\n    var current = null;\n    var phase = null;\n\n    function getCurrentFiberOwnerNameInDevOrNull() {\n      {\n        if (current === null) {\n          return null;\n        }\n\n        var owner = current._debugOwner;\n\n        if (owner !== null && typeof owner !== \"undefined\") {\n          return getComponentName(owner.type);\n        }\n      }\n      return null;\n    }\n\n    function getCurrentFiberStackInDev() {\n      {\n        if (current === null) {\n          return \"\";\n        }\n\n        return getStackByFiberInDevAndProd(current);\n      }\n      return \"\";\n    }\n\n    function resetCurrentFiber() {\n      {\n        ReactDebugCurrentFrame.getCurrentStack = null;\n        current = null;\n        phase = null;\n      }\n    }\n\n    function setCurrentFiber(fiber) {\n      {\n        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n        current = fiber;\n        phase = null;\n      }\n    }\n\n    function setCurrentPhase(lifeCyclePhase) {\n      {\n        phase = lifeCyclePhase;\n      }\n    }\n\n    var debugRenderPhaseSideEffects = false;\n    var debugRenderPhaseSideEffectsForStrictMode = false;\n    var enableGetDerivedStateFromCatch = false;\n    var enableSuspense = false;\n    var enableUserTimingAPI = true;\n    var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n    var warnAboutDeprecatedLifecycles = false;\n    var warnAboutLegacyContextAPI = false;\n    var enableProfilerTimer = true;\n    var enableSchedulerTracking = true;\n    var reactEmoji = \"\\u269B\";\n    var warningEmoji = \"\\u26D4\";\n    var supportsUserTiming = typeof performance !== \"undefined\" && typeof performance.mark === \"function\" && typeof performance.clearMarks === \"function\" && typeof performance.measure === \"function\" && typeof performance.clearMeasures === \"function\";\n    var currentFiber = null;\n    var currentPhase = null;\n    var currentPhaseFiber = null;\n    var isCommitting = false;\n    var hasScheduledUpdateInCurrentCommit = false;\n    var hasScheduledUpdateInCurrentPhase = false;\n    var commitCountInCurrentWorkLoop = 0;\n    var effectCountInCurrentCommit = 0;\n    var isWaitingForCallback = false;\n    var labelsInCurrentCommit = new Set();\n\n    var formatMarkName = function formatMarkName(markName) {\n      return reactEmoji + \" \" + markName;\n    };\n\n    var formatLabel = function formatLabel(label, warning) {\n      var prefix = warning ? warningEmoji + \" \" : reactEmoji + \" \";\n      var suffix = warning ? \" Warning: \" + warning : \"\";\n      return \"\" + prefix + label + suffix;\n    };\n\n    var beginMark = function beginMark(markName) {\n      performance.mark(formatMarkName(markName));\n    };\n\n    var clearMark = function clearMark(markName) {\n      performance.clearMarks(formatMarkName(markName));\n    };\n\n    var endMark = function endMark(label, markName, warning) {\n      var formattedMarkName = formatMarkName(markName);\n      var formattedLabel = formatLabel(label, warning);\n\n      try {\n        performance.measure(formattedLabel, formattedMarkName);\n      } catch (err) {}\n\n      performance.clearMarks(formattedMarkName);\n      performance.clearMeasures(formattedLabel);\n    };\n\n    var getFiberMarkName = function getFiberMarkName(label, debugID) {\n      return label + \" (#\" + debugID + \")\";\n    };\n\n    var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {\n      if (phase === null) {\n        return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n      } else {\n        return componentName + \".\" + phase;\n      }\n    };\n\n    var beginFiberMark = function beginFiberMark(fiber, phase) {\n      var componentName = getComponentName(fiber.type) || \"Unknown\";\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n\n      if (isCommitting && labelsInCurrentCommit.has(label)) {\n        return false;\n      }\n\n      labelsInCurrentCommit.add(label);\n      var markName = getFiberMarkName(label, debugID);\n      beginMark(markName);\n      return true;\n    };\n\n    var clearFiberMark = function clearFiberMark(fiber, phase) {\n      var componentName = getComponentName(fiber.type) || \"Unknown\";\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      clearMark(markName);\n    };\n\n    var endFiberMark = function endFiberMark(fiber, phase, warning) {\n      var componentName = getComponentName(fiber.type) || \"Unknown\";\n      var debugID = fiber._debugID;\n      var isMounted = fiber.alternate !== null;\n      var label = getFiberLabel(componentName, isMounted, phase);\n      var markName = getFiberMarkName(label, debugID);\n      endMark(label, markName, warning);\n    };\n\n    var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {\n      switch (fiber.tag) {\n        case HostRoot:\n        case HostComponent:\n        case HostText:\n        case HostPortal:\n        case Fragment:\n        case ContextProvider:\n        case ContextConsumer:\n        case Mode:\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {\n      if (currentPhase !== null && currentPhaseFiber !== null) {\n        clearFiberMark(currentPhaseFiber, currentPhase);\n      }\n\n      currentPhaseFiber = null;\n      currentPhase = null;\n      hasScheduledUpdateInCurrentPhase = false;\n    };\n\n    var pauseTimers = function pauseTimers() {\n      var fiber = currentFiber;\n\n      while (fiber) {\n        if (fiber._debugIsCurrentlyTiming) {\n          endFiberMark(fiber, null, null);\n        }\n\n        fiber = fiber.return;\n      }\n    };\n\n    var resumeTimersRecursively = function resumeTimersRecursively(fiber) {\n      if (fiber.return !== null) {\n        resumeTimersRecursively(fiber.return);\n      }\n\n      if (fiber._debugIsCurrentlyTiming) {\n        beginFiberMark(fiber, null);\n      }\n    };\n\n    var resumeTimers = function resumeTimers() {\n      if (currentFiber !== null) {\n        resumeTimersRecursively(currentFiber);\n      }\n    };\n\n    function recordEffect() {\n      if (enableUserTimingAPI) {\n        effectCountInCurrentCommit++;\n      }\n    }\n\n    function recordScheduleUpdate() {\n      if (enableUserTimingAPI) {\n        if (isCommitting) {\n          hasScheduledUpdateInCurrentCommit = true;\n        }\n\n        if (currentPhase !== null && currentPhase !== \"componentWillMount\" && currentPhase !== \"componentWillReceiveProps\") {\n          hasScheduledUpdateInCurrentPhase = true;\n        }\n      }\n    }\n\n    function startRequestCallbackTimer() {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming && !isWaitingForCallback) {\n          isWaitingForCallback = true;\n          beginMark(\"(Waiting for async callback...)\");\n        }\n      }\n    }\n\n    function stopRequestCallbackTimer(didExpire, expirationTime) {\n      if (enableUserTimingAPI) {\n        if (supportsUserTiming) {\n          isWaitingForCallback = false;\n          var warning = didExpire ? \"React was blocked by main thread\" : null;\n          endMark(\"(Waiting for async callback... will force flush in \" + expirationTime + \" ms)\", \"(Waiting for async callback...)\", warning);\n        }\n      }\n    }\n\n    function startWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        }\n\n        currentFiber = fiber;\n\n        if (!beginFiberMark(fiber, null)) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = true;\n      }\n    }\n\n    function cancelWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        clearFiberMark(fiber, null);\n      }\n    }\n\n    function stopWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        }\n\n        currentFiber = fiber.return;\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        endFiberMark(fiber, null, null);\n      }\n    }\n\n    function stopFailedWorkTimer(fiber) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n          return;\n        }\n\n        currentFiber = fiber.return;\n\n        if (!fiber._debugIsCurrentlyTiming) {\n          return;\n        }\n\n        fiber._debugIsCurrentlyTiming = false;\n        var warning = \"An error was thrown inside this error boundary\";\n        endFiberMark(fiber, null, warning);\n      }\n    }\n\n    function startPhaseTimer(fiber, phase) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        clearPendingPhaseMeasurement();\n\n        if (!beginFiberMark(fiber, phase)) {\n          return;\n        }\n\n        currentPhaseFiber = fiber;\n        currentPhase = phase;\n      }\n    }\n\n    function stopPhaseTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          var warning = hasScheduledUpdateInCurrentPhase ? \"Scheduled a cascading update\" : null;\n          endFiberMark(currentPhaseFiber, currentPhase, warning);\n        }\n\n        currentPhase = null;\n        currentPhaseFiber = null;\n      }\n    }\n\n    function startWorkLoopTimer(nextUnitOfWork) {\n      if (enableUserTimingAPI) {\n        currentFiber = nextUnitOfWork;\n\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        commitCountInCurrentWorkLoop = 0;\n        beginMark(\"(React Tree Reconciliation)\");\n        resumeTimers();\n      }\n    }\n\n    function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning = null;\n\n        if (interruptedBy !== null) {\n          if (interruptedBy.tag === HostRoot) {\n            warning = \"A top-level update interrupted the previous render\";\n          } else {\n            var componentName = getComponentName(interruptedBy.type) || \"Unknown\";\n            warning = \"An update to \" + componentName + \" interrupted the previous render\";\n          }\n        } else if (commitCountInCurrentWorkLoop > 1) {\n          warning = \"There were cascading updates\";\n        }\n\n        commitCountInCurrentWorkLoop = 0;\n        var label = didCompleteRoot ? \"(React Tree Reconciliation: Completed Root)\" : \"(React Tree Reconciliation: Yielded)\";\n        pauseTimers();\n        endMark(label, \"(React Tree Reconciliation)\", warning);\n      }\n    }\n\n    function startCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        isCommitting = true;\n        hasScheduledUpdateInCurrentCommit = false;\n        labelsInCurrentCommit.clear();\n        beginMark(\"(Committing Changes)\");\n      }\n    }\n\n    function stopCommitTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var warning = null;\n\n        if (hasScheduledUpdateInCurrentCommit) {\n          warning = \"Lifecycle hook scheduled a cascading update\";\n        } else if (commitCountInCurrentWorkLoop > 0) {\n          warning = \"Caused by a cascading update in earlier commit\";\n        }\n\n        hasScheduledUpdateInCurrentCommit = false;\n        commitCountInCurrentWorkLoop++;\n        isCommitting = false;\n        labelsInCurrentCommit.clear();\n        endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning);\n      }\n    }\n\n    function startCommitSnapshotEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark(\"(Committing Snapshot Effects)\");\n      }\n    }\n\n    function stopCommitSnapshotEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark(\"(Committing Snapshot Effects: \" + count + \" Total)\", \"(Committing Snapshot Effects)\", null);\n      }\n    }\n\n    function startCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark(\"(Committing Host Effects)\");\n      }\n    }\n\n    function stopCommitHostEffectsTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark(\"(Committing Host Effects: \" + count + \" Total)\", \"(Committing Host Effects)\", null);\n      }\n    }\n\n    function startCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        effectCountInCurrentCommit = 0;\n        beginMark(\"(Calling Lifecycle Methods)\");\n      }\n    }\n\n    function stopCommitLifeCyclesTimer() {\n      if (enableUserTimingAPI) {\n        if (!supportsUserTiming) {\n          return;\n        }\n\n        var count = effectCountInCurrentCommit;\n        effectCountInCurrentCommit = 0;\n        endMark(\"(Calling Lifecycle Methods: \" + count + \" Total)\", \"(Calling Lifecycle Methods)\", null);\n      }\n    }\n\n    var valueStack = [];\n    var fiberStack = void 0;\n    {\n      fiberStack = [];\n    }\n    var index = -1;\n\n    function createCursor(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    }\n\n    function pop(cursor, fiber) {\n      if (index < 0) {\n        {\n          warningWithoutStack$1(false, \"Unexpected pop.\");\n        }\n        return;\n      }\n\n      {\n        if (fiber !== fiberStack[index]) {\n          warningWithoutStack$1(false, \"Unexpected Fiber popped.\");\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    }\n\n    function push(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    }\n\n    function checkThatStackIsEmpty() {\n      {\n        if (index !== -1) {\n          warningWithoutStack$1(false, \"Expected an empty stack. Something was not reset properly.\");\n        }\n      }\n    }\n\n    function resetStackAfterFatalErrorInDev() {\n      {\n        index = -1;\n        valueStack.length = 0;\n        fiberStack.length = 0;\n      }\n    }\n\n    var warnedAboutMissingGetChildContext = void 0;\n    {\n      warnedAboutMissingGetChildContext = {};\n    }\n    var emptyContextObject = {};\n    {\n      Object.freeze(emptyContextObject);\n    }\n    var contextStackCursor = createCursor(emptyContextObject);\n    var didPerformWorkStackCursor = createCursor(false);\n    var previousContext = emptyContextObject;\n\n    function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n      if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n        return previousContext;\n      }\n\n      return contextStackCursor.current;\n    }\n\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n\n    function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n\n      if (!contextTypes) {\n        return emptyContextObject;\n      }\n\n      var instance = workInProgress.stateNode;\n\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n\n      var context = {};\n\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n\n      {\n        var name = getComponentName(type) || \"Unknown\";\n        checkPropTypes(contextTypes, context, \"context\", name, getCurrentFiberStackInDev);\n      }\n\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return context;\n    }\n\n    function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    }\n\n    function isContextProvider(type) {\n      var childContextTypes = type.childContextTypes;\n      return childContextTypes !== null && childContextTypes !== undefined;\n    }\n\n    function popContext(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    function pushTopLevelContextObject(fiber, context, didChange) {\n      invariant(contextStackCursor.current === emptyContextObject, \"Unexpected context found on stack. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    }\n\n    function processChildContext(fiber, type, parentContext) {\n      var instance = fiber.stateNode;\n      var childContextTypes = type.childContextTypes;\n\n      if (typeof instance.getChildContext !== \"function\") {\n        {\n          var componentName = getComponentName(type) || \"Unknown\";\n\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warningWithoutStack$1(false, \"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n\n      var childContext = void 0;\n      {\n        setCurrentPhase(\"getChildContext\");\n      }\n      startPhaseTimer(fiber, \"getChildContext\");\n      childContext = instance.getChildContext();\n      stopPhaseTimer();\n      {\n        setCurrentPhase(null);\n      }\n\n      for (var contextKey in childContext) {\n        invariant(contextKey in childContextTypes, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(type) || \"Unknown\", contextKey);\n      }\n\n      {\n        var name = getComponentName(type) || \"Unknown\";\n        checkPropTypes(childContextTypes, childContext, \"child context\", name, getCurrentFiberStackInDev);\n      }\n      return _extends({}, parentContext, childContext);\n    }\n\n    function pushContextProvider(workInProgress) {\n      var instance = workInProgress.stateNode;\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    }\n\n    function invalidateContextProvider(workInProgress, type, didChange) {\n      var instance = workInProgress.stateNode;\n      invariant(instance, \"Expected to have an instance by this point. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n\n      if (didChange) {\n        var mergedContext = processChildContext(workInProgress, type, previousContext);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress);\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    }\n\n    function findCurrentUnmaskedContext(fiber) {\n      invariant(isFiberMounted(fiber) && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy), \"Expected subtree parent to be a mounted class component. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n      var node = fiber;\n\n      do {\n        switch (node.tag) {\n          case HostRoot:\n            return node.stateNode.context;\n\n          case ClassComponent:\n            {\n              var Component = node.type;\n\n              if (isContextProvider(Component)) {\n                return node.stateNode.__reactInternalMemoizedMergedChildContext;\n              }\n\n              break;\n            }\n\n          case ClassComponentLazy:\n            {\n              var _Component = getResultFromResolvedThenable(node.type);\n\n              if (isContextProvider(_Component)) {\n                return node.stateNode.__reactInternalMemoizedMergedChildContext;\n              }\n\n              break;\n            }\n        }\n\n        node = node.return;\n      } while (node !== null);\n\n      invariant(false, \"Found unexpected detached subtree parent. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n    }\n\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n    var hasLoggedError = false;\n\n    function catchErrors(fn) {\n      return function (arg) {\n        try {\n          return fn(arg);\n        } catch (err) {\n          if (true && !hasLoggedError) {\n            hasLoggedError = true;\n            warningWithoutStack$1(false, \"React DevTools encountered an error: %s\", err);\n          }\n        }\n      };\n    }\n\n    var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n\n    function injectInternals(internals) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n        return false;\n      }\n\n      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n      if (hook.isDisabled) {\n        return true;\n      }\n\n      if (!hook.supportsFiber) {\n        {\n          warningWithoutStack$1(false, \"The installed version of React DevTools is too old and will not work \" + \"with the current version of React. Please update React DevTools. \" + \"https://fb.me/react-devtools\");\n        }\n        return true;\n      }\n\n      try {\n        var rendererID = hook.inject(internals);\n        onCommitFiberRoot = catchErrors(function (root) {\n          return hook.onCommitFiberRoot(rendererID, root);\n        });\n        onCommitFiberUnmount = catchErrors(function (fiber) {\n          return hook.onCommitFiberUnmount(rendererID, fiber);\n        });\n      } catch (err) {\n        {\n          warningWithoutStack$1(false, \"React DevTools encountered an error: %s.\", err);\n        }\n      }\n\n      return true;\n    }\n\n    function onCommitRoot(root) {\n      if (typeof onCommitFiberRoot === \"function\") {\n        onCommitFiberRoot(root);\n      }\n    }\n\n    function onCommitUnmount(fiber) {\n      if (typeof onCommitFiberUnmount === \"function\") {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n\n    var maxSigned31BitInt = 1073741823;\n    var NoWork = 0;\n    var Sync = 1;\n    var Never = maxSigned31BitInt;\n    var UNIT_SIZE = 10;\n    var MAGIC_NUMBER_OFFSET = 2;\n\n    function msToExpirationTime(ms) {\n      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n    }\n\n    function expirationTimeToMs(expirationTime) {\n      return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n    }\n\n    function ceiling(num, precision) {\n      return ((num / precision | 0) + 1) * precision;\n    }\n\n    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n      return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n    }\n\n    var LOW_PRIORITY_EXPIRATION = 5000;\n    var LOW_PRIORITY_BATCH_SIZE = 250;\n\n    function computeAsyncExpiration(currentTime) {\n      return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);\n    }\n\n    var HIGH_PRIORITY_EXPIRATION = 500;\n    var HIGH_PRIORITY_BATCH_SIZE = 100;\n\n    function computeInteractiveExpiration(currentTime) {\n      return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);\n    }\n\n    var NoContext = 0;\n    var AsyncMode = 1;\n    var StrictMode = 2;\n    var ProfileMode = 4;\n    var hasBadMapPolyfill = void 0;\n    {\n      hasBadMapPolyfill = false;\n\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        var testMap = new Map([[nonExtensibleObject, null]]);\n        var testSet = new Set([nonExtensibleObject]);\n        testMap.set(0, 0);\n        testSet.add(0);\n      } catch (e) {\n        hasBadMapPolyfill = true;\n      }\n    }\n    var debugCounter = void 0;\n    {\n      debugCounter = 1;\n    }\n\n    function FiberNode(tag, pendingProps, key, mode) {\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null;\n      this.return = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = pendingProps;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.firstContextDependency = null;\n      this.mode = mode;\n      this.effectTag = NoEffect;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.expirationTime = NoWork;\n      this.childExpirationTime = NoWork;\n      this.alternate = null;\n\n      if (enableProfilerTimer) {\n        this.actualDuration = 0;\n        this.actualStartTime = -1;\n        this.selfBaseDuration = 0;\n        this.treeBaseDuration = 0;\n      }\n\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n          Object.preventExtensions(this);\n        }\n      }\n    }\n\n    var createFiber = function createFiber(tag, pendingProps, key, mode) {\n      return new FiberNode(tag, pendingProps, key, mode);\n    };\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function resolveLazyComponentTag(fiber, Component) {\n      if (typeof Component === \"function\") {\n        return shouldConstruct(Component) ? ClassComponentLazy : FunctionalComponentLazy;\n      } else if (Component !== undefined && Component !== null && Component.$$typeof) {\n        return ForwardRefLazy;\n      }\n\n      return IndeterminateComponent;\n    }\n\n    function createWorkInProgress(current, pendingProps, expirationTime) {\n      var workInProgress = current.alternate;\n\n      if (workInProgress === null) {\n        workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        workInProgress.pendingProps = pendingProps;\n        workInProgress.effectTag = NoEffect;\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n\n        if (enableProfilerTimer) {\n          workInProgress.actualDuration = 0;\n          workInProgress.actualStartTime = -1;\n        }\n      }\n\n      workInProgress.childExpirationTime = current.childExpirationTime;\n\n      if (pendingProps !== current.pendingProps) {\n        workInProgress.expirationTime = expirationTime;\n      } else {\n        workInProgress.expirationTime = current.expirationTime;\n      }\n\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue;\n      workInProgress.firstContextDependency = current.firstContextDependency;\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n\n      if (enableProfilerTimer) {\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n      }\n\n      return workInProgress;\n    }\n\n    function createHostRootFiber(isAsync) {\n      var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n\n      if (enableProfilerTimer && isDevToolsPresent) {\n        mode |= ProfileMode;\n      }\n\n      return createFiber(HostRoot, null, null, mode);\n    }\n\n    function createFiberFromElement(element, mode, expirationTime) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = void 0;\n      var type = element.type;\n      var key = element.key;\n      var pendingProps = element.props;\n      var fiberTag = void 0;\n\n      if (typeof type === \"function\") {\n        fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n      } else if (typeof type === \"string\") {\n        fiberTag = HostComponent;\n      } else {\n        getTag: switch (type) {\n          case REACT_FRAGMENT_TYPE:\n            return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n\n          case REACT_ASYNC_MODE_TYPE:\n            fiberTag = Mode;\n            mode |= AsyncMode | StrictMode;\n            break;\n\n          case REACT_STRICT_MODE_TYPE:\n            fiberTag = Mode;\n            mode |= StrictMode;\n            break;\n\n          case REACT_PROFILER_TYPE:\n            return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n\n          case REACT_PLACEHOLDER_TYPE:\n            fiberTag = PlaceholderComponent;\n            break;\n\n          default:\n            {\n              if (typeof type === \"object\" && type !== null) {\n                switch (type.$$typeof) {\n                  case REACT_PROVIDER_TYPE:\n                    fiberTag = ContextProvider;\n                    break getTag;\n\n                  case REACT_CONTEXT_TYPE:\n                    fiberTag = ContextConsumer;\n                    break getTag;\n\n                  case REACT_FORWARD_REF_TYPE:\n                    fiberTag = ForwardRef;\n                    break getTag;\n\n                  default:\n                    {\n                      if (typeof type.then === \"function\") {\n                        fiberTag = IndeterminateComponent;\n                        break getTag;\n                      }\n                    }\n                }\n              }\n\n              var info = \"\";\n              {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                  info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n\n                var ownerName = owner ? getComponentName(owner.type) : null;\n\n                if (ownerName) {\n                  info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                }\n              }\n              invariant(false, \"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + \"but got: %s.%s\", type == null ? type : typeof type, info);\n            }\n        }\n      }\n\n      fiber = createFiber(fiberTag, pendingProps, key, mode);\n      fiber.type = type;\n      fiber.expirationTime = expirationTime;\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      return fiber;\n    }\n\n    function createFiberFromFragment(elements, mode, expirationTime, key) {\n      var fiber = createFiber(Fragment, elements, key, mode);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n      {\n        if (typeof pendingProps.id !== \"string\" || typeof pendingProps.onRender !== \"function\") {\n          warningWithoutStack$1(false, 'Profiler must specify an \"id\" string and \"onRender\" function as props');\n        }\n      }\n      var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n      fiber.type = REACT_PROFILER_TYPE;\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromText(content, mode, expirationTime) {\n      var fiber = createFiber(HostText, content, null, mode);\n      fiber.expirationTime = expirationTime;\n      return fiber;\n    }\n\n    function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent, null, null, NoContext);\n      fiber.type = \"DELETED\";\n      return fiber;\n    }\n\n    function createFiberFromPortal(portal, mode, expirationTime) {\n      var pendingProps = portal.children !== null ? portal.children : [];\n      var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n      fiber.expirationTime = expirationTime;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        pendingChildren: null,\n        implementation: portal.implementation\n      };\n      return fiber;\n    }\n\n    function assignFiberPropertiesInDEV(target, source) {\n      if (target === null) {\n        target = createFiber(IndeterminateComponent, null, null, NoContext);\n      }\n\n      target.tag = source.tag;\n      target.key = source.key;\n      target.type = source.type;\n      target.stateNode = source.stateNode;\n      target.return = source.return;\n      target.child = source.child;\n      target.sibling = source.sibling;\n      target.index = source.index;\n      target.ref = source.ref;\n      target.pendingProps = source.pendingProps;\n      target.memoizedProps = source.memoizedProps;\n      target.updateQueue = source.updateQueue;\n      target.memoizedState = source.memoizedState;\n      target.firstContextDependency = source.firstContextDependency;\n      target.mode = source.mode;\n      target.effectTag = source.effectTag;\n      target.nextEffect = source.nextEffect;\n      target.firstEffect = source.firstEffect;\n      target.lastEffect = source.lastEffect;\n      target.expirationTime = source.expirationTime;\n      target.childExpirationTime = source.childExpirationTime;\n      target.alternate = source.alternate;\n\n      if (enableProfilerTimer) {\n        target.actualDuration = source.actualDuration;\n        target.actualStartTime = source.actualStartTime;\n        target.selfBaseDuration = source.selfBaseDuration;\n        target.treeBaseDuration = source.treeBaseDuration;\n      }\n\n      target._debugID = source._debugID;\n      target._debugSource = source._debugSource;\n      target._debugOwner = source._debugOwner;\n      target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n      return target;\n    }\n\n    function createFiberRoot(containerInfo, isAsync, hydrate) {\n      var uninitializedFiber = createHostRootFiber(isAsync);\n      var root = void 0;\n\n      if (enableSchedulerTracking) {\n        root = {\n          current: uninitializedFiber,\n          containerInfo: containerInfo,\n          pendingChildren: null,\n          earliestPendingTime: NoWork,\n          latestPendingTime: NoWork,\n          earliestSuspendedTime: NoWork,\n          latestSuspendedTime: NoWork,\n          latestPingedTime: NoWork,\n          didError: false,\n          pendingCommitExpirationTime: NoWork,\n          finishedWork: null,\n          timeoutHandle: noTimeout,\n          context: null,\n          pendingContext: null,\n          hydrate: hydrate,\n          nextExpirationTimeToWorkOn: NoWork,\n          expirationTime: NoWork,\n          firstBatch: null,\n          nextScheduledRoot: null,\n          interactionThreadID: tracking.unstable_getThreadID(),\n          memoizedInteractions: new Set(),\n          pendingInteractionMap: new Map()\n        };\n      } else {\n        root = {\n          current: uninitializedFiber,\n          containerInfo: containerInfo,\n          pendingChildren: null,\n          earliestPendingTime: NoWork,\n          latestPendingTime: NoWork,\n          earliestSuspendedTime: NoWork,\n          latestSuspendedTime: NoWork,\n          latestPingedTime: NoWork,\n          didError: false,\n          pendingCommitExpirationTime: NoWork,\n          finishedWork: null,\n          timeoutHandle: noTimeout,\n          context: null,\n          pendingContext: null,\n          hydrate: hydrate,\n          nextExpirationTimeToWorkOn: NoWork,\n          expirationTime: NoWork,\n          firstBatch: null,\n          nextScheduledRoot: null\n        };\n      }\n\n      uninitializedFiber.stateNode = root;\n      return root;\n    }\n\n    var lowPriorityWarning = function lowPriorityWarning() {};\n\n    {\n      var printWarning = function printWarning(format) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argIndex = 0;\n        var message = \"Warning: \" + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n\n        if (typeof console !== \"undefined\") {\n          console.warn(message);\n        }\n\n        try {\n          throw new Error(message);\n        } catch (x) {}\n      };\n\n      lowPriorityWarning = function lowPriorityWarning(condition, format) {\n        if (format === undefined) {\n          throw new Error(\"`lowPriorityWarning(condition, format, ...args)` requires a warning \" + \"message argument\");\n        }\n\n        if (!condition) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n\n          printWarning.apply(undefined, [format].concat(args));\n        }\n      };\n    }\n    var lowPriorityWarning$1 = lowPriorityWarning;\n    var ReactStrictModeWarnings = {\n      discardPendingWarnings: function discardPendingWarnings() {},\n      flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},\n      flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},\n      recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},\n      recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},\n      recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},\n      flushLegacyContextWarning: function flushLegacyContextWarning() {}\n    };\n    {\n      var LIFECYCLE_SUGGESTIONS = {\n        UNSAFE_componentWillMount: \"componentDidMount\",\n        UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n        UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n      };\n      var pendingComponentWillMountWarnings = [];\n      var pendingComponentWillReceivePropsWarnings = [];\n      var pendingComponentWillUpdateWarnings = [];\n      var pendingUnsafeLifecycleWarnings = new Map();\n      var pendingLegacyContextWarning = new Map();\n      var didWarnAboutDeprecatedLifecycles = new Set();\n      var didWarnAboutUnsafeLifecycles = new Set();\n      var didWarnAboutLegacyContext = new Set();\n\n      var setToSortedString = function setToSortedString(set) {\n        var array = [];\n        set.forEach(function (value) {\n          array.push(value);\n        });\n        return array.sort().join(\", \");\n      };\n\n      ReactStrictModeWarnings.discardPendingWarnings = function () {\n        pendingComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUnsafeLifecycleWarnings = new Map();\n        pendingLegacyContextWarning = new Map();\n      };\n\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n        pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n          var lifecyclesWarningMesages = [];\n          Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n            var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n\n            if (lifecycleWarnings.length > 0) {\n              var componentNames = new Set();\n              lifecycleWarnings.forEach(function (fiber) {\n                componentNames.add(getComponentName(fiber.type) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n              var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n              var sortedComponentNames = setToSortedString(componentNames);\n              lifecyclesWarningMesages.push(formatted + \": Please update the following components to use \" + (suggestion + \" instead: \" + sortedComponentNames));\n            }\n          });\n\n          if (lifecyclesWarningMesages.length > 0) {\n            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n            warningWithoutStack$1(false, \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" + \"\\n\\n%s\" + \"\\n\\nLearn more about this warning here:\" + \"\\nhttps://fb.me/react-strict-mode-warnings\", strictRootComponentStack, lifecyclesWarningMesages.join(\"\\n\\n\"));\n          }\n        });\n        pendingUnsafeLifecycleWarnings = new Map();\n      };\n\n      var findStrictRoot = function findStrictRoot(fiber) {\n        var maybeStrictRoot = null;\n        var node = fiber;\n\n        while (node !== null) {\n          if (node.mode & StrictMode) {\n            maybeStrictRoot = node;\n          }\n\n          node = node.return;\n        }\n\n        return maybeStrictRoot;\n      };\n\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n        if (pendingComponentWillMountWarnings.length > 0) {\n          var uniqueNames = new Set();\n          pendingComponentWillMountWarnings.forEach(function (fiber) {\n            uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n            didWarnAboutDeprecatedLifecycles.add(fiber.type);\n          });\n          var sortedNames = setToSortedString(uniqueNames);\n          lowPriorityWarning$1(false, \"componentWillMount is deprecated and will be removed in the next major version. \" + \"Use componentDidMount instead. As a temporary workaround, \" + \"you can rename to UNSAFE_componentWillMount.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here:\" + \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\", sortedNames);\n          pendingComponentWillMountWarnings = [];\n        }\n\n        if (pendingComponentWillReceivePropsWarnings.length > 0) {\n          var _uniqueNames = new Set();\n\n          pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n            _uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n\n            didWarnAboutDeprecatedLifecycles.add(fiber.type);\n          });\n\n          var _sortedNames = setToSortedString(_uniqueNames);\n\n          lowPriorityWarning$1(false, \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" + \"Use static getDerivedStateFromProps instead.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here:\" + \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\", _sortedNames);\n          pendingComponentWillReceivePropsWarnings = [];\n        }\n\n        if (pendingComponentWillUpdateWarnings.length > 0) {\n          var _uniqueNames2 = new Set();\n\n          pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n            _uniqueNames2.add(getComponentName(fiber.type) || \"Component\");\n\n            didWarnAboutDeprecatedLifecycles.add(fiber.type);\n          });\n\n          var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n          lowPriorityWarning$1(false, \"componentWillUpdate is deprecated and will be removed in the next major version. \" + \"Use componentDidUpdate instead. As a temporary workaround, \" + \"you can rename to UNSAFE_componentWillUpdate.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here:\" + \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\", _sortedNames2);\n          pendingComponentWillUpdateWarnings = [];\n        }\n      };\n\n      ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n        if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n          return;\n        }\n\n        if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n          pendingComponentWillMountWarnings.push(fiber);\n        }\n\n        if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n          pendingComponentWillReceivePropsWarnings.push(fiber);\n        }\n\n        if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n          pendingComponentWillUpdateWarnings.push(fiber);\n        }\n      };\n\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n        var strictRoot = findStrictRoot(fiber);\n\n        if (strictRoot === null) {\n          warningWithoutStack$1(false, \"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          return;\n        }\n\n        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n          return;\n        }\n\n        var warningsForRoot = void 0;\n\n        if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n          warningsForRoot = {\n            UNSAFE_componentWillMount: [],\n            UNSAFE_componentWillReceiveProps: [],\n            UNSAFE_componentWillUpdate: []\n          };\n          pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n        } else {\n          warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n        }\n\n        var unsafeLifecycles = [];\n\n        if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === \"function\") {\n          unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n        }\n\n        if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n          unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n        }\n\n        if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n          unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n        }\n\n        if (unsafeLifecycles.length > 0) {\n          unsafeLifecycles.forEach(function (lifecycle) {\n            warningsForRoot[lifecycle].push(fiber);\n          });\n        }\n      };\n\n      ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n        var strictRoot = findStrictRoot(fiber);\n\n        if (strictRoot === null) {\n          warningWithoutStack$1(false, \"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          return;\n        }\n\n        if (didWarnAboutLegacyContext.has(fiber.type)) {\n          return;\n        }\n\n        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n        if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n          if (warningsForRoot === undefined) {\n            warningsForRoot = [];\n            pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n          }\n\n          warningsForRoot.push(fiber);\n        }\n      };\n\n      ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n        pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n          var uniqueNames = new Set();\n          fiberArray.forEach(function (fiber) {\n            uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n            didWarnAboutLegacyContext.add(fiber.type);\n          });\n          var sortedNames = setToSortedString(uniqueNames);\n          var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n          warningWithoutStack$1(false, \"Legacy context API has been detected within a strict-mode tree: %s\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here:\" + \"\\nhttps://fb.me/react-strict-mode-warnings\", strictRootComponentStack, sortedNames);\n        });\n      };\n    }\n    var ReactFiberInstrumentation = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n    function markPendingPriorityLevel(root, expirationTime) {\n      root.didError = false;\n      var earliestPendingTime = root.earliestPendingTime;\n\n      if (earliestPendingTime === NoWork) {\n        root.earliestPendingTime = root.latestPendingTime = expirationTime;\n      } else {\n        if (earliestPendingTime > expirationTime) {\n          root.earliestPendingTime = expirationTime;\n        } else {\n          var latestPendingTime = root.latestPendingTime;\n\n          if (latestPendingTime < expirationTime) {\n            root.latestPendingTime = expirationTime;\n          }\n        }\n      }\n\n      findNextExpirationTimeToWorkOn(expirationTime, root);\n    }\n\n    function markCommittedPriorityLevels(root, earliestRemainingTime) {\n      root.didError = false;\n\n      if (earliestRemainingTime === NoWork) {\n        root.earliestPendingTime = NoWork;\n        root.latestPendingTime = NoWork;\n        root.earliestSuspendedTime = NoWork;\n        root.latestSuspendedTime = NoWork;\n        root.latestPingedTime = NoWork;\n        findNextExpirationTimeToWorkOn(NoWork, root);\n        return;\n      }\n\n      var latestPendingTime = root.latestPendingTime;\n\n      if (latestPendingTime !== NoWork) {\n        if (latestPendingTime < earliestRemainingTime) {\n          root.earliestPendingTime = root.latestPendingTime = NoWork;\n        } else {\n          var earliestPendingTime = root.earliestPendingTime;\n\n          if (earliestPendingTime < earliestRemainingTime) {\n            root.earliestPendingTime = root.latestPendingTime;\n          }\n        }\n      }\n\n      var earliestSuspendedTime = root.earliestSuspendedTime;\n\n      if (earliestSuspendedTime === NoWork) {\n        markPendingPriorityLevel(root, earliestRemainingTime);\n        findNextExpirationTimeToWorkOn(NoWork, root);\n        return;\n      }\n\n      var latestSuspendedTime = root.latestSuspendedTime;\n\n      if (earliestRemainingTime > latestSuspendedTime) {\n        root.earliestSuspendedTime = NoWork;\n        root.latestSuspendedTime = NoWork;\n        root.latestPingedTime = NoWork;\n        markPendingPriorityLevel(root, earliestRemainingTime);\n        findNextExpirationTimeToWorkOn(NoWork, root);\n        return;\n      }\n\n      if (earliestRemainingTime < earliestSuspendedTime) {\n        markPendingPriorityLevel(root, earliestRemainingTime);\n        findNextExpirationTimeToWorkOn(NoWork, root);\n        return;\n      }\n\n      findNextExpirationTimeToWorkOn(NoWork, root);\n    }\n\n    function hasLowerPriorityWork(root, erroredExpirationTime) {\n      var latestPendingTime = root.latestPendingTime;\n      var latestSuspendedTime = root.latestSuspendedTime;\n      var latestPingedTime = root.latestPingedTime;\n      return latestPendingTime !== NoWork && latestPendingTime > erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime > erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime;\n    }\n\n    function isPriorityLevelSuspended(root, expirationTime) {\n      var earliestSuspendedTime = root.earliestSuspendedTime;\n      var latestSuspendedTime = root.latestSuspendedTime;\n      return earliestSuspendedTime !== NoWork && expirationTime >= earliestSuspendedTime && expirationTime <= latestSuspendedTime;\n    }\n\n    function markSuspendedPriorityLevel(root, suspendedTime) {\n      root.didError = false;\n      clearPing(root, suspendedTime);\n      var earliestPendingTime = root.earliestPendingTime;\n      var latestPendingTime = root.latestPendingTime;\n\n      if (earliestPendingTime === suspendedTime) {\n        if (latestPendingTime === suspendedTime) {\n          root.earliestPendingTime = root.latestPendingTime = NoWork;\n        } else {\n          root.earliestPendingTime = latestPendingTime;\n        }\n      } else if (latestPendingTime === suspendedTime) {\n        root.latestPendingTime = earliestPendingTime;\n      }\n\n      var earliestSuspendedTime = root.earliestSuspendedTime;\n      var latestSuspendedTime = root.latestSuspendedTime;\n\n      if (earliestSuspendedTime === NoWork) {\n        root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n      } else {\n        if (earliestSuspendedTime > suspendedTime) {\n          root.earliestSuspendedTime = suspendedTime;\n        } else if (latestSuspendedTime < suspendedTime) {\n          root.latestSuspendedTime = suspendedTime;\n        }\n      }\n\n      findNextExpirationTimeToWorkOn(suspendedTime, root);\n    }\n\n    function markPingedPriorityLevel(root, pingedTime) {\n      root.didError = false;\n      var latestPingedTime = root.latestPingedTime;\n\n      if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n        root.latestPingedTime = pingedTime;\n      }\n\n      findNextExpirationTimeToWorkOn(pingedTime, root);\n    }\n\n    function clearPing(root, completedTime) {\n      var latestPingedTime = root.latestPingedTime;\n\n      if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {\n        root.latestPingedTime = NoWork;\n      }\n    }\n\n    function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\n      var earliestExpirationTime = renderExpirationTime;\n      var earliestPendingTime = root.earliestPendingTime;\n      var earliestSuspendedTime = root.earliestSuspendedTime;\n\n      if (earliestExpirationTime === NoWork || earliestPendingTime !== NoWork && earliestPendingTime < earliestExpirationTime) {\n        earliestExpirationTime = earliestPendingTime;\n      }\n\n      if (earliestExpirationTime === NoWork || earliestSuspendedTime !== NoWork && earliestSuspendedTime < earliestExpirationTime) {\n        earliestExpirationTime = earliestSuspendedTime;\n      }\n\n      return earliestExpirationTime;\n    }\n\n    function didExpireAtExpirationTime(root, currentTime) {\n      var expirationTime = root.expirationTime;\n\n      if (expirationTime !== NoWork && currentTime >= expirationTime) {\n        root.nextExpirationTimeToWorkOn = currentTime;\n      }\n    }\n\n    function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\n      var earliestSuspendedTime = root.earliestSuspendedTime;\n      var latestSuspendedTime = root.latestSuspendedTime;\n      var earliestPendingTime = root.earliestPendingTime;\n      var latestPingedTime = root.latestPingedTime;\n      var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\n\n      if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime > completedExpirationTime)) {\n        nextExpirationTimeToWorkOn = latestSuspendedTime;\n      }\n\n      var expirationTime = nextExpirationTimeToWorkOn;\n\n      if (expirationTime !== NoWork && earliestSuspendedTime !== NoWork && earliestSuspendedTime < expirationTime) {\n        expirationTime = earliestSuspendedTime;\n      }\n\n      root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n      root.expirationTime = expirationTime;\n    }\n\n    var UpdateState = 0;\n    var ReplaceState = 1;\n    var ForceUpdate = 2;\n    var CaptureUpdate = 3;\n    var hasForceUpdate = false;\n    var didWarnUpdateInsideUpdate = void 0;\n    var currentlyProcessingQueue = void 0;\n    var resetCurrentlyProcessingQueue = void 0;\n    {\n      didWarnUpdateInsideUpdate = false;\n      currentlyProcessingQueue = null;\n\n      resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {\n        currentlyProcessingQueue = null;\n      };\n    }\n\n    function createUpdateQueue(baseState) {\n      var queue = {\n        baseState: baseState,\n        firstUpdate: null,\n        lastUpdate: null,\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null\n      };\n      return queue;\n    }\n\n    function cloneUpdateQueue(currentQueue) {\n      var queue = {\n        baseState: currentQueue.baseState,\n        firstUpdate: currentQueue.firstUpdate,\n        lastUpdate: currentQueue.lastUpdate,\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null\n      };\n      return queue;\n    }\n\n    function createUpdate(expirationTime) {\n      return {\n        expirationTime: expirationTime,\n        tag: UpdateState,\n        payload: null,\n        callback: null,\n        next: null,\n        nextEffect: null\n      };\n    }\n\n    function appendUpdateToQueue(queue, update) {\n      if (queue.lastUpdate === null) {\n        queue.firstUpdate = queue.lastUpdate = update;\n      } else {\n        queue.lastUpdate.next = update;\n        queue.lastUpdate = update;\n      }\n    }\n\n    function enqueueUpdate(fiber, update) {\n      var alternate = fiber.alternate;\n      var queue1 = void 0;\n      var queue2 = void 0;\n\n      if (alternate === null) {\n        queue1 = fiber.updateQueue;\n        queue2 = null;\n\n        if (queue1 === null) {\n          queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        }\n      } else {\n        queue1 = fiber.updateQueue;\n        queue2 = alternate.updateQueue;\n\n        if (queue1 === null) {\n          if (queue2 === null) {\n            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n            queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);\n          } else {\n            queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n          }\n        } else {\n          if (queue2 === null) {\n            queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n          } else {}\n        }\n      }\n\n      if (queue2 === null || queue1 === queue2) {\n        appendUpdateToQueue(queue1, update);\n      } else {\n        if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n          appendUpdateToQueue(queue1, update);\n          appendUpdateToQueue(queue2, update);\n        } else {\n          appendUpdateToQueue(queue1, update);\n          queue2.lastUpdate = update;\n        }\n      }\n\n      {\n        if ((fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {\n          warningWithoutStack$1(false, \"An update (setState, replaceState, or forceUpdate) was scheduled \" + \"from inside an update function. Update functions should be pure, \" + \"with zero side-effects. Consider using componentDidUpdate or a \" + \"callback.\");\n          didWarnUpdateInsideUpdate = true;\n        }\n      }\n    }\n\n    function enqueueCapturedUpdate(workInProgress, update) {\n      var workInProgressQueue = workInProgress.updateQueue;\n\n      if (workInProgressQueue === null) {\n        workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);\n      } else {\n        workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);\n      }\n\n      if (workInProgressQueue.lastCapturedUpdate === null) {\n        workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n      } else {\n        workInProgressQueue.lastCapturedUpdate.next = update;\n        workInProgressQueue.lastCapturedUpdate = update;\n      }\n    }\n\n    function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n      var current = workInProgress.alternate;\n\n      if (current !== null) {\n        if (queue === current.updateQueue) {\n          queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n        }\n      }\n\n      return queue;\n    }\n\n    function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n      switch (update.tag) {\n        case ReplaceState:\n          {\n            var _payload = update.payload;\n\n            if (typeof _payload === \"function\") {\n              {\n                if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n                  _payload.call(instance, prevState, nextProps);\n                }\n              }\n              return _payload.call(instance, prevState, nextProps);\n            }\n\n            return _payload;\n          }\n\n        case CaptureUpdate:\n          {\n            workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n          }\n\n        case UpdateState:\n          {\n            var _payload2 = update.payload;\n            var partialState = void 0;\n\n            if (typeof _payload2 === \"function\") {\n              {\n                if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n                  _payload2.call(instance, prevState, nextProps);\n                }\n              }\n              partialState = _payload2.call(instance, prevState, nextProps);\n            } else {\n              partialState = _payload2;\n            }\n\n            if (partialState === null || partialState === undefined) {\n              return prevState;\n            }\n\n            return _extends({}, prevState, partialState);\n          }\n\n        case ForceUpdate:\n          {\n            hasForceUpdate = true;\n            return prevState;\n          }\n      }\n\n      return prevState;\n    }\n\n    function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {\n      hasForceUpdate = false;\n      queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n      {\n        currentlyProcessingQueue = queue;\n      }\n      var newBaseState = queue.baseState;\n      var newFirstUpdate = null;\n      var newExpirationTime = NoWork;\n      var update = queue.firstUpdate;\n      var resultState = newBaseState;\n\n      while (update !== null) {\n        var updateExpirationTime = update.expirationTime;\n\n        if (updateExpirationTime > renderExpirationTime) {\n          if (newFirstUpdate === null) {\n            newFirstUpdate = update;\n            newBaseState = resultState;\n          }\n\n          if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {\n            newExpirationTime = updateExpirationTime;\n          }\n        } else {\n          resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n          var _callback = update.callback;\n\n          if (_callback !== null) {\n            workInProgress.effectTag |= Callback;\n            update.nextEffect = null;\n\n            if (queue.lastEffect === null) {\n              queue.firstEffect = queue.lastEffect = update;\n            } else {\n              queue.lastEffect.nextEffect = update;\n              queue.lastEffect = update;\n            }\n          }\n        }\n\n        update = update.next;\n      }\n\n      var newFirstCapturedUpdate = null;\n      update = queue.firstCapturedUpdate;\n\n      while (update !== null) {\n        var _updateExpirationTime = update.expirationTime;\n\n        if (_updateExpirationTime > renderExpirationTime) {\n          if (newFirstCapturedUpdate === null) {\n            newFirstCapturedUpdate = update;\n\n            if (newFirstUpdate === null) {\n              newBaseState = resultState;\n            }\n          }\n\n          if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {\n            newExpirationTime = _updateExpirationTime;\n          }\n        } else {\n          resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n          var _callback2 = update.callback;\n\n          if (_callback2 !== null) {\n            workInProgress.effectTag |= Callback;\n            update.nextEffect = null;\n\n            if (queue.lastCapturedEffect === null) {\n              queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n            } else {\n              queue.lastCapturedEffect.nextEffect = update;\n              queue.lastCapturedEffect = update;\n            }\n          }\n        }\n\n        update = update.next;\n      }\n\n      if (newFirstUpdate === null) {\n        queue.lastUpdate = null;\n      }\n\n      if (newFirstCapturedUpdate === null) {\n        queue.lastCapturedUpdate = null;\n      } else {\n        workInProgress.effectTag |= Callback;\n      }\n\n      if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n        newBaseState = resultState;\n      }\n\n      queue.baseState = newBaseState;\n      queue.firstUpdate = newFirstUpdate;\n      queue.firstCapturedUpdate = newFirstCapturedUpdate;\n      workInProgress.expirationTime = newExpirationTime;\n      workInProgress.memoizedState = resultState;\n      {\n        currentlyProcessingQueue = null;\n      }\n    }\n\n    function callCallback(callback, context) {\n      invariant(typeof callback === \"function\", \"Invalid argument passed as callback. Expected a function. Instead \" + \"received: %s\", callback);\n      callback.call(context);\n    }\n\n    function resetHasForceUpdateBeforeProcessing() {\n      hasForceUpdate = false;\n    }\n\n    function checkHasForceUpdateAfterProcessing() {\n      return hasForceUpdate;\n    }\n\n    function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {\n      if (finishedQueue.firstCapturedUpdate !== null) {\n        if (finishedQueue.lastUpdate !== null) {\n          finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n          finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n        }\n\n        finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n      }\n\n      commitUpdateEffects(finishedQueue.firstEffect, instance);\n      finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n      commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n      finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n    }\n\n    function commitUpdateEffects(effect, instance) {\n      while (effect !== null) {\n        var _callback3 = effect.callback;\n\n        if (_callback3 !== null) {\n          effect.callback = null;\n          callCallback(_callback3, instance);\n        }\n\n        effect = effect.nextEffect;\n      }\n    }\n\n    function createCapturedValue(value, source) {\n      return {\n        value: value,\n        source: source,\n        stack: getStackByFiberInDevAndProd(source)\n      };\n    }\n\n    var warning = warningWithoutStack$1;\n    {\n      warning = function warning(condition, format) {\n        if (condition) {\n          return;\n        }\n\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        warningWithoutStack$1.apply(undefined, [false, format + \"%s\"].concat(args, [stack]));\n      };\n    }\n    var warning$1 = warning;\n    var valueCursor = createCursor(null);\n    var rendererSigil = void 0;\n    {\n      rendererSigil = {};\n    }\n    var currentlyRenderingFiber = null;\n    var lastContextDependency = null;\n    var lastContextWithAllBitsObserved = null;\n\n    function resetContextDependences() {\n      currentlyRenderingFiber = null;\n      lastContextDependency = null;\n      lastContextWithAllBitsObserved = null;\n    }\n\n    function pushProvider(providerFiber, nextValue) {\n      var context = providerFiber.type._context;\n\n      if (isPrimaryRenderer) {\n        push(valueCursor, context._currentValue, providerFiber);\n        context._currentValue = nextValue;\n        {\n          !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, \"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\") : void 0;\n          context._currentRenderer = rendererSigil;\n        }\n      } else {\n        push(valueCursor, context._currentValue2, providerFiber);\n        context._currentValue2 = nextValue;\n        {\n          !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, \"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\") : void 0;\n          context._currentRenderer2 = rendererSigil;\n        }\n      }\n    }\n\n    function popProvider(providerFiber) {\n      var currentValue = valueCursor.current;\n      pop(valueCursor, providerFiber);\n      var context = providerFiber.type._context;\n\n      if (isPrimaryRenderer) {\n        context._currentValue = currentValue;\n      } else {\n        context._currentValue2 = currentValue;\n      }\n    }\n\n    function calculateChangedBits(context, newValue, oldValue) {\n      if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue) {\n          return 0;\n        } else {\n        var changedBits = typeof context._calculateChangedBits === \"function\" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;\n        {\n          !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, \"calculateChangedBits: Expected the return value to be a \" + \"31-bit integer. Instead received: %s\", changedBits) : void 0;\n        }\n        return changedBits | 0;\n      }\n    }\n\n    function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n      var fiber = workInProgress.child;\n\n      if (fiber !== null) {\n        fiber.return = workInProgress;\n      }\n\n      while (fiber !== null) {\n        var nextFiber = void 0;\n        var dependency = fiber.firstContextDependency;\n\n        if (dependency !== null) {\n          do {\n            if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {\n              if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n                var update = createUpdate(renderExpirationTime);\n                update.tag = ForceUpdate;\n                enqueueUpdate(fiber, update);\n              }\n\n              if (fiber.expirationTime === NoWork || fiber.expirationTime > renderExpirationTime) {\n                fiber.expirationTime = renderExpirationTime;\n              }\n\n              var alternate = fiber.alternate;\n\n              if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n                alternate.expirationTime = renderExpirationTime;\n              }\n\n              var node = fiber.return;\n\n              while (node !== null) {\n                alternate = node.alternate;\n\n                if (node.childExpirationTime === NoWork || node.childExpirationTime > renderExpirationTime) {\n                  node.childExpirationTime = renderExpirationTime;\n\n                  if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n                    alternate.childExpirationTime = renderExpirationTime;\n                  }\n                } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n                  alternate.childExpirationTime = renderExpirationTime;\n                } else {\n                  break;\n                }\n\n                node = node.return;\n              }\n            }\n\n            nextFiber = fiber.child;\n            dependency = dependency.next;\n          } while (dependency !== null);\n        } else if (fiber.tag === ContextProvider) {\n          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n        } else {\n          nextFiber = fiber.child;\n        }\n\n        if (nextFiber !== null) {\n          nextFiber.return = fiber;\n        } else {\n          nextFiber = fiber;\n\n          while (nextFiber !== null) {\n            if (nextFiber === workInProgress) {\n              nextFiber = null;\n              break;\n            }\n\n            var sibling = nextFiber.sibling;\n\n            if (sibling !== null) {\n              sibling.return = nextFiber.return;\n              nextFiber = sibling;\n              break;\n            }\n\n            nextFiber = nextFiber.return;\n          }\n        }\n\n        fiber = nextFiber;\n      }\n    }\n\n    function prepareToReadContext(workInProgress, renderExpirationTime) {\n      currentlyRenderingFiber = workInProgress;\n      lastContextDependency = null;\n      lastContextWithAllBitsObserved = null;\n      workInProgress.firstContextDependency = null;\n    }\n\n    function readContext(context, observedBits) {\n      if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {\n        var resolvedObservedBits = void 0;\n\n        if (typeof observedBits !== \"number\" || observedBits === maxSigned31BitInt) {\n          lastContextWithAllBitsObserved = context;\n          resolvedObservedBits = maxSigned31BitInt;\n        } else {\n          resolvedObservedBits = observedBits;\n        }\n\n        var contextItem = {\n          context: context,\n          observedBits: resolvedObservedBits,\n          next: null\n        };\n\n        if (lastContextDependency === null) {\n          invariant(currentlyRenderingFiber !== null, \"Context.unstable_read(): Context can only be read while React is \" + \"rendering, e.g. inside the render method or getDerivedStateFromProps.\");\n          currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;\n        } else {\n          lastContextDependency = lastContextDependency.next = contextItem;\n        }\n      }\n\n      return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n    }\n\n    var NO_CONTEXT = {};\n    var contextStackCursor$1 = createCursor(NO_CONTEXT);\n    var contextFiberStackCursor = createCursor(NO_CONTEXT);\n    var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n    function requiredContext(c) {\n      invariant(c !== NO_CONTEXT, \"Expected host context to exist. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n      return c;\n    }\n\n    function getRootHostContainer() {\n      var rootInstance = requiredContext(rootInstanceStackCursor.current);\n      return rootInstance;\n    }\n\n    function pushHostContainer(fiber, nextRootInstance) {\n      push(rootInstanceStackCursor, nextRootInstance, fiber);\n      push(contextFiberStackCursor, fiber, fiber);\n      push(contextStackCursor$1, NO_CONTEXT, fiber);\n      var nextRootContext = getRootHostContext(nextRootInstance);\n      pop(contextStackCursor$1, fiber);\n      push(contextStackCursor$1, nextRootContext, fiber);\n    }\n\n    function popHostContainer(fiber) {\n      pop(contextStackCursor$1, fiber);\n      pop(contextFiberStackCursor, fiber);\n      pop(rootInstanceStackCursor, fiber);\n    }\n\n    function getHostContext() {\n      var context = requiredContext(contextStackCursor$1.current);\n      return context;\n    }\n\n    function pushHostContext(fiber) {\n      var rootInstance = requiredContext(rootInstanceStackCursor.current);\n      var context = requiredContext(contextStackCursor$1.current);\n      var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n      if (context === nextContext) {\n        return;\n      }\n\n      push(contextFiberStackCursor, fiber, fiber);\n      push(contextStackCursor$1, nextContext, fiber);\n    }\n\n    function popHostContext(fiber) {\n      if (contextFiberStackCursor.current !== fiber) {\n        return;\n      }\n\n      pop(contextStackCursor$1, fiber);\n      pop(contextFiberStackCursor, fiber);\n    }\n\n    var commitTime = 0;\n    var profilerStartTime = -1;\n\n    function getCommitTime() {\n      return commitTime;\n    }\n\n    function recordCommitTime() {\n      if (!enableProfilerTimer) {\n        return;\n      }\n\n      commitTime = now();\n    }\n\n    function startProfilerTimer(fiber) {\n      if (!enableProfilerTimer) {\n        return;\n      }\n\n      profilerStartTime = now();\n\n      if (fiber.actualStartTime < 0) {\n        fiber.actualStartTime = now();\n      }\n    }\n\n    function stopProfilerTimerIfRunning(fiber) {\n      if (!enableProfilerTimer) {\n        return;\n      }\n\n      profilerStartTime = -1;\n    }\n\n    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n      if (!enableProfilerTimer) {\n        return;\n      }\n\n      if (profilerStartTime >= 0) {\n        var elapsedTime = now() - profilerStartTime;\n        fiber.actualDuration += elapsedTime;\n\n        if (overrideBaseTime) {\n          fiber.selfBaseDuration = elapsedTime;\n        }\n\n        profilerStartTime = -1;\n      }\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function is(x, y) {\n      if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n      } else {\n        return x !== x && y !== y;\n      }\n    }\n\n    function shallowEqual(objA, objB) {\n      if (is(objA, objB)) {\n        return true;\n      }\n\n      if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n      }\n\n      var keysA = Object.keys(objA);\n      var keysB = Object.keys(objB);\n\n      if (keysA.length !== keysB.length) {\n        return false;\n      }\n\n      for (var i = 0; i < keysA.length; i++) {\n        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    var fakeInternalInstance = {};\n    var isArray = Array.isArray;\n    var emptyRefsObject = new React.Component().refs;\n    var didWarnAboutStateAssignmentForComponent = void 0;\n    var didWarnAboutUninitializedState = void 0;\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\n    var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\n    var didWarnAboutUndefinedDerivedState = void 0;\n    var warnOnUndefinedDerivedState = void 0;\n    var warnOnInvalidCallback = void 0;\n    var didWarnAboutDirectlyAssigningPropsToState = void 0;\n    {\n      didWarnAboutStateAssignmentForComponent = new Set();\n      didWarnAboutUninitializedState = new Set();\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n      didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n      didWarnAboutDirectlyAssigningPropsToState = new Set();\n      didWarnAboutUndefinedDerivedState = new Set();\n      var didWarnOnInvalidCallback = new Set();\n\n      warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {\n        if (callback === null || typeof callback === \"function\") {\n          return;\n        }\n\n        var key = callerName + \"_\" + callback;\n\n        if (!didWarnOnInvalidCallback.has(key)) {\n          didWarnOnInvalidCallback.add(key);\n          warningWithoutStack$1(false, \"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n        }\n      };\n\n      warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {\n        if (partialState === undefined) {\n          var componentName = getComponentName(type) || \"Component\";\n\n          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n            didWarnAboutUndefinedDerivedState.add(componentName);\n            warningWithoutStack$1(false, \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n          }\n        }\n      };\n\n      Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n        enumerable: false,\n        value: function value() {\n          invariant(false, \"_processChildContext is not available in React 16+. This likely \" + \"means you have multiple copies of React and are attempting to nest \" + \"a React 15 tree inside a React 16 tree using \" + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + \"to make sure you have only one copy of React (and ideally, switch \" + \"to ReactDOM.createPortal).\");\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n      var prevState = workInProgress.memoizedState;\n      {\n        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n          getDerivedStateFromProps(nextProps, prevState);\n        }\n      }\n      var partialState = getDerivedStateFromProps(nextProps, prevState);\n      {\n        warnOnUndefinedDerivedState(ctor, partialState);\n      }\n      var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);\n      workInProgress.memoizedState = memoizedState;\n      var updateQueue = workInProgress.updateQueue;\n\n      if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n        updateQueue.baseState = memoizedState;\n      }\n    }\n\n    var classComponentUpdater = {\n      isMounted: isMounted,\n      enqueueSetState: function enqueueSetState(inst, payload, callback) {\n        var fiber = get$1(inst);\n        var currentTime = requestCurrentTime();\n        var expirationTime = computeExpirationForFiber(currentTime, fiber);\n        var update = createUpdate(expirationTime);\n        update.payload = payload;\n\n        if (callback !== undefined && callback !== null) {\n          {\n            warnOnInvalidCallback(callback, \"setState\");\n          }\n          update.callback = callback;\n        }\n\n        enqueueUpdate(fiber, update);\n        scheduleWork(fiber, expirationTime);\n      },\n      enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {\n        var fiber = get$1(inst);\n        var currentTime = requestCurrentTime();\n        var expirationTime = computeExpirationForFiber(currentTime, fiber);\n        var update = createUpdate(expirationTime);\n        update.tag = ReplaceState;\n        update.payload = payload;\n\n        if (callback !== undefined && callback !== null) {\n          {\n            warnOnInvalidCallback(callback, \"replaceState\");\n          }\n          update.callback = callback;\n        }\n\n        enqueueUpdate(fiber, update);\n        scheduleWork(fiber, expirationTime);\n      },\n      enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {\n        var fiber = get$1(inst);\n        var currentTime = requestCurrentTime();\n        var expirationTime = computeExpirationForFiber(currentTime, fiber);\n        var update = createUpdate(expirationTime);\n        update.tag = ForceUpdate;\n\n        if (callback !== undefined && callback !== null) {\n          {\n            warnOnInvalidCallback(callback, \"forceUpdate\");\n          }\n          update.callback = callback;\n        }\n\n        enqueueUpdate(fiber, update);\n        scheduleWork(fiber, expirationTime);\n      }\n    };\n\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext) {\n      var instance = workInProgress.stateNode;\n\n      if (typeof instance.shouldComponentUpdate === \"function\") {\n        startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n        var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextLegacyContext);\n        stopPhaseTimer();\n        {\n          !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, \"%s.shouldComponentUpdate(): Returned undefined instead of a \" + \"boolean value. Make sure to return true or false.\", getComponentName(ctor) || \"Component\") : void 0;\n        }\n        return shouldUpdate;\n      }\n\n      if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n        return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n      }\n\n      return true;\n    }\n\n    function checkClassInstance(workInProgress, ctor, newProps) {\n      var instance = workInProgress.stateNode;\n      {\n        var name = getComponentName(ctor) || \"Component\";\n        var renderPresent = instance.render;\n\n        if (!renderPresent) {\n          if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n            warningWithoutStack$1(false, \"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n          } else {\n            warningWithoutStack$1(false, \"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n          }\n        }\n\n        var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n        !noGetInitialStateOnES6 ? warningWithoutStack$1(false, \"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name) : void 0;\n        var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n        !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, \"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name) : void 0;\n        var noInstancePropTypes = !instance.propTypes;\n        !noInstancePropTypes ? warningWithoutStack$1(false, \"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name) : void 0;\n        var noInstanceContextTypes = !instance.contextTypes;\n        !noInstanceContextTypes ? warningWithoutStack$1(false, \"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name) : void 0;\n        var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== \"function\";\n        !noComponentShouldUpdate ? warningWithoutStack$1(false, \"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name) : void 0;\n\n        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n          warningWithoutStack$1(false, \"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentName(ctor) || \"A pure component\");\n        }\n\n        var noComponentDidUnmount = typeof instance.componentDidUnmount !== \"function\";\n        !noComponentDidUnmount ? warningWithoutStack$1(false, \"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name) : void 0;\n        var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== \"function\";\n        !noComponentDidReceiveProps ? warningWithoutStack$1(false, \"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name) : void 0;\n        var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== \"function\";\n        !noComponentWillRecieveProps ? warningWithoutStack$1(false, \"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name) : void 0;\n        var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n        !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, \"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name) : void 0;\n        var hasMutatedProps = instance.props !== newProps;\n        !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, \"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n        var noInstanceDefaultProps = !instance.defaultProps;\n        !noInstanceDefaultProps ? warningWithoutStack$1(false, \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name) : void 0;\n\n        if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n          warningWithoutStack$1(false, \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentName(ctor));\n        }\n\n        var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== \"function\";\n        !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, \"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name) : void 0;\n        var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== \"function\";\n        !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, \"%s: getDerivedStateFromCatch() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name) : void 0;\n        var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== \"function\";\n        !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, \"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name) : void 0;\n        var _state = instance.state;\n\n        if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n          warningWithoutStack$1(false, \"%s.state: must be set to an object or null\", name);\n        }\n\n        if (typeof instance.getChildContext === \"function\") {\n          !(typeof ctor.childContextTypes === \"object\") ? warningWithoutStack$1(false, \"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name) : void 0;\n        }\n      }\n    }\n\n    function adoptClassInstance(workInProgress, instance) {\n      instance.updater = classComponentUpdater;\n      workInProgress.stateNode = instance;\n      set(instance, workInProgress);\n      {\n        instance._reactInternalInstance = fakeInternalInstance;\n      }\n    }\n\n    function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {\n      var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n      var contextTypes = ctor.contextTypes;\n      var isContextConsumer = contextTypes !== null && contextTypes !== undefined;\n      var context = isContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n      {\n        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n          new ctor(props, context);\n        }\n      }\n      var instance = new ctor(props, context);\n      var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n      adoptClassInstance(workInProgress, instance);\n      {\n        if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n          var componentName = getComponentName(ctor) || \"Component\";\n\n          if (!didWarnAboutUninitializedState.has(componentName)) {\n            didWarnAboutUninitializedState.add(componentName);\n            warningWithoutStack$1(false, \"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n          }\n        }\n\n        if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n          var foundWillMountName = null;\n          var foundWillReceivePropsName = null;\n          var foundWillUpdateName = null;\n\n          if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n            foundWillMountName = \"componentWillMount\";\n          } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n            foundWillMountName = \"UNSAFE_componentWillMount\";\n          }\n\n          if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n            foundWillReceivePropsName = \"componentWillReceiveProps\";\n          } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n            foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n          }\n\n          if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n            foundWillUpdateName = \"componentWillUpdate\";\n          } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n            foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n          }\n\n          if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n            var _componentName = getComponentName(ctor) || \"Component\";\n\n            var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n\n            if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n              didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n              warningWithoutStack$1(false, \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://fb.me/react-async-component-lifecycle-hooks\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n            }\n          }\n        }\n      }\n\n      if (isContextConsumer) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return instance;\n    }\n\n    function callComponentWillMount(workInProgress, instance) {\n      startPhaseTimer(workInProgress, \"componentWillMount\");\n      var oldState = instance.state;\n\n      if (typeof instance.componentWillMount === \"function\") {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        instance.UNSAFE_componentWillMount();\n      }\n\n      stopPhaseTimer();\n\n      if (oldState !== instance.state) {\n        {\n          warningWithoutStack$1(false, \"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentName(workInProgress.type) || \"Component\");\n        }\n        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n      }\n    }\n\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext) {\n      var oldState = instance.state;\n      startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n\n      if (typeof instance.componentWillReceiveProps === \"function\") {\n        instance.componentWillReceiveProps(newProps, nextLegacyContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n        instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);\n      }\n\n      stopPhaseTimer();\n\n      if (instance.state !== oldState) {\n        {\n          var componentName = getComponentName(workInProgress.type) || \"Component\";\n\n          if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n            didWarnAboutStateAssignmentForComponent.add(componentName);\n            warningWithoutStack$1(false, \"%s.componentWillReceiveProps(): Assigning directly to \" + \"this.state is deprecated (except inside a component's \" + \"constructor). Use setState instead.\", componentName);\n          }\n        }\n        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n      }\n    }\n\n    function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n      {\n        checkClassInstance(workInProgress, ctor, newProps);\n      }\n      var instance = workInProgress.stateNode;\n      var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n      instance.props = newProps;\n      instance.state = workInProgress.memoizedState;\n      instance.refs = emptyRefsObject;\n      instance.context = getMaskedContext(workInProgress, unmaskedContext);\n      {\n        if (instance.state === newProps) {\n          var componentName = getComponentName(ctor) || \"Component\";\n\n          if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n            didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n            warningWithoutStack$1(false, \"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n          }\n        }\n\n        if (workInProgress.mode & StrictMode) {\n          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n        }\n\n        if (warnAboutDeprecatedLifecycles) {\n          ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n        }\n      }\n      var updateQueue = workInProgress.updateQueue;\n\n      if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n        instance.state = workInProgress.memoizedState;\n      }\n\n      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n      if (typeof getDerivedStateFromProps === \"function\") {\n        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n        instance.state = workInProgress.memoizedState;\n      }\n\n      if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n        callComponentWillMount(workInProgress, instance);\n        updateQueue = workInProgress.updateQueue;\n\n        if (updateQueue !== null) {\n          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n          instance.state = workInProgress.memoizedState;\n        }\n      }\n\n      if (typeof instance.componentDidMount === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n    }\n\n    function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n      var instance = workInProgress.stateNode;\n      var oldProps = workInProgress.memoizedProps;\n      instance.props = oldProps;\n      var oldContext = instance.context;\n      var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n      var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n      var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n        if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n        }\n      }\n\n      resetHasForceUpdateBeforeProcessing();\n      var oldState = workInProgress.memoizedState;\n      var newState = instance.state = oldState;\n      var updateQueue = workInProgress.updateQueue;\n\n      if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n        newState = workInProgress.memoizedState;\n      }\n\n      if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n        if (typeof instance.componentDidMount === \"function\") {\n          workInProgress.effectTag |= Update;\n        }\n\n        return false;\n      }\n\n      if (typeof getDerivedStateFromProps === \"function\") {\n        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n        newState = workInProgress.memoizedState;\n      }\n\n      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n      if (shouldUpdate) {\n        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n          startPhaseTimer(workInProgress, \"componentWillMount\");\n\n          if (typeof instance.componentWillMount === \"function\") {\n            instance.componentWillMount();\n          }\n\n          if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n            instance.UNSAFE_componentWillMount();\n          }\n\n          stopPhaseTimer();\n        }\n\n        if (typeof instance.componentDidMount === \"function\") {\n          workInProgress.effectTag |= Update;\n        }\n      } else {\n        if (typeof instance.componentDidMount === \"function\") {\n          workInProgress.effectTag |= Update;\n        }\n\n        workInProgress.memoizedProps = newProps;\n        workInProgress.memoizedState = newState;\n      }\n\n      instance.props = newProps;\n      instance.state = newState;\n      instance.context = nextLegacyContext;\n      return shouldUpdate;\n    }\n\n    function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {\n      var instance = workInProgress.stateNode;\n      var oldProps = workInProgress.memoizedProps;\n      instance.props = oldProps;\n      var oldContext = instance.context;\n      var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n      var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n      var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n        if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n        }\n      }\n\n      resetHasForceUpdateBeforeProcessing();\n      var oldState = workInProgress.memoizedState;\n      var newState = instance.state = oldState;\n      var updateQueue = workInProgress.updateQueue;\n\n      if (updateQueue !== null) {\n        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n        newState = workInProgress.memoizedState;\n      }\n\n      if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n        if (typeof instance.componentDidUpdate === \"function\") {\n          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n            workInProgress.effectTag |= Update;\n          }\n        }\n\n        if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n            workInProgress.effectTag |= Snapshot;\n          }\n        }\n\n        return false;\n      }\n\n      if (typeof getDerivedStateFromProps === \"function\") {\n        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n        newState = workInProgress.memoizedState;\n      }\n\n      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n      if (shouldUpdate) {\n        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n          startPhaseTimer(workInProgress, \"componentWillUpdate\");\n\n          if (typeof instance.componentWillUpdate === \"function\") {\n            instance.componentWillUpdate(newProps, newState, nextLegacyContext);\n          }\n\n          if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n            instance.UNSAFE_componentWillUpdate(newProps, newState, nextLegacyContext);\n          }\n\n          stopPhaseTimer();\n        }\n\n        if (typeof instance.componentDidUpdate === \"function\") {\n          workInProgress.effectTag |= Update;\n        }\n\n        if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n          workInProgress.effectTag |= Snapshot;\n        }\n      } else {\n        if (typeof instance.componentDidUpdate === \"function\") {\n          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n            workInProgress.effectTag |= Update;\n          }\n        }\n\n        if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n            workInProgress.effectTag |= Snapshot;\n          }\n        }\n\n        workInProgress.memoizedProps = newProps;\n        workInProgress.memoizedState = newState;\n      }\n\n      instance.props = newProps;\n      instance.state = newState;\n      instance.context = nextLegacyContext;\n      return shouldUpdate;\n    }\n\n    var didWarnAboutMaps = void 0;\n    var didWarnAboutGenerators = void 0;\n    var didWarnAboutStringRefInStrictMode = void 0;\n    var ownerHasKeyUseWarning = void 0;\n    var ownerHasFunctionTypeWarning = void 0;\n\n    var warnForMissingKey = function warnForMissingKey(child) {};\n\n    {\n      didWarnAboutMaps = false;\n      didWarnAboutGenerators = false;\n      didWarnAboutStringRefInStrictMode = {};\n      ownerHasKeyUseWarning = {};\n      ownerHasFunctionTypeWarning = {};\n\n      warnForMissingKey = function warnForMissingKey(child) {\n        if (child === null || typeof child !== \"object\") {\n          return;\n        }\n\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n\n        invariant(typeof child._store === \"object\", \"React Component in warnForMissingKey should have a _store. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n        child._store.validated = true;\n        var currentComponentErrorInfo = \"Each child in an array or iterator should have a unique \" + '\"key\" prop. See https://fb.me/react-warning-keys for ' + \"more information.\" + getCurrentFiberStackInDev();\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning$1(false, \"Each child in an array or iterator should have a unique \" + '\"key\" prop. See https://fb.me/react-warning-keys for ' + \"more information.\");\n      };\n    }\n    var isArray$1 = Array.isArray;\n\n    function coerceRef(returnFiber, current$$1, element) {\n      var mixedRef = element.ref;\n\n      if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n        {\n          if (returnFiber.mode & StrictMode) {\n            var componentName = getComponentName(returnFiber.type) || \"Component\";\n\n            if (!didWarnAboutStringRefInStrictMode[componentName]) {\n              warningWithoutStack$1(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + \"String refs are a source of potential bugs and should be avoided. \" + \"We recommend using createRef() instead.\" + \"\\n%s\" + \"\\n\\nLearn more about using refs safely here:\" + \"\\nhttps://fb.me/react-strict-mode-string-ref\", mixedRef, getStackByFiberInDevAndProd(returnFiber));\n              didWarnAboutStringRefInStrictMode[componentName] = true;\n            }\n          }\n        }\n\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n\n          if (owner) {\n            var ownerFiber = owner;\n            invariant(ownerFiber.tag === ClassComponent || ownerFiber.tag === ClassComponentLazy, \"Stateless function components cannot have refs.\");\n            inst = ownerFiber.stateNode;\n          }\n\n          invariant(inst, \"Missing owner for string ref %s. This error is likely caused by a \" + \"bug in React. Please file an issue.\", mixedRef);\n          var stringRef = \"\" + mixedRef;\n\n          if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === \"function\" && current$$1.ref._stringRef === stringRef) {\n            return current$$1.ref;\n          }\n\n          var ref = function ref(value) {\n            var refs = inst.refs;\n\n            if (refs === emptyRefsObject) {\n              refs = inst.refs = {};\n            }\n\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          invariant(typeof mixedRef === \"string\", \"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n          invariant(element._owner, \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" + \" the following reasons:\\n\" + \"1. You may be adding a ref to a functional component\\n\" + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + \"3. You have multiple copies of React loaded\\n\" + \"See https://fb.me/react-refs-must-have-owner for more information.\", mixedRef);\n        }\n      }\n\n      return mixedRef;\n    }\n\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== \"textarea\") {\n        var addendum = \"\";\n        {\n          addendum = \" If you meant to render a collection of children, use an array \" + \"instead.\" + getCurrentFiberStackInDev();\n        }\n        invariant(false, \"Objects are not valid as a React child (found: %s).%s\", Object.prototype.toString.call(newChild) === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : newChild, addendum);\n      }\n    }\n\n    function warnOnFunctionType() {\n      var currentComponentErrorInfo = \"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\" + getCurrentFiberStackInDev();\n\n      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n      warning$1(false, \"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n    }\n\n    function ChildReconciler(shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          return;\n        }\n\n        var last = returnFiber.lastEffect;\n\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion;\n      }\n\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          return null;\n        }\n\n        var childToDelete = currentFirstChild;\n\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n\n        return null;\n      }\n\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n\n          existingChild = existingChild.sibling;\n        }\n\n        return existingChildren;\n      }\n\n      function useFiber(fiber, pendingProps, expirationTime) {\n        var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n        clone.index = 0;\n        clone.sibling = null;\n        return clone;\n      }\n\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n\n        if (!shouldTrackSideEffects) {\n          return lastPlacedIndex;\n        }\n\n        var current$$1 = newFiber.alternate;\n\n        if (current$$1 !== null) {\n          var oldIndex = current$$1.index;\n\n          if (oldIndex < lastPlacedIndex) {\n            newFiber.effectTag = Placement;\n            return lastPlacedIndex;\n          } else {\n            return oldIndex;\n          }\n        } else {\n          newFiber.effectTag = Placement;\n          return lastPlacedIndex;\n        }\n      }\n\n      function placeSingleChild(newFiber) {\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement;\n        }\n\n        return newFiber;\n      }\n\n      function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {\n        if (current$$1 === null || current$$1.tag !== HostText) {\n          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n          created.return = returnFiber;\n          return created;\n        } else {\n          var existing = useFiber(current$$1, textContent, expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateElement(returnFiber, current$$1, element, expirationTime) {\n        if (current$$1 !== null && current$$1.type === element.type) {\n          var existing = useFiber(current$$1, element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, current$$1, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n          created.ref = coerceRef(returnFiber, current$$1, element);\n          created.return = returnFiber;\n          return created;\n        }\n      }\n\n      function updatePortal(returnFiber, current$$1, portal, expirationTime) {\n        if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {\n          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n          created.return = returnFiber;\n          return created;\n        } else {\n          var existing = useFiber(current$$1, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {\n        if (current$$1 === null || current$$1.tag !== Fragment) {\n          var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n          created.return = returnFiber;\n          return created;\n        } else {\n          var existing = useFiber(current$$1, fragment, expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        }\n      }\n\n      function createChild(returnFiber, newChild, expirationTime) {\n        if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n          var created = createFiberFromText(\"\" + newChild, returnFiber.mode, expirationTime);\n          created.return = returnFiber;\n          return created;\n        }\n\n        if (typeof newChild === \"object\" && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n\n                _created.ref = coerceRef(returnFiber, null, newChild);\n                _created.return = returnFiber;\n                return _created;\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n\n                _created2.return = returnFiber;\n                return _created2;\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n\n            _created3.return = returnFiber;\n            return _created3;\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === \"function\") {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n        var key = oldFiber !== null ? oldFiber.key : null;\n\n        if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n          if (key !== null) {\n            return null;\n          }\n\n          return updateTextNode(returnFiber, oldFiber, \"\" + newChild, expirationTime);\n        }\n\n        if (typeof newChild === \"object\" && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  if (newChild.type === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n                  }\n\n                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n                } else {\n                  return null;\n                }\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            if (key !== null) {\n              return null;\n            }\n\n            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === \"function\") {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n        if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, expirationTime);\n        }\n\n        if (typeof newChild === \"object\" && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                if (newChild.type === REACT_FRAGMENT_TYPE) {\n                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n                }\n\n                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n              }\n          }\n\n          if (isArray$1(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n            return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === \"function\") {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== \"object\" || child === null) {\n            return knownKeys;\n          }\n\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n\n              if (typeof key !== \"string\") {\n                break;\n              }\n\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n\n              warning$1(false, \"Encountered two children with the same key, `%s`. \" + \"Keys should be unique so that components maintain their identity \" + \"across updates. Non-unique keys may cause children to be \" + \"duplicated and/or omitted  the behavior is unsupported and \" + \"could change in a future version.\", key);\n              break;\n\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n        {\n          var knownKeys = null;\n\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n          if (newFiber === null) {\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            resultingFirstChild = newFiber;\n          } else {\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (newIdx === newChildren.length) {\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n\n            if (!_newFiber) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n\n            previousNewFiber = _newFiber;\n          }\n\n          return resultingFirstChild;\n        }\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n\n            previousNewFiber = _newFiber2;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        invariant(typeof iteratorFn === \"function\", \"An object is not an iterable. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        {\n          if (typeof Symbol === \"function\" && newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n            !didWarnAboutGenerators ? warning$1(false, \"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\") : void 0;\n            didWarnAboutGenerators = true;\n          }\n\n          if (newChildrenIterable.entries === iteratorFn) {\n            !didWarnAboutMaps ? warning$1(false, \"Using Maps as children is unsupported and will likely yield \" + \"unexpected results. Convert it to a sequence/iterable of keyed \" + \"ReactElements instead.\") : void 0;\n            didWarnAboutMaps = true;\n          }\n\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n\n          if (_newChildren) {\n            var knownKeys = null;\n\n            var _step = _newChildren.next();\n\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        invariant(newChildren != null, \"An iterable object provided no iterator.\");\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n          if (newFiber === null) {\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            resultingFirstChild = newFiber;\n          } else {\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (step.done) {\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n\n            if (_newFiber3 === null) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n\n            previousNewFiber = _newFiber3;\n          }\n\n          return resultingFirstChild;\n        }\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n\n            previousNewFiber = _newFiber4;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, textContent, expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        }\n\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n        created.return = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n        var key = element.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          if (child.key === key) {\n            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n              existing.ref = coerceRef(returnFiber, child, element);\n              existing.return = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        if (element.type === REACT_FRAGMENT_TYPE) {\n          var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n          created.return = returnFiber;\n          return created;\n        } else {\n          var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n\n          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n          _created4.return = returnFiber;\n          return _created4;\n        }\n      }\n\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n        var key = portal.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          if (child.key === key) {\n            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, portal.children || [], expirationTime);\n              existing.return = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n        created.return = returnFiber;\n        return created;\n      }\n\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n        var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n        if (isUnkeyedTopLevelFragment) {\n          newChild = newChild.props.children;\n        }\n\n        var isObject = typeof newChild === \"object\" && newChild !== null;\n\n        if (isObject) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n          }\n        }\n\n        if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, expirationTime));\n        }\n\n        if (isArray$1(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n        }\n\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === \"function\") {\n            warnOnFunctionType();\n          }\n        }\n\n        if (typeof newChild === \"undefined\" && !isUnkeyedTopLevelFragment) {\n          switch (returnFiber.tag) {\n            case ClassComponent:\n            case ClassComponentLazy:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n\n                  if (instance.render._isMockFunction) {\n                    break;\n                  }\n                }\n              }\n\n            case FunctionalComponent:\n              {\n                var Component = returnFiber.type;\n                invariant(false, \"%s(...): Nothing was returned from render. This usually means a \" + \"return statement is missing. Or, to render nothing, \" + \"return null.\", Component.displayName || Component.name || \"Component\");\n              }\n          }\n        }\n\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n\n      return reconcileChildFibers;\n    }\n\n    var reconcileChildFibers = ChildReconciler(true);\n    var mountChildFibers = ChildReconciler(false);\n\n    function cloneChildFibers(current$$1, workInProgress) {\n      invariant(current$$1 === null || workInProgress.child === current$$1.child, \"Resuming work not yet implemented.\");\n\n      if (workInProgress.child === null) {\n        return;\n      }\n\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n      workInProgress.child = newChild;\n      newChild.return = workInProgress;\n\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n        newChild.return = workInProgress;\n      }\n\n      newChild.sibling = null;\n    }\n\n    var hydrationParentFiber = null;\n    var nextHydratableInstance = null;\n    var isHydrating = false;\n\n    function enterHydrationState(fiber) {\n      if (!supportsHydration) {\n        return false;\n      }\n\n      var parentInstance = fiber.stateNode.containerInfo;\n      nextHydratableInstance = getFirstHydratableChild(parentInstance);\n      hydrationParentFiber = fiber;\n      isHydrating = true;\n      return true;\n    }\n\n    function deleteHydratableInstance(returnFiber, instance) {\n      {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n            break;\n\n          case HostComponent:\n            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n            break;\n        }\n      }\n      var childToDelete = createFiberFromHostInstanceForDeletion();\n      childToDelete.stateNode = instance;\n      childToDelete.return = returnFiber;\n      childToDelete.effectTag = Deletion;\n\n      if (returnFiber.lastEffect !== null) {\n        returnFiber.lastEffect.nextEffect = childToDelete;\n        returnFiber.lastEffect = childToDelete;\n      } else {\n        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n      }\n    }\n\n    function insertNonHydratedInstance(returnFiber, fiber) {\n      fiber.effectTag |= Placement;\n      {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n\n              switch (fiber.tag) {\n                case HostComponent:\n                  var type = fiber.type;\n                  var props = fiber.pendingProps;\n                  didNotFindHydratableContainerInstance(parentContainer, type, props);\n                  break;\n\n                case HostText:\n                  var text = fiber.pendingProps;\n                  didNotFindHydratableContainerTextInstance(parentContainer, text);\n                  break;\n              }\n\n              break;\n            }\n\n          case HostComponent:\n            {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n\n              switch (fiber.tag) {\n                case HostComponent:\n                  var _type = fiber.type;\n                  var _props = fiber.pendingProps;\n                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                  break;\n\n                case HostText:\n                  var _text = fiber.pendingProps;\n                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                  break;\n              }\n\n              break;\n            }\n\n          default:\n            return;\n        }\n      }\n    }\n\n    function tryHydrate(fiber, nextInstance) {\n      switch (fiber.tag) {\n        case HostComponent:\n          {\n            var type = fiber.type;\n            var props = fiber.pendingProps;\n            var instance = canHydrateInstance(nextInstance, type, props);\n\n            if (instance !== null) {\n              fiber.stateNode = instance;\n              return true;\n            }\n\n            return false;\n          }\n\n        case HostText:\n          {\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text);\n\n            if (textInstance !== null) {\n              fiber.stateNode = textInstance;\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n    }\n\n    function tryToClaimNextHydratableInstance(fiber) {\n      if (!isHydrating) {\n        return;\n      }\n\n      var nextInstance = nextHydratableInstance;\n\n      if (!nextInstance) {\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n\n      var firstAttemptedInstance = nextInstance;\n\n      if (!tryHydrate(fiber, nextInstance)) {\n        nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n\n        if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n\n        deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n      }\n\n      hydrationParentFiber = fiber;\n      nextHydratableInstance = getFirstHydratableChild(nextInstance);\n    }\n\n    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n      if (!supportsHydration) {\n        invariant(false, \"Expected prepareToHydrateHostInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n      }\n\n      var instance = fiber.stateNode;\n      var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n      fiber.updateQueue = updatePayload;\n\n      if (updatePayload !== null) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function prepareToHydrateHostTextInstance(fiber) {\n      if (!supportsHydration) {\n        invariant(false, \"Expected prepareToHydrateHostTextInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n      }\n\n      var textInstance = fiber.stateNode;\n      var textContent = fiber.memoizedProps;\n      var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n      {\n        if (shouldUpdate) {\n          var returnFiber = hydrationParentFiber;\n\n          if (returnFiber !== null) {\n            switch (returnFiber.tag) {\n              case HostRoot:\n                {\n                  var parentContainer = returnFiber.stateNode.containerInfo;\n                  didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                  break;\n                }\n\n              case HostComponent:\n                {\n                  var parentType = returnFiber.type;\n                  var parentProps = returnFiber.memoizedProps;\n                  var parentInstance = returnFiber.stateNode;\n                  didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                  break;\n                }\n            }\n          }\n        }\n      }\n      return shouldUpdate;\n    }\n\n    function popToNextHostParent(fiber) {\n      var parent = fiber.return;\n\n      while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n        parent = parent.return;\n      }\n\n      hydrationParentFiber = parent;\n    }\n\n    function popHydrationState(fiber) {\n      if (!supportsHydration) {\n        return false;\n      }\n\n      if (fiber !== hydrationParentFiber) {\n        return false;\n      }\n\n      if (!isHydrating) {\n        popToNextHostParent(fiber);\n        isHydrating = true;\n        return false;\n      }\n\n      var type = fiber.type;\n\n      if (fiber.tag !== HostComponent || type !== \"head\" && type !== \"body\" && !shouldSetTextContent(type, fiber.memoizedProps)) {\n        var nextInstance = nextHydratableInstance;\n\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n\n      popToNextHostParent(fiber);\n      nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n      return true;\n    }\n\n    function resetHydrationState() {\n      if (!supportsHydration) {\n        return;\n      }\n\n      hydrationParentFiber = null;\n      nextHydratableInstance = null;\n      isHydrating = false;\n    }\n\n    function readLazyComponentType(thenable) {\n      var status = thenable._reactStatus;\n\n      switch (status) {\n        case Resolved:\n          var Component = thenable._reactResult;\n          return Component;\n\n        case Rejected:\n          throw thenable._reactResult;\n\n        case Pending:\n          throw thenable;\n\n        default:\n          {\n            thenable._reactStatus = Pending;\n            thenable.then(function (resolvedValue) {\n              if (thenable._reactStatus === Pending) {\n                thenable._reactStatus = Resolved;\n\n                if (typeof resolvedValue === \"object\" && resolvedValue !== null) {\n                  var defaultExport = resolvedValue.default;\n                  resolvedValue = defaultExport !== undefined && defaultExport !== null ? defaultExport : resolvedValue;\n                } else {\n                  resolvedValue = resolvedValue;\n                }\n\n                thenable._reactResult = resolvedValue;\n              }\n            }, function (error) {\n              if (thenable._reactStatus === Pending) {\n                thenable._reactStatus = Rejected;\n                thenable._reactResult = error;\n              }\n            });\n            throw thenable;\n          }\n      }\n    }\n\n    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n    var didWarnAboutBadClass = void 0;\n    var didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\n    var didWarnAboutStatelessRefs = void 0;\n    {\n      didWarnAboutBadClass = {};\n      didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n      didWarnAboutStatelessRefs = {};\n    }\n\n    function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {\n      if (current$$1 === null) {\n        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      } else {\n        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);\n      }\n    }\n\n    function updateForwardRef(current$$1, workInProgress, type, nextProps, renderExpirationTime) {\n      var render = type.render;\n      var ref = workInProgress.ref;\n\n      if (hasContextChanged()) {} else if (workInProgress.memoizedProps === nextProps) {\n        var currentRef = current$$1 !== null ? current$$1.ref : null;\n\n        if (ref === currentRef) {\n          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n        }\n      }\n\n      var nextChildren = void 0;\n      {\n        ReactCurrentOwner$3.current = workInProgress;\n        setCurrentPhase(\"render\");\n        nextChildren = render(nextProps, ref);\n        setCurrentPhase(null);\n      }\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextProps);\n      return workInProgress.child;\n    }\n\n    function updateFragment(current$$1, workInProgress, renderExpirationTime) {\n      var nextChildren = workInProgress.pendingProps;\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n      return workInProgress.child;\n    }\n\n    function updateMode(current$$1, workInProgress, renderExpirationTime) {\n      var nextChildren = workInProgress.pendingProps.children;\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n      return workInProgress.child;\n    }\n\n    function updateProfiler(current$$1, workInProgress, renderExpirationTime) {\n      if (enableProfilerTimer) {\n        workInProgress.effectTag |= Update;\n      }\n\n      var nextProps = workInProgress.pendingProps;\n      var nextChildren = nextProps.children;\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextProps);\n      return workInProgress.child;\n    }\n\n    function markRef(current$$1, workInProgress) {\n      var ref = workInProgress.ref;\n\n      if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {\n        workInProgress.effectTag |= Ref;\n      }\n    }\n\n    function updateFunctionalComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n      var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n      var context = getMaskedContext(workInProgress, unmaskedContext);\n      var nextChildren = void 0;\n      prepareToReadContext(workInProgress, renderExpirationTime);\n      {\n        ReactCurrentOwner$3.current = workInProgress;\n        setCurrentPhase(\"render\");\n        nextChildren = Component(nextProps, context);\n        setCurrentPhase(null);\n      }\n      workInProgress.effectTag |= PerformedWork;\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextProps);\n      return workInProgress.child;\n    }\n\n    function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n      var hasContext = void 0;\n\n      if (isContextProvider(Component)) {\n        hasContext = true;\n        pushContextProvider(workInProgress);\n      } else {\n        hasContext = false;\n      }\n\n      prepareToReadContext(workInProgress, renderExpirationTime);\n      var shouldUpdate = void 0;\n\n      if (current$$1 === null) {\n        if (workInProgress.stateNode === null) {\n          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n          shouldUpdate = true;\n        } else {\n          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n        }\n      } else {\n        shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);\n      }\n\n      return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);\n    }\n\n    function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {\n      markRef(current$$1, workInProgress);\n      var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n      if (!shouldUpdate && !didCaptureError) {\n        if (hasContext) {\n          invalidateContextProvider(workInProgress, Component, false);\n        }\n\n        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n      }\n\n      var instance = workInProgress.stateNode;\n      ReactCurrentOwner$3.current = workInProgress;\n      var nextChildren = void 0;\n\n      if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof Component.getDerivedStateFromCatch !== \"function\")) {\n        nextChildren = null;\n\n        if (enableProfilerTimer) {\n          stopProfilerTimerIfRunning(workInProgress);\n        }\n      } else {\n        {\n          setCurrentPhase(\"render\");\n          nextChildren = instance.render();\n\n          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n            instance.render();\n          }\n\n          setCurrentPhase(null);\n        }\n      }\n\n      workInProgress.effectTag |= PerformedWork;\n\n      if (current$$1 !== null && didCaptureError) {\n        reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n        workInProgress.child = null;\n      }\n\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeState(workInProgress, instance.state);\n      memoizeProps(workInProgress, instance.props);\n\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, Component, true);\n      }\n\n      return workInProgress.child;\n    }\n\n    function pushHostRootContext(workInProgress) {\n      var root = workInProgress.stateNode;\n\n      if (root.pendingContext) {\n        pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n      } else if (root.context) {\n        pushTopLevelContextObject(workInProgress, root.context, false);\n      }\n\n      pushHostContainer(workInProgress, root.containerInfo);\n    }\n\n    function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {\n      pushHostRootContext(workInProgress);\n      var updateQueue = workInProgress.updateQueue;\n      invariant(updateQueue !== null, \"If the root does not have an updateQueue, we should have already \" + \"bailed out. This error is likely caused by a bug in React. Please \" + \"file an issue.\");\n      var nextProps = workInProgress.pendingProps;\n      var prevState = workInProgress.memoizedState;\n      var prevChildren = prevState !== null ? prevState.element : null;\n      processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);\n      var nextState = workInProgress.memoizedState;\n      var nextChildren = nextState.element;\n\n      if (nextChildren === prevChildren) {\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n      }\n\n      var root = workInProgress.stateNode;\n\n      if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        workInProgress.effectTag |= Placement;\n        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      } else {\n        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n        resetHydrationState();\n      }\n\n      return workInProgress.child;\n    }\n\n    function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {\n      pushHostContext(workInProgress);\n\n      if (current$$1 === null) {\n        tryToClaimNextHydratableInstance(workInProgress);\n      }\n\n      var type = workInProgress.type;\n      var nextProps = workInProgress.pendingProps;\n      var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;\n      var nextChildren = nextProps.children;\n      var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n      if (isDirectTextChild) {\n        nextChildren = null;\n      } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n        workInProgress.effectTag |= ContentReset;\n      }\n\n      markRef(current$$1, workInProgress);\n\n      if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n        workInProgress.expirationTime = Never;\n        workInProgress.memoizedProps = nextProps;\n        return null;\n      }\n\n      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextProps);\n      return workInProgress.child;\n    }\n\n    function updateHostText(current$$1, workInProgress) {\n      if (current$$1 === null) {\n        tryToClaimNextHydratableInstance(workInProgress);\n      }\n\n      var nextProps = workInProgress.pendingProps;\n      memoizeProps(workInProgress, nextProps);\n      return null;\n    }\n\n    function resolveDefaultProps(Component, baseProps) {\n      if (Component && Component.defaultProps) {\n        var props = _extends({}, baseProps);\n\n        var defaultProps = Component.defaultProps;\n\n        for (var propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n\n        return props;\n      }\n\n      return baseProps;\n    }\n\n    function mountIndeterminateComponent(current$$1, workInProgress, Component, renderExpirationTime) {\n      invariant(current$$1 === null, \"An indeterminate component should never have mounted. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n      var props = workInProgress.pendingProps;\n\n      if (typeof Component === \"object\" && Component !== null && typeof Component.then === \"function\") {\n        Component = readLazyComponentType(Component);\n        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(workInProgress, Component);\n        var resolvedProps = resolveDefaultProps(Component, props);\n\n        switch (resolvedTag) {\n          case FunctionalComponentLazy:\n            {\n              return updateFunctionalComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n            }\n\n          case ClassComponentLazy:\n            {\n              return updateClassComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n            }\n\n          case ForwardRefLazy:\n            {\n              return updateForwardRef(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n            }\n\n          default:\n            {\n              invariant(false, \"Element type is invalid. Received a promise that resolves to: %s. \" + \"Promise elements must resolve to a class or function.\", Component);\n            }\n        }\n      }\n\n      var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n      var context = getMaskedContext(workInProgress, unmaskedContext);\n      prepareToReadContext(workInProgress, renderExpirationTime);\n      var value = void 0;\n      {\n        if (Component.prototype && typeof Component.prototype.render === \"function\") {\n          var componentName = getComponentName(Component) || \"Unknown\";\n\n          if (!didWarnAboutBadClass[componentName]) {\n            warningWithoutStack$1(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n            didWarnAboutBadClass[componentName] = true;\n          }\n        }\n\n        if (workInProgress.mode & StrictMode) {\n          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        }\n\n        ReactCurrentOwner$3.current = workInProgress;\n        value = Component(props, context);\n      }\n      workInProgress.effectTag |= PerformedWork;\n\n      if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n        workInProgress.tag = ClassComponent;\n        var hasContext = false;\n\n        if (isContextProvider(Component)) {\n          hasContext = true;\n          pushContextProvider(workInProgress);\n        } else {\n          hasContext = false;\n        }\n\n        workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n        var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n\n        if (typeof getDerivedStateFromProps === \"function\") {\n          applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\n        }\n\n        adoptClassInstance(workInProgress, value);\n        mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n        return finishClassComponent(current$$1, workInProgress, Component, true, hasContext, renderExpirationTime);\n      } else {\n        workInProgress.tag = FunctionalComponent;\n        {\n          if (Component) {\n            !!Component.childContextTypes ? warningWithoutStack$1(false, \"%s(...): childContextTypes cannot be defined on a functional component.\", Component.displayName || Component.name || \"Component\") : void 0;\n          }\n\n          if (workInProgress.ref !== null) {\n            var info = \"\";\n            var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n            if (ownerName) {\n              info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n            }\n\n            var warningKey = ownerName || workInProgress._debugID || \"\";\n            var debugSource = workInProgress._debugSource;\n\n            if (debugSource) {\n              warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n            }\n\n            if (!didWarnAboutStatelessRefs[warningKey]) {\n              didWarnAboutStatelessRefs[warningKey] = true;\n              warning$1(false, \"Stateless function components cannot be given refs. \" + \"Attempts to access this ref will fail.%s\", info);\n            }\n          }\n\n          if (typeof Component.getDerivedStateFromProps === \"function\") {\n            var _componentName = getComponentName(Component) || \"Unknown\";\n\n            if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n              warningWithoutStack$1(false, \"%s: Stateless functional components do not support getDerivedStateFromProps.\", _componentName);\n              didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n            }\n          }\n        }\n        reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);\n        memoizeProps(workInProgress, props);\n        return workInProgress.child;\n      }\n    }\n\n    function updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime) {\n      if (enableSuspense) {\n        var nextProps = workInProgress.pendingProps;\n        var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n        var nextDidTimeout = void 0;\n\n        if (current$$1 !== null && workInProgress.updateQueue !== null) {\n          workInProgress.updateQueue = null;\n          nextDidTimeout = true;\n          reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n          current$$1.child = null;\n        } else {\n          nextDidTimeout = !alreadyCaptured;\n        }\n\n        if ((workInProgress.mode & StrictMode) !== NoEffect) {\n          if (nextDidTimeout) {\n            workInProgress.effectTag |= Update;\n          } else {\n            workInProgress.stateNode = null;\n          }\n        }\n\n        var children = nextProps.children;\n        var nextChildren = void 0;\n\n        if (typeof children === \"function\") {\n          nextChildren = children(nextDidTimeout);\n        } else {\n          nextChildren = nextDidTimeout ? nextProps.fallback : children;\n        }\n\n        workInProgress.memoizedProps = nextProps;\n        workInProgress.memoizedState = nextDidTimeout;\n        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n        return workInProgress.child;\n      } else {\n        return null;\n      }\n    }\n\n    function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      var nextChildren = workInProgress.pendingProps;\n\n      if (current$$1 === null) {\n        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n        memoizeProps(workInProgress, nextChildren);\n      } else {\n        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n        memoizeProps(workInProgress, nextChildren);\n      }\n\n      return workInProgress.child;\n    }\n\n    function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {\n      var providerType = workInProgress.type;\n      var context = providerType._context;\n      var newProps = workInProgress.pendingProps;\n      var oldProps = workInProgress.memoizedProps;\n      var newValue = newProps.value;\n      workInProgress.memoizedProps = newProps;\n      {\n        var providerPropTypes = workInProgress.type.propTypes;\n\n        if (providerPropTypes) {\n          checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\", getCurrentFiberStackInDev);\n        }\n      }\n      pushProvider(workInProgress, newValue);\n\n      if (oldProps !== null) {\n        var oldValue = oldProps.value;\n        var changedBits = calculateChangedBits(context, newValue, oldValue);\n\n        if (changedBits === 0) {\n          if (oldProps.children === newProps.children && !hasContextChanged()) {\n            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n          }\n        } else {\n          propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n        }\n      }\n\n      var newChildren = newProps.children;\n      reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n      return workInProgress.child;\n    }\n\n    function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {\n      var context = workInProgress.type;\n      var newProps = workInProgress.pendingProps;\n      var render = newProps.children;\n      {\n        !(typeof render === \"function\") ? warningWithoutStack$1(false, \"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\") : void 0;\n      }\n      prepareToReadContext(workInProgress, renderExpirationTime);\n      var newValue = readContext(context, newProps.unstable_observedBits);\n      var newChildren = void 0;\n      {\n        ReactCurrentOwner$3.current = workInProgress;\n        setCurrentPhase(\"render\");\n        newChildren = render(newValue);\n        setCurrentPhase(null);\n      }\n      workInProgress.effectTag |= PerformedWork;\n      reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n      workInProgress.memoizedProps = newProps;\n      return workInProgress.child;\n    }\n\n    function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {\n      cancelWorkTimer(workInProgress);\n\n      if (current$$1 !== null) {\n        workInProgress.firstContextDependency = current$$1.firstContextDependency;\n      }\n\n      if (enableProfilerTimer) {\n        stopProfilerTimerIfRunning(workInProgress);\n      }\n\n      var childExpirationTime = workInProgress.childExpirationTime;\n\n      if (childExpirationTime === NoWork || childExpirationTime > renderExpirationTime) {\n        return null;\n      } else {\n        cloneChildFibers(current$$1, workInProgress);\n        return workInProgress.child;\n      }\n    }\n\n    function memoizeProps(workInProgress, nextProps) {\n      workInProgress.memoizedProps = nextProps;\n    }\n\n    function memoizeState(workInProgress, nextState) {\n      workInProgress.memoizedState = nextState;\n    }\n\n    function beginWork(current$$1, workInProgress, renderExpirationTime) {\n      var updateExpirationTime = workInProgress.expirationTime;\n\n      if (!hasContextChanged() && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {\n        switch (workInProgress.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress);\n            resetHydrationState();\n            break;\n\n          case HostComponent:\n            pushHostContext(workInProgress);\n            break;\n\n          case ClassComponent:\n            {\n              var Component = workInProgress.type;\n\n              if (isContextProvider(Component)) {\n                pushContextProvider(workInProgress);\n              }\n\n              break;\n            }\n\n          case ClassComponentLazy:\n            {\n              var thenable = workInProgress.type;\n\n              var _Component = getResultFromResolvedThenable(thenable);\n\n              if (isContextProvider(_Component)) {\n                pushContextProvider(workInProgress);\n              }\n\n              break;\n            }\n\n          case HostPortal:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n\n          case ContextProvider:\n            {\n              var newValue = workInProgress.memoizedProps.value;\n              pushProvider(workInProgress, newValue);\n              break;\n            }\n\n          case Profiler:\n            if (enableProfilerTimer) {\n              workInProgress.effectTag |= Update;\n            }\n\n            break;\n        }\n\n        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n      }\n\n      workInProgress.expirationTime = NoWork;\n\n      switch (workInProgress.tag) {\n        case IndeterminateComponent:\n          {\n            var _Component3 = workInProgress.type;\n            return mountIndeterminateComponent(current$$1, workInProgress, _Component3, renderExpirationTime);\n          }\n\n        case FunctionalComponent:\n          {\n            var _Component4 = workInProgress.type;\n            var _unresolvedProps = workInProgress.pendingProps;\n            return updateFunctionalComponent(current$$1, workInProgress, _Component4, _unresolvedProps, renderExpirationTime);\n          }\n\n        case FunctionalComponentLazy:\n          {\n            var _thenable2 = workInProgress.type;\n\n            var _Component5 = getResultFromResolvedThenable(_thenable2);\n\n            var _unresolvedProps2 = workInProgress.pendingProps;\n\n            var _child = updateFunctionalComponent(current$$1, workInProgress, _Component5, resolveDefaultProps(_Component5, _unresolvedProps2), renderExpirationTime);\n\n            workInProgress.memoizedProps = _unresolvedProps2;\n            return _child;\n          }\n\n        case ClassComponent:\n          {\n            var _Component6 = workInProgress.type;\n            var _unresolvedProps3 = workInProgress.pendingProps;\n            return updateClassComponent(current$$1, workInProgress, _Component6, _unresolvedProps3, renderExpirationTime);\n          }\n\n        case ClassComponentLazy:\n          {\n            var _thenable3 = workInProgress.type;\n\n            var _Component7 = getResultFromResolvedThenable(_thenable3);\n\n            var _unresolvedProps4 = workInProgress.pendingProps;\n\n            var _child2 = updateClassComponent(current$$1, workInProgress, _Component7, resolveDefaultProps(_Component7, _unresolvedProps4), renderExpirationTime);\n\n            workInProgress.memoizedProps = _unresolvedProps4;\n            return _child2;\n          }\n\n        case HostRoot:\n          return updateHostRoot(current$$1, workInProgress, renderExpirationTime);\n\n        case HostComponent:\n          return updateHostComponent(current$$1, workInProgress, renderExpirationTime);\n\n        case HostText:\n          return updateHostText(current$$1, workInProgress);\n\n        case PlaceholderComponent:\n          return updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime);\n\n        case HostPortal:\n          return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);\n\n        case ForwardRef:\n          {\n            var type = workInProgress.type;\n            return updateForwardRef(current$$1, workInProgress, type, workInProgress.pendingProps, renderExpirationTime);\n          }\n\n        case ForwardRefLazy:\n          var _thenable = workInProgress.type;\n\n          var _Component2 = getResultFromResolvedThenable(_thenable);\n\n          var unresolvedProps = workInProgress.pendingProps;\n          var child = updateForwardRef(current$$1, workInProgress, _Component2, resolveDefaultProps(_Component2, unresolvedProps), renderExpirationTime);\n          workInProgress.memoizedProps = unresolvedProps;\n          return child;\n\n        case Fragment:\n          return updateFragment(current$$1, workInProgress, renderExpirationTime);\n\n        case Mode:\n          return updateMode(current$$1, workInProgress, renderExpirationTime);\n\n        case Profiler:\n          return updateProfiler(current$$1, workInProgress, renderExpirationTime);\n\n        case ContextProvider:\n          return updateContextProvider(current$$1, workInProgress, renderExpirationTime);\n\n        case ContextConsumer:\n          return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);\n\n        default:\n          invariant(false, \"Unknown unit of work tag. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n      }\n    }\n\n    function markUpdate(workInProgress) {\n      workInProgress.effectTag |= Update;\n    }\n\n    function markRef$1(workInProgress) {\n      workInProgress.effectTag |= Ref;\n    }\n\n    function appendAllChildren(parent, workInProgress) {\n      var node = workInProgress.child;\n\n      while (node !== null) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          appendInitialChild(parent, node.stateNode);\n        } else if (node.tag === HostPortal) {} else if (node.child !== null) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === workInProgress) {\n          return;\n        }\n\n        while (node.sibling === null) {\n          if (node.return === null || node.return === workInProgress) {\n            return;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n    }\n\n    var updateHostContainer = void 0;\n    var updateHostComponent$1 = void 0;\n    var updateHostText$1 = void 0;\n\n    if (supportsMutation) {\n      updateHostContainer = function updateHostContainer(workInProgress) {};\n\n      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {\n        var oldProps = current.memoizedProps;\n\n        if (oldProps === newProps) {\n          return;\n        }\n\n        var instance = workInProgress.stateNode;\n        var currentHostContext = getHostContext();\n        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n        workInProgress.updateQueue = updatePayload;\n\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n\n      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else if (supportsPersistence) {\n      var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress) {\n        var node = workInProgress.child;\n\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {} else if (node.child !== null) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === workInProgress) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node.return === null || node.return === workInProgress) {\n              return;\n            }\n\n            node = node.return;\n          }\n\n          node.sibling.return = node.return;\n          node = node.sibling;\n        }\n      };\n\n      updateHostContainer = function updateHostContainer(workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n\n        if (childrenUnchanged) {} else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          portalOrRoot.pendingChildren = newChildSet;\n          markUpdate(workInProgress);\n          finalizeContainerChildren(container, newChildSet);\n        }\n      };\n\n      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {\n        var currentInstance = current.stateNode;\n        var oldProps = current.memoizedProps;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n\n        if (childrenUnchanged && oldProps === newProps) {\n          workInProgress.stateNode = currentInstance;\n          return;\n        }\n\n        var recyclableInstance = workInProgress.stateNode;\n        var currentHostContext = getHostContext();\n        var updatePayload = null;\n\n        if (oldProps !== newProps) {\n          updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n        }\n\n        if (childrenUnchanged && updatePayload === null) {\n          workInProgress.stateNode = currentInstance;\n          return;\n        }\n\n        var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n        if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n          markUpdate(workInProgress);\n        }\n\n        workInProgress.stateNode = newInstance;\n\n        if (childrenUnchanged) {\n          markUpdate(workInProgress);\n        } else {\n          appendAllChildren(newInstance, workInProgress);\n        }\n      };\n\n      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      updateHostContainer = function updateHostContainer(workInProgress) {};\n\n      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};\n\n      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};\n    }\n\n    function completeWork(current, workInProgress, renderExpirationTime) {\n      var newProps = workInProgress.pendingProps;\n\n      switch (workInProgress.tag) {\n        case FunctionalComponent:\n        case FunctionalComponentLazy:\n          break;\n\n        case ClassComponent:\n          {\n            var Component = workInProgress.type;\n\n            if (isContextProvider(Component)) {\n              popContext(workInProgress);\n            }\n\n            break;\n          }\n\n        case ClassComponentLazy:\n          {\n            var _Component = getResultFromResolvedThenable(workInProgress.type);\n\n            if (isContextProvider(_Component)) {\n              popContext(workInProgress);\n            }\n\n            break;\n          }\n\n        case HostRoot:\n          {\n            popHostContainer(workInProgress);\n            popTopLevelContextObject(workInProgress);\n            var fiberRoot = workInProgress.stateNode;\n\n            if (fiberRoot.pendingContext) {\n              fiberRoot.context = fiberRoot.pendingContext;\n              fiberRoot.pendingContext = null;\n            }\n\n            if (current === null || current.child === null) {\n              popHydrationState(workInProgress);\n              workInProgress.effectTag &= ~Placement;\n            }\n\n            updateHostContainer(workInProgress);\n            break;\n          }\n\n        case HostComponent:\n          {\n            popHostContext(workInProgress);\n            var rootContainerInstance = getRootHostContainer();\n            var type = workInProgress.type;\n\n            if (current !== null && workInProgress.stateNode != null) {\n              updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n              if (current.ref !== workInProgress.ref) {\n                markRef$1(workInProgress);\n              }\n            } else {\n              if (!newProps) {\n                invariant(workInProgress.stateNode !== null, \"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                break;\n              }\n\n              var currentHostContext = getHostContext();\n              var wasHydrated = popHydrationState(workInProgress);\n\n              if (wasHydrated) {\n                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n                  markUpdate(workInProgress);\n                }\n              } else {\n                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n                appendAllChildren(instance, workInProgress);\n\n                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n                  markUpdate(workInProgress);\n                }\n\n                workInProgress.stateNode = instance;\n              }\n\n              if (workInProgress.ref !== null) {\n                markRef$1(workInProgress);\n              }\n            }\n\n            break;\n          }\n\n        case HostText:\n          {\n            var newText = newProps;\n\n            if (current && workInProgress.stateNode != null) {\n              var oldText = current.memoizedProps;\n              updateHostText$1(current, workInProgress, oldText, newText);\n            } else {\n              if (typeof newText !== \"string\") {\n                invariant(workInProgress.stateNode !== null, \"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n              }\n\n              var _rootContainerInstance = getRootHostContainer();\n\n              var _currentHostContext = getHostContext();\n\n              var _wasHydrated = popHydrationState(workInProgress);\n\n              if (_wasHydrated) {\n                if (prepareToHydrateHostTextInstance(workInProgress)) {\n                  markUpdate(workInProgress);\n                }\n              } else {\n                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n              }\n            }\n\n            break;\n          }\n\n        case ForwardRef:\n        case ForwardRefLazy:\n          break;\n\n        case PlaceholderComponent:\n          break;\n\n        case Fragment:\n          break;\n\n        case Mode:\n          break;\n\n        case Profiler:\n          break;\n\n        case HostPortal:\n          popHostContainer(workInProgress);\n          updateHostContainer(workInProgress);\n          break;\n\n        case ContextProvider:\n          popProvider(workInProgress);\n          break;\n\n        case ContextConsumer:\n          break;\n\n        case IndeterminateComponent:\n          invariant(false, \"An indeterminate component should have become determinate before \" + \"completing. This error is likely caused by a bug in React. Please \" + \"file an issue.\");\n\n        default:\n          invariant(false, \"Unknown unit of work tag. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n      }\n\n      return null;\n    }\n\n    function showErrorDialog(capturedError) {\n      var componentStack = capturedError.componentStack,\n          error = capturedError.error;\n      var errorToHandle = void 0;\n\n      if (error instanceof Error) {\n        var message = error.message,\n            name = error.name;\n        var summary = message ? name + \": \" + message : name;\n        errorToHandle = error;\n\n        try {\n          errorToHandle.message = summary + \"\\n\\nThis error is located at:\" + componentStack;\n        } catch (e) {}\n      } else if (typeof error === \"string\") {\n        errorToHandle = new Error(error + \"\\n\\nThis error is located at:\" + componentStack);\n      } else {\n        errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n      }\n\n      ExceptionsManager.handleException(errorToHandle, false);\n      return false;\n    }\n\n    function logCapturedError(capturedError) {\n      var logError = showErrorDialog(capturedError);\n\n      if (logError === false) {\n        return;\n      }\n\n      var error = capturedError.error;\n      {\n        var componentName = capturedError.componentName,\n            componentStack = capturedError.componentStack,\n            errorBoundaryName = capturedError.errorBoundaryName,\n            errorBoundaryFound = capturedError.errorBoundaryFound,\n            willRetry = capturedError.willRetry;\n\n        if (error != null && error._suppressLogging) {\n          if (errorBoundaryFound && willRetry) {\n            return;\n          }\n\n          console.error(error);\n        }\n\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n        var errorBoundaryMessage = void 0;\n\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n          } else {\n            errorBoundaryMessage = \"This error was initially handled by the error boundary \" + errorBoundaryName + \".\\n\" + \"Recreating the tree from scratch failed so React will unmount the tree.\";\n          }\n        } else {\n          errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" + \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n        }\n\n        var combinedMessage = \"\" + componentNameMessage + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage);\n        console.error(combinedMessage);\n      }\n    }\n\n    var emptyObject$1 = {};\n    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    {\n      didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    }\n\n    function logError(boundary, errorInfo) {\n      var source = errorInfo.source;\n      var stack = errorInfo.stack;\n\n      if (stack === null && source !== null) {\n        stack = getStackByFiberInDevAndProd(source);\n      }\n\n      var capturedError = {\n        componentName: source !== null ? getComponentName(source.type) : null,\n        componentStack: stack !== null ? stack : \"\",\n        error: errorInfo.value,\n        errorBoundary: null,\n        errorBoundaryName: null,\n        errorBoundaryFound: false,\n        willRetry: false\n      };\n\n      if (boundary !== null && boundary.tag === ClassComponent) {\n        capturedError.errorBoundary = boundary.stateNode;\n        capturedError.errorBoundaryName = getComponentName(boundary.type);\n        capturedError.errorBoundaryFound = true;\n        capturedError.willRetry = true;\n      }\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        });\n      }\n    }\n\n    var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {\n      startPhaseTimer(current$$1, \"componentWillUnmount\");\n      instance.props = current$$1.memoizedProps;\n      instance.state = current$$1.memoizedState;\n      instance.componentWillUnmount();\n      stopPhaseTimer();\n    };\n\n    function safelyCallComponentWillUnmount(current$$1, instance) {\n      {\n        invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);\n\n        if (hasCaughtError()) {\n          var unmountError = clearCaughtError();\n          captureCommitPhaseError(current$$1, unmountError);\n        }\n      }\n    }\n\n    function safelyDetachRef(current$$1) {\n      var ref = current$$1.ref;\n\n      if (ref !== null) {\n        if (typeof ref === \"function\") {\n          {\n            invokeGuardedCallback(null, ref, null, null);\n\n            if (hasCaughtError()) {\n              var refError = clearCaughtError();\n              captureCommitPhaseError(current$$1, refError);\n            }\n          }\n        } else {\n          ref.current = null;\n        }\n      }\n    }\n\n    function commitBeforeMutationLifeCycles(current$$1, finishedWork) {\n      switch (finishedWork.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            if (finishedWork.effectTag & Snapshot) {\n              if (current$$1 !== null) {\n                var prevProps = current$$1.memoizedProps;\n                var prevState = current$$1.memoizedState;\n                startPhaseTimer(finishedWork, \"getSnapshotBeforeUpdate\");\n                var instance = finishedWork.stateNode;\n                instance.props = finishedWork.memoizedProps;\n                instance.state = finishedWork.memoizedState;\n                var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n                {\n                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n                  if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                    didWarnSet.add(finishedWork.type);\n                    warningWithoutStack$1(false, \"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" + \"must be returned. You have returned undefined.\", getComponentName(finishedWork.type));\n                  }\n                }\n                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                stopPhaseTimer();\n              }\n            }\n\n            return;\n          }\n\n        case HostRoot:\n        case HostComponent:\n        case HostText:\n        case HostPortal:\n          return;\n\n        default:\n          {\n            invariant(false, \"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n          }\n      }\n    }\n\n    function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {\n      switch (finishedWork.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            var instance = finishedWork.stateNode;\n\n            if (finishedWork.effectTag & Update) {\n              if (current$$1 === null) {\n                startPhaseTimer(finishedWork, \"componentDidMount\");\n                instance.props = finishedWork.memoizedProps;\n                instance.state = finishedWork.memoizedState;\n                instance.componentDidMount();\n                stopPhaseTimer();\n              } else {\n                var prevProps = current$$1.memoizedProps;\n                var prevState = current$$1.memoizedState;\n                startPhaseTimer(finishedWork, \"componentDidUpdate\");\n                instance.props = finishedWork.memoizedProps;\n                instance.state = finishedWork.memoizedState;\n                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                stopPhaseTimer();\n              }\n            }\n\n            var updateQueue = finishedWork.updateQueue;\n\n            if (updateQueue !== null) {\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n            }\n\n            return;\n          }\n\n        case HostRoot:\n          {\n            var _updateQueue = finishedWork.updateQueue;\n\n            if (_updateQueue !== null) {\n              var _instance = null;\n\n              if (finishedWork.child !== null) {\n                switch (finishedWork.child.tag) {\n                  case HostComponent:\n                    _instance = getPublicInstance(finishedWork.child.stateNode);\n                    break;\n\n                  case ClassComponent:\n                  case ClassComponentLazy:\n                    _instance = finishedWork.child.stateNode;\n                    break;\n                }\n              }\n\n              commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);\n            }\n\n            return;\n          }\n\n        case HostComponent:\n          {\n            var _instance2 = finishedWork.stateNode;\n\n            if (current$$1 === null && finishedWork.effectTag & Update) {\n              var type = finishedWork.type;\n              var props = finishedWork.memoizedProps;\n            }\n\n            return;\n          }\n\n        case HostText:\n          {\n            return;\n          }\n\n        case HostPortal:\n          {\n            return;\n          }\n\n        case Profiler:\n          {\n            if (enableProfilerTimer) {\n              var onRender = finishedWork.memoizedProps.onRender;\n\n              if (enableSchedulerTracking) {\n                onRender(finishedWork.memoizedProps.id, current$$1 === null ? \"mount\" : \"update\", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);\n              } else {\n                onRender(finishedWork.memoizedProps.id, current$$1 === null ? \"mount\" : \"update\", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());\n              }\n            }\n\n            return;\n          }\n\n        case PlaceholderComponent:\n          {\n            if (enableSuspense) {\n              if ((finishedWork.mode & StrictMode) === NoEffect) {\n                finishedWork.updateQueue = emptyObject$1;\n                scheduleWork(finishedWork, Sync);\n              } else {\n                var currentTime = requestCurrentTime();\n                finishedWork.stateNode = {\n                  timedOutAt: currentTime\n                };\n              }\n            }\n\n            return;\n          }\n\n        default:\n          {\n            invariant(false, \"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n          }\n      }\n    }\n\n    function commitAttachRef(finishedWork) {\n      var ref = finishedWork.ref;\n\n      if (ref !== null) {\n        var instance = finishedWork.stateNode;\n        var instanceToUse = void 0;\n\n        switch (finishedWork.tag) {\n          case HostComponent:\n            instanceToUse = getPublicInstance(instance);\n            break;\n\n          default:\n            instanceToUse = instance;\n        }\n\n        if (typeof ref === \"function\") {\n          ref(instanceToUse);\n        } else {\n          {\n            if (!ref.hasOwnProperty(\"current\")) {\n              warningWithoutStack$1(false, \"Unexpected ref object provided for %s. \" + \"Use either a ref-setter function or React.createRef().%s\", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));\n            }\n          }\n          ref.current = instanceToUse;\n        }\n      }\n    }\n\n    function commitDetachRef(current$$1) {\n      var currentRef = current$$1.ref;\n\n      if (currentRef !== null) {\n        if (typeof currentRef === \"function\") {\n          currentRef(null);\n        } else {\n          currentRef.current = null;\n        }\n      }\n    }\n\n    function commitUnmount(current$$1) {\n      onCommitUnmount(current$$1);\n\n      switch (current$$1.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            safelyDetachRef(current$$1);\n            var instance = current$$1.stateNode;\n\n            if (typeof instance.componentWillUnmount === \"function\") {\n              safelyCallComponentWillUnmount(current$$1, instance);\n            }\n\n            return;\n          }\n\n        case HostComponent:\n          {\n            safelyDetachRef(current$$1);\n            return;\n          }\n\n        case HostPortal:\n          {\n            if (supportsMutation) {\n              unmountHostComponents(current$$1);\n            } else if (supportsPersistence) {\n              emptyPortalContainer(current$$1);\n            }\n\n            return;\n          }\n      }\n    }\n\n    function commitNestedUnmounts(root) {\n      var node = root;\n\n      while (true) {\n        commitUnmount(node);\n\n        if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === root) {\n          return;\n        }\n\n        while (node.sibling === null) {\n          if (node.return === null || node.return === root) {\n            return;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n    }\n\n    function detachFiber(current$$1) {\n      current$$1.return = null;\n      current$$1.child = null;\n\n      if (current$$1.alternate) {\n        current$$1.alternate.child = null;\n        current$$1.alternate.return = null;\n      }\n    }\n\n    function emptyPortalContainer(current$$1) {\n      if (!supportsPersistence) {\n        return;\n      }\n\n      var portal = current$$1.stateNode;\n      var containerInfo = portal.containerInfo;\n      var emptyChildSet = createContainerChildSet(containerInfo);\n      replaceContainerChildren(containerInfo, emptyChildSet);\n    }\n\n    function commitContainer(finishedWork) {\n      if (!supportsPersistence) {\n        return;\n      }\n\n      switch (finishedWork.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            return;\n          }\n\n        case HostComponent:\n          {\n            return;\n          }\n\n        case HostText:\n          {\n            return;\n          }\n\n        case HostRoot:\n        case HostPortal:\n          {\n            var portalOrRoot = finishedWork.stateNode;\n            var containerInfo = portalOrRoot.containerInfo,\n                _pendingChildren = portalOrRoot.pendingChildren;\n            replaceContainerChildren(containerInfo, _pendingChildren);\n            return;\n          }\n\n        default:\n          {\n            invariant(false, \"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n          }\n      }\n    }\n\n    function getHostParentFiber(fiber) {\n      var parent = fiber.return;\n\n      while (parent !== null) {\n        if (isHostParent(parent)) {\n          return parent;\n        }\n\n        parent = parent.return;\n      }\n\n      invariant(false, \"Expected to find a host parent. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n    }\n\n    function isHostParent(fiber) {\n      return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n    }\n\n    function getHostSibling(fiber) {\n      var node = fiber;\n\n      siblings: while (true) {\n        while (node.sibling === null) {\n          if (node.return === null || isHostParent(node.return)) {\n            return null;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n\n        while (node.tag !== HostComponent && node.tag !== HostText) {\n          if (node.effectTag & Placement) {\n            continue siblings;\n          }\n\n          if (node.child === null || node.tag === HostPortal) {\n            continue siblings;\n          } else {\n            node.child.return = node;\n            node = node.child;\n          }\n        }\n\n        if (!(node.effectTag & Placement)) {\n          return node.stateNode;\n        }\n      }\n    }\n\n    function commitPlacement(finishedWork) {\n      if (!supportsMutation) {\n        return;\n      }\n\n      var parentFiber = getHostParentFiber(finishedWork);\n      var parent = void 0;\n      var isContainer = void 0;\n\n      switch (parentFiber.tag) {\n        case HostComponent:\n          parent = parentFiber.stateNode;\n          isContainer = false;\n          break;\n\n        case HostRoot:\n          parent = parentFiber.stateNode.containerInfo;\n          isContainer = true;\n          break;\n\n        case HostPortal:\n          parent = parentFiber.stateNode.containerInfo;\n          isContainer = true;\n          break;\n\n        default:\n          invariant(false, \"Invalid host parent fiber. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n      }\n\n      if (parentFiber.effectTag & ContentReset) {\n        parentFiber.effectTag &= ~ContentReset;\n      }\n\n      var before = getHostSibling(finishedWork);\n      var node = finishedWork;\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          if (before) {\n            if (isContainer) {\n              insertInContainerBefore(parent, node.stateNode, before);\n            } else {\n              insertBefore(parent, node.stateNode, before);\n            }\n          } else {\n            if (isContainer) {\n              appendChildToContainer(parent, node.stateNode);\n            } else {\n              appendChild(parent, node.stateNode);\n            }\n          }\n        } else if (node.tag === HostPortal) {} else if (node.child !== null) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === finishedWork) {\n          return;\n        }\n\n        while (node.sibling === null) {\n          if (node.return === null || node.return === finishedWork) {\n            return;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n    }\n\n    function unmountHostComponents(current$$1) {\n      var node = current$$1;\n      var currentParentIsValid = false;\n      var currentParent = void 0;\n      var currentParentIsContainer = void 0;\n\n      while (true) {\n        if (!currentParentIsValid) {\n          var parent = node.return;\n\n          findParent: while (true) {\n            invariant(parent !== null, \"Expected to find a host parent. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n\n            switch (parent.tag) {\n              case HostComponent:\n                currentParent = parent.stateNode;\n                currentParentIsContainer = false;\n                break findParent;\n\n              case HostRoot:\n                currentParent = parent.stateNode.containerInfo;\n                currentParentIsContainer = true;\n                break findParent;\n\n              case HostPortal:\n                currentParent = parent.stateNode.containerInfo;\n                currentParentIsContainer = true;\n                break findParent;\n            }\n\n            parent = parent.return;\n          }\n\n          currentParentIsValid = true;\n        }\n\n        if (node.tag === HostComponent || node.tag === HostText) {\n          commitNestedUnmounts(node);\n\n          if (currentParentIsContainer) {\n            removeChildFromContainer(currentParent, node.stateNode);\n          } else {\n            removeChild(currentParent, node.stateNode);\n          }\n        } else if (node.tag === HostPortal) {\n          currentParent = node.stateNode.containerInfo;\n          currentParentIsContainer = true;\n\n          if (node.child !== null) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n        } else {\n          commitUnmount(node);\n\n          if (node.child !== null) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n        }\n\n        if (node === current$$1) {\n          return;\n        }\n\n        while (node.sibling === null) {\n          if (node.return === null || node.return === current$$1) {\n            return;\n          }\n\n          node = node.return;\n\n          if (node.tag === HostPortal) {\n            currentParentIsValid = false;\n          }\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n    }\n\n    function commitDeletion(current$$1) {\n      if (supportsMutation) {\n        unmountHostComponents(current$$1);\n      } else {\n        commitNestedUnmounts(current$$1);\n      }\n\n      detachFiber(current$$1);\n    }\n\n    function commitWork(current$$1, finishedWork) {\n      if (!supportsMutation) {\n        commitContainer(finishedWork);\n        return;\n      }\n\n      switch (finishedWork.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            return;\n          }\n\n        case HostComponent:\n          {\n            var instance = finishedWork.stateNode;\n\n            if (instance != null) {\n              var newProps = finishedWork.memoizedProps;\n              var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;\n              var type = finishedWork.type;\n              var updatePayload = finishedWork.updateQueue;\n              finishedWork.updateQueue = null;\n\n              if (updatePayload !== null) {\n                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n              }\n            }\n\n            return;\n          }\n\n        case HostText:\n          {\n            invariant(finishedWork.stateNode !== null, \"This should have a text node initialized. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n            var textInstance = finishedWork.stateNode;\n            var newText = finishedWork.memoizedProps;\n            var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;\n            commitTextUpdate(textInstance, oldText, newText);\n            return;\n          }\n\n        case HostRoot:\n          {\n            return;\n          }\n\n        case Profiler:\n          {\n            return;\n          }\n\n        case PlaceholderComponent:\n          {\n            return;\n          }\n\n        default:\n          {\n            invariant(false, \"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n          }\n      }\n    }\n\n    function commitResetTextContent(current$$1) {\n      if (!supportsMutation) {\n        return;\n      }\n\n      resetTextContent(current$$1.stateNode);\n    }\n\n    function NoopComponent() {\n      return null;\n    }\n\n    function createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n      var update = createUpdate(expirationTime);\n      update.tag = CaptureUpdate;\n      update.payload = {\n        element: null\n      };\n      var error = errorInfo.value;\n\n      update.callback = function () {\n        onUncaughtError(error);\n        logError(fiber, errorInfo);\n      };\n\n      return update;\n    }\n\n    function createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n      var update = createUpdate(expirationTime);\n      update.tag = CaptureUpdate;\n      var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n\n      if (enableGetDerivedStateFromCatch && typeof getDerivedStateFromCatch === \"function\") {\n        var error = errorInfo.value;\n\n        update.payload = function () {\n          return getDerivedStateFromCatch(error);\n        };\n      }\n\n      var inst = fiber.stateNode;\n\n      if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n        update.callback = function callback() {\n          if (!enableGetDerivedStateFromCatch || getDerivedStateFromCatch !== \"function\") {\n            markLegacyErrorBoundaryAsFailed(this);\n          }\n\n          var error = errorInfo.value;\n          var stack = errorInfo.stack;\n          logError(fiber, errorInfo);\n          this.componentDidCatch(error, {\n            componentStack: stack !== null ? stack : \"\"\n          });\n        };\n      }\n\n      return update;\n    }\n\n    function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {\n      sourceFiber.effectTag |= Incomplete;\n      sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n      if (enableSuspense && value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n        var thenable = value;\n        var _workInProgress = returnFiber;\n        var earliestTimeoutMs = -1;\n        var startTimeMs = -1;\n\n        do {\n          if (_workInProgress.tag === PlaceholderComponent) {\n            var current = _workInProgress.alternate;\n\n            if (current !== null && current.memoizedState === true && current.stateNode !== null) {\n              var timedOutAt = current.stateNode.timedOutAt;\n              startTimeMs = expirationTimeToMs(timedOutAt);\n              break;\n            }\n\n            var timeoutPropMs = _workInProgress.pendingProps.delayMs;\n\n            if (typeof timeoutPropMs === \"number\") {\n              if (timeoutPropMs <= 0) {\n                earliestTimeoutMs = 0;\n              } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {\n                earliestTimeoutMs = timeoutPropMs;\n              }\n            }\n          }\n\n          _workInProgress = _workInProgress.return;\n        } while (_workInProgress !== null);\n\n        _workInProgress = returnFiber;\n\n        do {\n          if (_workInProgress.tag === PlaceholderComponent) {\n            var didTimeout = _workInProgress.memoizedState;\n\n            if (!didTimeout) {\n              var pingTime = (_workInProgress.mode & AsyncMode) === NoEffect ? Sync : renderExpirationTime;\n              var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, pingTime);\n              thenable.then(onResolveOrReject, onResolveOrReject);\n\n              if ((_workInProgress.mode & StrictMode) === NoEffect) {\n                _workInProgress.effectTag |= Update;\n                var nextChildren = null;\n                reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);\n                sourceFiber.effectTag &= ~Incomplete;\n\n                if (sourceFiber.tag === IndeterminateComponent) {\n                  sourceFiber.tag = FunctionalComponent;\n                }\n\n                if (sourceFiber.tag === ClassComponent || sourceFiber.tag === ClassComponentLazy) {\n                  sourceFiber.effectTag &= ~LifecycleEffectMask;\n\n                  if (sourceFiber.alternate === null) {\n                    sourceFiber.tag = FunctionalComponent;\n                    sourceFiber.type = NoopComponent;\n                  }\n                }\n\n                return;\n              }\n\n              var absoluteTimeoutMs = void 0;\n\n              if (earliestTimeoutMs === -1) {\n                absoluteTimeoutMs = maxSigned31BitInt;\n              } else {\n                if (startTimeMs === -1) {\n                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);\n                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n                }\n\n                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n              }\n\n              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n              _workInProgress.effectTag |= ShouldCapture;\n              _workInProgress.expirationTime = renderExpirationTime;\n              return;\n            }\n          }\n\n          _workInProgress = _workInProgress.return;\n        } while (_workInProgress !== null);\n\n        value = new Error(\"An update was suspended, but no placeholder UI was provided.\");\n      }\n\n      renderDidError();\n      value = createCapturedValue(value, sourceFiber);\n      var workInProgress = returnFiber;\n\n      do {\n        switch (workInProgress.tag) {\n          case HostRoot:\n            {\n              var _errorInfo = value;\n              workInProgress.effectTag |= ShouldCapture;\n              workInProgress.expirationTime = renderExpirationTime;\n              var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);\n              enqueueCapturedUpdate(workInProgress, update);\n              return;\n            }\n\n          case ClassComponent:\n          case ClassComponentLazy:\n            var errorInfo = value;\n            var ctor = workInProgress.type;\n            var instance = workInProgress.stateNode;\n\n            if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === \"function\" && enableGetDerivedStateFromCatch || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n              workInProgress.effectTag |= ShouldCapture;\n              workInProgress.expirationTime = renderExpirationTime;\n\n              var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n\n              enqueueCapturedUpdate(workInProgress, _update);\n              return;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        workInProgress = workInProgress.return;\n      } while (workInProgress !== null);\n    }\n\n    function unwindWork(workInProgress, renderExpirationTime) {\n      switch (workInProgress.tag) {\n        case ClassComponent:\n          {\n            var Component = workInProgress.type;\n\n            if (isContextProvider(Component)) {\n              popContext(workInProgress);\n            }\n\n            var effectTag = workInProgress.effectTag;\n\n            if (effectTag & ShouldCapture) {\n              workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n              return workInProgress;\n            }\n\n            return null;\n          }\n\n        case ClassComponentLazy:\n          {\n            var _Component = workInProgress.type._reactResult;\n\n            if (isContextProvider(_Component)) {\n              popContext(workInProgress);\n            }\n\n            var _effectTag = workInProgress.effectTag;\n\n            if (_effectTag & ShouldCapture) {\n              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n              return workInProgress;\n            }\n\n            return null;\n          }\n\n        case HostRoot:\n          {\n            popHostContainer(workInProgress);\n            popTopLevelContextObject(workInProgress);\n            var _effectTag2 = workInProgress.effectTag;\n            invariant((_effectTag2 & DidCapture) === NoEffect, \"The root failed to unmount after an error. This is likely a bug in \" + \"React. Please file an issue.\");\n            workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;\n            return workInProgress;\n          }\n\n        case HostComponent:\n          {\n            popHostContext(workInProgress);\n            return null;\n          }\n\n        case PlaceholderComponent:\n          {\n            var _effectTag3 = workInProgress.effectTag;\n\n            if (_effectTag3 & ShouldCapture) {\n              workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;\n              return workInProgress;\n            }\n\n            return null;\n          }\n\n        case HostPortal:\n          popHostContainer(workInProgress);\n          return null;\n\n        case ContextProvider:\n          popProvider(workInProgress);\n          return null;\n\n        default:\n          return null;\n      }\n    }\n\n    function unwindInterruptedWork(interruptedWork) {\n      switch (interruptedWork.tag) {\n        case ClassComponent:\n          {\n            var childContextTypes = interruptedWork.type.childContextTypes;\n\n            if (childContextTypes !== null && childContextTypes !== undefined) {\n              popContext(interruptedWork);\n            }\n\n            break;\n          }\n\n        case ClassComponentLazy:\n          {\n            var _childContextTypes = interruptedWork.type._reactResult.childContextTypes;\n\n            if (_childContextTypes !== null && _childContextTypes !== undefined) {\n              popContext(interruptedWork);\n            }\n\n            break;\n          }\n\n        case HostRoot:\n          {\n            popHostContainer(interruptedWork);\n            popTopLevelContextObject(interruptedWork);\n            break;\n          }\n\n        case HostComponent:\n          {\n            popHostContext(interruptedWork);\n            break;\n          }\n\n        case HostPortal:\n          popHostContainer(interruptedWork);\n          break;\n\n        case ContextProvider:\n          popProvider(interruptedWork);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    var Dispatcher = {\n      readContext: readContext\n    };\n    var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;\n    var didWarnAboutStateTransition = void 0;\n    var didWarnSetStateChildContext = void 0;\n    var warnAboutUpdateOnUnmounted = void 0;\n    var warnAboutInvalidUpdates = void 0;\n\n    if (enableSchedulerTracking) {\n      invariant(tracking.__interactionsRef != null && tracking.__interactionsRef.current != null, \"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) \" + \"without also replacing the `schedule/tracking` module with `schedule/tracking-profiling`. \" + \"Your bundler might have a setting for aliasing both modules. \" + \"Learn more at http://fb.me/react-profiling\");\n    }\n\n    {\n      didWarnAboutStateTransition = false;\n      didWarnSetStateChildContext = false;\n      var didWarnStateUpdateForUnmountedComponent = {};\n\n      warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {\n        var componentName = getComponentName(fiber.type) || \"ReactClass\";\n\n        if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n          return;\n        }\n\n        warningWithoutStack$1(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + \"is a no-op, but it indicates a memory leak in your application. To \" + \"fix, cancel all subscriptions and asynchronous tasks in the \" + \"componentWillUnmount method.%s\", getStackByFiberInDevAndProd(fiber));\n        didWarnStateUpdateForUnmountedComponent[componentName] = true;\n      };\n\n      warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {\n        switch (phase) {\n          case \"getChildContext\":\n            if (didWarnSetStateChildContext) {\n              return;\n            }\n\n            warningWithoutStack$1(false, \"setState(...): Cannot call setState() inside getChildContext()\");\n            didWarnSetStateChildContext = true;\n            break;\n\n          case \"render\":\n            if (didWarnAboutStateTransition) {\n              return;\n            }\n\n            warningWithoutStack$1(false, \"Cannot update during an existing state transition (such as within \" + \"`render`). Render methods should be a pure function of props and state.\");\n            didWarnAboutStateTransition = true;\n            break;\n        }\n      };\n    }\n    var expirationContext = NoWork;\n    var isWorking = false;\n    var nextUnitOfWork = null;\n    var nextRoot = null;\n    var nextRenderExpirationTime = NoWork;\n    var nextLatestAbsoluteTimeoutMs = -1;\n    var nextRenderDidError = false;\n    var nextEffect = null;\n    var isCommitting$1 = false;\n    var legacyErrorBoundariesThatAlreadyFailed = null;\n    var interruptedBy = null;\n    var suspenseDidTimeout = false;\n    var stashedWorkInProgressProperties = void 0;\n    var replayUnitOfWork = void 0;\n    var isReplayingFailedUnitOfWork = void 0;\n    var originalReplayError = void 0;\n    var rethrowOriginalError = void 0;\n\n    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n      stashedWorkInProgressProperties = null;\n      isReplayingFailedUnitOfWork = false;\n      originalReplayError = null;\n\n      replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {\n        if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n          return;\n        }\n\n        if (stashedWorkInProgressProperties === null) {\n          warningWithoutStack$1(false, \"Could not replay rendering after an error. This is likely a bug in React. \" + \"Please file an issue.\");\n          return;\n        }\n\n        assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n\n        switch (failedUnitOfWork.tag) {\n          case HostRoot:\n            popHostContainer(failedUnitOfWork);\n            popTopLevelContextObject(failedUnitOfWork);\n            break;\n\n          case HostComponent:\n            popHostContext(failedUnitOfWork);\n            break;\n\n          case ClassComponent:\n            {\n              var Component = failedUnitOfWork.type;\n\n              if (isContextProvider(Component)) {\n                popContext(failedUnitOfWork);\n              }\n\n              break;\n            }\n\n          case ClassComponentLazy:\n            {\n              var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);\n\n              if (isContextProvider(_Component)) {\n                popContext(failedUnitOfWork);\n              }\n\n              break;\n            }\n\n          case HostPortal:\n            popHostContainer(failedUnitOfWork);\n            break;\n\n          case ContextProvider:\n            popProvider(failedUnitOfWork);\n            break;\n        }\n\n        isReplayingFailedUnitOfWork = true;\n        originalReplayError = thrownValue;\n        invokeGuardedCallback(null, workLoop, null, isYieldy);\n        isReplayingFailedUnitOfWork = false;\n        originalReplayError = null;\n\n        if (hasCaughtError()) {\n          var replayError = clearCaughtError();\n\n          if (replayError != null && thrownValue != null) {\n            try {\n              if (replayError._suppressLogging) {\n                thrownValue._suppressLogging = true;\n              }\n            } catch (inner) {}\n          }\n        } else {\n          nextUnitOfWork = failedUnitOfWork;\n        }\n      };\n\n      rethrowOriginalError = function rethrowOriginalError() {\n        throw originalReplayError;\n      };\n    }\n\n    function resetStack() {\n      if (nextUnitOfWork !== null) {\n        var interruptedWork = nextUnitOfWork.return;\n\n        while (interruptedWork !== null) {\n          unwindInterruptedWork(interruptedWork);\n          interruptedWork = interruptedWork.return;\n        }\n      }\n\n      {\n        ReactStrictModeWarnings.discardPendingWarnings();\n        checkThatStackIsEmpty();\n      }\n      nextRoot = null;\n      nextRenderExpirationTime = NoWork;\n      nextLatestAbsoluteTimeoutMs = -1;\n      nextRenderDidError = false;\n      nextUnitOfWork = null;\n    }\n\n    function commitAllHostEffects() {\n      while (nextEffect !== null) {\n        {\n          setCurrentFiber(nextEffect);\n        }\n        recordEffect();\n        var effectTag = nextEffect.effectTag;\n\n        if (effectTag & ContentReset) {\n          commitResetTextContent(nextEffect);\n        }\n\n        if (effectTag & Ref) {\n          var current$$1 = nextEffect.alternate;\n\n          if (current$$1 !== null) {\n            commitDetachRef(current$$1);\n          }\n        }\n\n        var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n\n        switch (primaryEffectTag) {\n          case Placement:\n            {\n              commitPlacement(nextEffect);\n              nextEffect.effectTag &= ~Placement;\n              break;\n            }\n\n          case PlacementAndUpdate:\n            {\n              commitPlacement(nextEffect);\n              nextEffect.effectTag &= ~Placement;\n              var _current = nextEffect.alternate;\n              commitWork(_current, nextEffect);\n              break;\n            }\n\n          case Update:\n            {\n              var _current2 = nextEffect.alternate;\n              commitWork(_current2, nextEffect);\n              break;\n            }\n\n          case Deletion:\n            {\n              commitDeletion(nextEffect);\n              break;\n            }\n        }\n\n        nextEffect = nextEffect.nextEffect;\n      }\n\n      {\n        resetCurrentFiber();\n      }\n    }\n\n    function commitBeforeMutationLifecycles() {\n      while (nextEffect !== null) {\n        {\n          setCurrentFiber(nextEffect);\n        }\n        var effectTag = nextEffect.effectTag;\n\n        if (effectTag & Snapshot) {\n          recordEffect();\n          var current$$1 = nextEffect.alternate;\n          commitBeforeMutationLifeCycles(current$$1, nextEffect);\n        }\n\n        nextEffect = nextEffect.nextEffect;\n      }\n\n      {\n        resetCurrentFiber();\n      }\n    }\n\n    function commitAllLifeCycles(finishedRoot, committedExpirationTime) {\n      {\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n        if (warnAboutDeprecatedLifecycles) {\n          ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n        }\n\n        if (warnAboutLegacyContextAPI) {\n          ReactStrictModeWarnings.flushLegacyContextWarning();\n        }\n      }\n\n      while (nextEffect !== null) {\n        var effectTag = nextEffect.effectTag;\n\n        if (effectTag & (Update | Callback)) {\n          recordEffect();\n          var current$$1 = nextEffect.alternate;\n          commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);\n        }\n\n        if (effectTag & Ref) {\n          recordEffect();\n          commitAttachRef(nextEffect);\n        }\n\n        var next = nextEffect.nextEffect;\n        nextEffect.nextEffect = null;\n        nextEffect = next;\n      }\n    }\n\n    function isAlreadyFailedLegacyErrorBoundary(instance) {\n      return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n    }\n\n    function markLegacyErrorBoundaryAsFailed(instance) {\n      if (legacyErrorBoundariesThatAlreadyFailed === null) {\n        legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n      } else {\n        legacyErrorBoundariesThatAlreadyFailed.add(instance);\n      }\n    }\n\n    function commitRoot(root, finishedWork) {\n      isWorking = true;\n      isCommitting$1 = true;\n      startCommitTimer();\n      invariant(root.current !== finishedWork, \"Cannot commit the same tree as before. This is probably a bug \" + \"related to the return field. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n      var committedExpirationTime = root.pendingCommitExpirationTime;\n      invariant(committedExpirationTime !== NoWork, \"Cannot commit an incomplete root. This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n      root.pendingCommitExpirationTime = NoWork;\n      var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n      var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n      var earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || childExpirationTimeBeforeCommit !== NoWork && childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;\n      markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n      var prevInteractions = null;\n      var committedInteractions = enableSchedulerTracking ? [] : null;\n\n      if (enableSchedulerTracking) {\n        prevInteractions = tracking.__interactionsRef.current;\n        tracking.__interactionsRef.current = root.memoizedInteractions;\n        root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n          if (scheduledExpirationTime <= committedExpirationTime) {\n            committedInteractions.push.apply(committedInteractions, Array.from(scheduledInteractions));\n            root.pendingInteractionMap.delete(scheduledExpirationTime);\n          }\n        });\n      }\n\n      ReactCurrentOwner$2.current = null;\n      var firstEffect = void 0;\n\n      if (finishedWork.effectTag > PerformedWork) {\n        if (finishedWork.lastEffect !== null) {\n          finishedWork.lastEffect.nextEffect = finishedWork;\n          firstEffect = finishedWork.firstEffect;\n        } else {\n          firstEffect = finishedWork;\n        }\n      } else {\n        firstEffect = finishedWork.firstEffect;\n      }\n\n      prepareForCommit(root.containerInfo);\n      nextEffect = firstEffect;\n      startCommitSnapshotEffectsTimer();\n\n      while (nextEffect !== null) {\n        var didError = false;\n        var error = void 0;\n        {\n          invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        }\n\n        if (didError) {\n          invariant(nextEffect !== null, \"Should have next effect. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n          captureCommitPhaseError(nextEffect, error);\n\n          if (nextEffect !== null) {\n            nextEffect = nextEffect.nextEffect;\n          }\n        }\n      }\n\n      stopCommitSnapshotEffectsTimer();\n\n      if (enableProfilerTimer) {\n        recordCommitTime();\n      }\n\n      nextEffect = firstEffect;\n      startCommitHostEffectsTimer();\n\n      while (nextEffect !== null) {\n        var _didError = false;\n\n        var _error = void 0;\n\n        {\n          invokeGuardedCallback(null, commitAllHostEffects, null);\n\n          if (hasCaughtError()) {\n            _didError = true;\n            _error = clearCaughtError();\n          }\n        }\n\n        if (_didError) {\n          invariant(nextEffect !== null, \"Should have next effect. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n          captureCommitPhaseError(nextEffect, _error);\n\n          if (nextEffect !== null) {\n            nextEffect = nextEffect.nextEffect;\n          }\n        }\n      }\n\n      stopCommitHostEffectsTimer();\n      resetAfterCommit(root.containerInfo);\n      root.current = finishedWork;\n      nextEffect = firstEffect;\n      startCommitLifeCyclesTimer();\n\n      while (nextEffect !== null) {\n        var _didError2 = false;\n\n        var _error2 = void 0;\n\n        {\n          invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);\n\n          if (hasCaughtError()) {\n            _didError2 = true;\n            _error2 = clearCaughtError();\n          }\n        }\n\n        if (_didError2) {\n          invariant(nextEffect !== null, \"Should have next effect. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n          captureCommitPhaseError(nextEffect, _error2);\n\n          if (nextEffect !== null) {\n            nextEffect = nextEffect.nextEffect;\n          }\n        }\n      }\n\n      isCommitting$1 = false;\n      isWorking = false;\n      stopCommitLifeCyclesTimer();\n      stopCommitTimer();\n      onCommitRoot(finishedWork.stateNode);\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n      }\n\n      var updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n      var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n      var earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || childExpirationTimeAfterCommit !== NoWork && childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;\n\n      if (earliestRemainingTimeAfterCommit === NoWork) {\n        legacyErrorBoundariesThatAlreadyFailed = null;\n      }\n\n      onCommit(root, earliestRemainingTimeAfterCommit);\n\n      if (enableSchedulerTracking) {\n        tracking.__interactionsRef.current = prevInteractions;\n        var subscriber = void 0;\n\n        try {\n          subscriber = tracking.__subscriberRef.current;\n\n          if (subscriber !== null && root.memoizedInteractions.size > 0) {\n            var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);\n            subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n          }\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        } finally {\n          if (!suspenseDidTimeout) {\n            committedInteractions.forEach(function (interaction) {\n              interaction.__count--;\n\n              if (subscriber !== null && interaction.__count === 0) {\n                try {\n                  subscriber.onInteractionScheduledWorkCompleted(interaction);\n                } catch (error) {\n                  if (!hasUnhandledError) {\n                    hasUnhandledError = true;\n                    unhandledError = error;\n                  }\n                }\n              }\n            });\n          }\n        }\n      }\n    }\n\n    function resetChildExpirationTime(workInProgress, renderTime) {\n      if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n        return;\n      }\n\n      var newChildExpirationTime = NoWork;\n\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        var actualDuration = workInProgress.actualDuration;\n        var treeBaseDuration = workInProgress.selfBaseDuration;\n        var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;\n        var child = workInProgress.child;\n\n        while (child !== null) {\n          var childUpdateExpirationTime = child.expirationTime;\n          var childChildExpirationTime = child.childExpirationTime;\n\n          if (newChildExpirationTime === NoWork || childUpdateExpirationTime !== NoWork && childUpdateExpirationTime < newChildExpirationTime) {\n            newChildExpirationTime = childUpdateExpirationTime;\n          }\n\n          if (newChildExpirationTime === NoWork || childChildExpirationTime !== NoWork && childChildExpirationTime < newChildExpirationTime) {\n            newChildExpirationTime = childChildExpirationTime;\n          }\n\n          if (shouldBubbleActualDurations) {\n            actualDuration += child.actualDuration;\n          }\n\n          treeBaseDuration += child.treeBaseDuration;\n          child = child.sibling;\n        }\n\n        workInProgress.actualDuration = actualDuration;\n        workInProgress.treeBaseDuration = treeBaseDuration;\n      } else {\n        var _child = workInProgress.child;\n\n        while (_child !== null) {\n          var _childUpdateExpirationTime = _child.expirationTime;\n          var _childChildExpirationTime = _child.childExpirationTime;\n\n          if (newChildExpirationTime === NoWork || _childUpdateExpirationTime !== NoWork && _childUpdateExpirationTime < newChildExpirationTime) {\n            newChildExpirationTime = _childUpdateExpirationTime;\n          }\n\n          if (newChildExpirationTime === NoWork || _childChildExpirationTime !== NoWork && _childChildExpirationTime < newChildExpirationTime) {\n            newChildExpirationTime = _childChildExpirationTime;\n          }\n\n          _child = _child.sibling;\n        }\n      }\n\n      workInProgress.childExpirationTime = newChildExpirationTime;\n    }\n\n    function completeUnitOfWork(workInProgress) {\n      while (true) {\n        var current$$1 = workInProgress.alternate;\n        {\n          setCurrentFiber(workInProgress);\n        }\n        var returnFiber = workInProgress.return;\n        var siblingFiber = workInProgress.sibling;\n\n        if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n          if (enableProfilerTimer) {\n            if (workInProgress.mode & ProfileMode) {\n              startProfilerTimer(workInProgress);\n            }\n\n            nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n            if (workInProgress.mode & ProfileMode) {\n              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n            }\n          } else {\n            nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n          }\n\n          var next = nextUnitOfWork;\n          stopWorkTimer(workInProgress);\n          resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n          {\n            resetCurrentFiber();\n          }\n\n          if (next !== null) {\n            stopWorkTimer(workInProgress);\n\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            }\n\n            return next;\n          }\n\n          if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            }\n\n            var effectTag = workInProgress.effectTag;\n\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            return null;\n          }\n        } else {\n          if (workInProgress.mode & ProfileMode) {\n            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n          }\n\n          var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n\n          if (workInProgress.effectTag & DidCapture) {\n            stopFailedWorkTimer(workInProgress);\n          } else {\n            stopWorkTimer(workInProgress);\n          }\n\n          {\n            resetCurrentFiber();\n          }\n\n          if (_next !== null) {\n            stopWorkTimer(workInProgress);\n\n            if (true && ReactFiberInstrumentation_1.debugTool) {\n              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n            }\n\n            if (enableProfilerTimer) {\n              if (_next.mode & ProfileMode) {\n                var actualDuration = _next.actualDuration;\n                var child = _next.child;\n\n                while (child !== null) {\n                  actualDuration += child.actualDuration;\n                  child = child.sibling;\n                }\n\n                _next.actualDuration = actualDuration;\n              }\n            }\n\n            _next.effectTag &= HostEffectMask;\n            return _next;\n          }\n\n          if (returnFiber !== null) {\n            returnFiber.firstEffect = returnFiber.lastEffect = null;\n            returnFiber.effectTag |= Incomplete;\n          }\n\n          if (true && ReactFiberInstrumentation_1.debugTool) {\n            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            return null;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    function performUnitOfWork(workInProgress) {\n      var current$$1 = workInProgress.alternate;\n      startWorkTimer(workInProgress);\n      {\n        setCurrentFiber(workInProgress);\n      }\n\n      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n        stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n      }\n\n      var next = void 0;\n\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n\n        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n        if (workInProgress.mode & ProfileMode) {\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n        }\n      } else {\n        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n      }\n\n      {\n        resetCurrentFiber();\n\n        if (isReplayingFailedUnitOfWork) {\n          rethrowOriginalError();\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n      }\n\n      if (next === null) {\n        next = completeUnitOfWork(workInProgress);\n      }\n\n      ReactCurrentOwner$2.current = null;\n      return next;\n    }\n\n    function workLoop(isYieldy) {\n      if (!isYieldy) {\n        while (nextUnitOfWork !== null) {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      } else {\n        while (nextUnitOfWork !== null && !shouldYield()) {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n\n    function renderRoot(root, isYieldy, isExpired) {\n      invariant(!isWorking, \"renderRoot was called recursively. This error is likely caused \" + \"by a bug in React. Please file an issue.\");\n      isWorking = true;\n      ReactCurrentOwner$2.currentDispatcher = Dispatcher;\n      var expirationTime = root.nextExpirationTimeToWorkOn;\n      var prevInteractions = null;\n\n      if (enableSchedulerTracking) {\n        prevInteractions = tracking.__interactionsRef.current;\n        tracking.__interactionsRef.current = root.memoizedInteractions;\n      }\n\n      if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n        resetStack();\n        nextRoot = root;\n        nextRenderExpirationTime = expirationTime;\n        nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n        root.pendingCommitExpirationTime = NoWork;\n\n        if (enableSchedulerTracking) {\n          var interactions = new Set();\n          root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n            if (scheduledExpirationTime <= expirationTime) {\n              scheduledInteractions.forEach(function (interaction) {\n                return interactions.add(interaction);\n              });\n            }\n          });\n          root.memoizedInteractions = interactions;\n\n          if (interactions.size > 0) {\n            var subscriber = tracking.__subscriberRef.current;\n\n            if (subscriber !== null) {\n              var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n\n              try {\n                subscriber.onWorkStarted(interactions, threadID);\n              } catch (error) {\n                if (!hasUnhandledError) {\n                  hasUnhandledError = true;\n                  unhandledError = error;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      var didFatal = false;\n      startWorkLoopTimer(nextUnitOfWork);\n\n      do {\n        try {\n          workLoop(isYieldy);\n        } catch (thrownValue) {\n          if (nextUnitOfWork === null) {\n            didFatal = true;\n            onUncaughtError(thrownValue);\n          } else {\n            {\n              resetCurrentlyProcessingQueue();\n            }\n            var failedUnitOfWork = nextUnitOfWork;\n\n            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n              replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n            }\n\n            invariant(nextUnitOfWork !== null, \"Failed to replay rendering after an error. This \" + \"is likely caused by a bug in React. Please file an issue \" + \"with a reproducing case to help us find it.\");\n            var sourceFiber = nextUnitOfWork;\n            var returnFiber = sourceFiber.return;\n\n            if (returnFiber === null) {\n              didFatal = true;\n              onUncaughtError(thrownValue);\n            } else {\n              throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);\n              nextUnitOfWork = completeUnitOfWork(sourceFiber);\n              continue;\n            }\n          }\n        }\n\n        break;\n      } while (true);\n\n      if (enableSchedulerTracking) {\n        tracking.__interactionsRef.current = prevInteractions;\n      }\n\n      isWorking = false;\n      ReactCurrentOwner$2.currentDispatcher = null;\n      resetContextDependences();\n\n      if (didFatal) {\n        var _didCompleteRoot = false;\n        stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n        interruptedBy = null;\n        {\n          resetStackAfterFatalErrorInDev();\n        }\n        nextRoot = null;\n        onFatal(root);\n        return;\n      }\n\n      if (nextUnitOfWork !== null) {\n        var _didCompleteRoot2 = false;\n        stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n        interruptedBy = null;\n        onYield(root);\n        return;\n      }\n\n      var didCompleteRoot = true;\n      stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n      var rootWorkInProgress = root.current.alternate;\n      invariant(rootWorkInProgress !== null, \"Finished root should have a work-in-progress. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n      nextRoot = null;\n      interruptedBy = null;\n\n      if (nextRenderDidError) {\n        if (hasLowerPriorityWork(root, expirationTime)) {\n          markSuspendedPriorityLevel(root, expirationTime);\n          var suspendedExpirationTime = expirationTime;\n          var rootExpirationTime = root.expirationTime;\n          onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);\n          return;\n        } else if (!root.didError && !isExpired) {\n          root.didError = true;\n\n          var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;\n\n          var _rootExpirationTime = root.expirationTime = Sync;\n\n          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);\n          return;\n        }\n      }\n\n      if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {\n        var _suspendedExpirationTime2 = expirationTime;\n        markSuspendedPriorityLevel(root, _suspendedExpirationTime2);\n        var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);\n        var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n\n        if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n          nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n        }\n\n        var currentTimeMs = expirationTimeToMs(requestCurrentTime());\n        var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n        msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n        var _rootExpirationTime2 = root.expirationTime;\n        onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);\n        return;\n      }\n\n      onComplete(root, rootWorkInProgress, expirationTime);\n    }\n\n    function dispatch(sourceFiber, value, expirationTime) {\n      invariant(!isWorking || isCommitting$1, \"dispatch: Cannot dispatch during the render phase.\");\n      var fiber = sourceFiber.return;\n\n      while (fiber !== null) {\n        switch (fiber.tag) {\n          case ClassComponent:\n          case ClassComponentLazy:\n            var ctor = fiber.type;\n            var instance = fiber.stateNode;\n\n            if (typeof ctor.getDerivedStateFromCatch === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n              var errorInfo = createCapturedValue(value, sourceFiber);\n              var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n              enqueueUpdate(fiber, update);\n              scheduleWork(fiber, expirationTime);\n              return;\n            }\n\n            break;\n\n          case HostRoot:\n            {\n              var _errorInfo = createCapturedValue(value, sourceFiber);\n\n              var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n\n              enqueueUpdate(fiber, _update);\n              scheduleWork(fiber, expirationTime);\n              return;\n            }\n        }\n\n        fiber = fiber.return;\n      }\n\n      if (sourceFiber.tag === HostRoot) {\n        var rootFiber = sourceFiber;\n\n        var _errorInfo2 = createCapturedValue(value, rootFiber);\n\n        var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);\n\n        enqueueUpdate(rootFiber, _update2);\n        scheduleWork(rootFiber, expirationTime);\n      }\n    }\n\n    function captureCommitPhaseError(fiber, error) {\n      return dispatch(fiber, error, Sync);\n    }\n\n    function computeThreadID(expirationTime, interactionThreadID) {\n      return expirationTime * 1000 + interactionThreadID;\n    }\n\n    function computeExpirationForFiber(currentTime, fiber) {\n      var expirationTime = void 0;\n\n      if (expirationContext !== NoWork) {\n        expirationTime = expirationContext;\n      } else if (isWorking) {\n        if (isCommitting$1) {\n          expirationTime = Sync;\n        } else {\n          expirationTime = nextRenderExpirationTime;\n        }\n      } else {\n        if (fiber.mode & AsyncMode) {\n          if (isBatchingInteractiveUpdates) {\n            expirationTime = computeInteractiveExpiration(currentTime);\n          } else {\n            expirationTime = computeAsyncExpiration(currentTime);\n          }\n\n          if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n            expirationTime += 1;\n          }\n        } else {\n          expirationTime = Sync;\n        }\n      }\n\n      if (isBatchingInteractiveUpdates) {\n        if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPriorityPendingInteractiveExpirationTime) {\n          lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n        }\n      }\n\n      return expirationTime;\n    }\n\n    function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {\n      if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {\n        nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n      }\n    }\n\n    function renderDidError() {\n      nextRenderDidError = true;\n    }\n\n    function retrySuspendedRoot(root, fiber, suspendedTime) {\n      if (enableSuspense) {\n        var retryTime = void 0;\n\n        if (isPriorityLevelSuspended(root, suspendedTime)) {\n          retryTime = suspendedTime;\n          markPingedPriorityLevel(root, retryTime);\n        } else {\n          var currentTime = requestCurrentTime();\n          retryTime = computeExpirationForFiber(currentTime, fiber);\n          markPendingPriorityLevel(root, retryTime);\n        }\n\n        scheduleWorkToRoot(fiber, retryTime);\n        var rootExpirationTime = root.expirationTime;\n\n        if (rootExpirationTime !== NoWork) {\n          if (enableSchedulerTracking) {\n            var prevInteractions = tracking.__interactionsRef.current;\n            tracking.__interactionsRef.current = root.memoizedInteractions;\n            storeInteractionsForExpirationTime(root, rootExpirationTime, false);\n            requestWork(root, rootExpirationTime);\n            tracking.__interactionsRef.current = prevInteractions;\n          } else {\n            requestWork(root, rootExpirationTime);\n          }\n        }\n      }\n    }\n\n    function scheduleWorkToRoot(fiber, expirationTime) {\n      if (fiber.expirationTime === NoWork || fiber.expirationTime > expirationTime) {\n        fiber.expirationTime = expirationTime;\n      }\n\n      var alternate = fiber.alternate;\n\n      if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > expirationTime)) {\n        alternate.expirationTime = expirationTime;\n      }\n\n      var node = fiber.return;\n\n      if (node === null && fiber.tag === HostRoot) {\n        return fiber.stateNode;\n      }\n\n      while (node !== null) {\n        alternate = node.alternate;\n\n        if (node.childExpirationTime === NoWork || node.childExpirationTime > expirationTime) {\n          node.childExpirationTime = expirationTime;\n\n          if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n            alternate.childExpirationTime = expirationTime;\n          }\n        } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n          alternate.childExpirationTime = expirationTime;\n        }\n\n        if (node.return === null && node.tag === HostRoot) {\n          return node.stateNode;\n        }\n\n        node = node.return;\n      }\n\n      return null;\n    }\n\n    function storeInteractionsForExpirationTime(root, expirationTime, updateInteractionCounts) {\n      if (!enableSchedulerTracking) {\n        return;\n      }\n\n      var interactions = tracking.__interactionsRef.current;\n\n      if (interactions.size > 0) {\n        var pendingInteractions = root.pendingInteractionMap.get(expirationTime);\n\n        if (pendingInteractions != null) {\n          interactions.forEach(function (interaction) {\n            if (updateInteractionCounts && !pendingInteractions.has(interaction)) {\n              interaction.__count++;\n            }\n\n            pendingInteractions.add(interaction);\n          });\n        } else {\n          root.pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n          if (updateInteractionCounts) {\n            interactions.forEach(function (interaction) {\n              interaction.__count++;\n            });\n          }\n        }\n\n        var subscriber = tracking.__subscriberRef.current;\n\n        if (subscriber !== null) {\n          var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n          subscriber.onWorkScheduled(interactions, threadID);\n        }\n      }\n    }\n\n    function scheduleWork(fiber, expirationTime) {\n      recordScheduleUpdate();\n      {\n        if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n          var instance = fiber.stateNode;\n          warnAboutInvalidUpdates(instance);\n        }\n      }\n      var root = scheduleWorkToRoot(fiber, expirationTime);\n\n      if (root === null) {\n        if (true && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) {\n          warnAboutUpdateOnUnmounted(fiber);\n        }\n\n        return;\n      }\n\n      if (enableSchedulerTracking) {\n        storeInteractionsForExpirationTime(root, expirationTime, true);\n      }\n\n      if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n        interruptedBy = fiber;\n        resetStack();\n      }\n\n      markPendingPriorityLevel(root, expirationTime);\n\n      if (!isWorking || isCommitting$1 || nextRoot !== root) {\n        var rootExpirationTime = root.expirationTime;\n        requestWork(root, rootExpirationTime);\n      }\n\n      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n        nestedUpdateCount = 0;\n        invariant(false, \"Maximum update depth exceeded. This can happen when a \" + \"component repeatedly calls setState inside \" + \"componentWillUpdate or componentDidUpdate. React limits \" + \"the number of nested updates to prevent infinite loops.\");\n      }\n    }\n\n    var firstScheduledRoot = null;\n    var lastScheduledRoot = null;\n    var callbackExpirationTime = NoWork;\n    var callbackID = void 0;\n    var isRendering = false;\n    var nextFlushedRoot = null;\n    var nextFlushedExpirationTime = NoWork;\n    var lowestPriorityPendingInteractiveExpirationTime = NoWork;\n    var deadlineDidExpire = false;\n    var hasUnhandledError = false;\n    var unhandledError = null;\n    var deadline = null;\n    var isBatchingUpdates = false;\n    var isUnbatchingUpdates = false;\n    var isBatchingInteractiveUpdates = false;\n    var completedBatches = null;\n    var originalStartTimeMs = now();\n    var currentRendererTime = msToExpirationTime(originalStartTimeMs);\n    var currentSchedulerTime = currentRendererTime;\n    var NESTED_UPDATE_LIMIT = 50;\n    var nestedUpdateCount = 0;\n    var lastCommittedRootDuringThisBatch = null;\n    var timeHeuristicForUnitOfWork = 1;\n\n    function recomputeCurrentRendererTime() {\n      var currentTimeMs = now() - originalStartTimeMs;\n      currentRendererTime = msToExpirationTime(currentTimeMs);\n    }\n\n    function scheduleCallbackWithExpirationTime(root, expirationTime) {\n      if (callbackExpirationTime !== NoWork) {\n        if (expirationTime > callbackExpirationTime) {\n          return;\n        } else {\n          if (callbackID !== null) {\n            cancelDeferredCallback(callbackID);\n          }\n        }\n      } else {\n        startRequestCallbackTimer();\n      }\n\n      callbackExpirationTime = expirationTime;\n      var currentMs = now() - originalStartTimeMs;\n      var expirationTimeMs = expirationTimeToMs(expirationTime);\n      var timeout = expirationTimeMs - currentMs;\n      callbackID = scheduleDeferredCallback(performAsyncWork, {\n        timeout: timeout\n      });\n    }\n\n    function onFatal(root) {\n      root.finishedWork = null;\n    }\n\n    function onComplete(root, finishedWork, expirationTime) {\n      root.pendingCommitExpirationTime = expirationTime;\n      root.finishedWork = finishedWork;\n    }\n\n    function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {\n      root.expirationTime = rootExpirationTime;\n\n      if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {\n        root.pendingCommitExpirationTime = suspendedExpirationTime;\n        root.finishedWork = finishedWork;\n      } else if (msUntilTimeout > 0) {\n        root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);\n      }\n    }\n\n    function onYield(root) {\n      root.finishedWork = null;\n    }\n\n    function onTimeout(root, finishedWork, suspendedExpirationTime) {\n      if (enableSuspense) {\n        root.pendingCommitExpirationTime = suspendedExpirationTime;\n        root.finishedWork = finishedWork;\n        recomputeCurrentRendererTime();\n        currentSchedulerTime = currentRendererTime;\n\n        if (enableSchedulerTracking) {\n          suspenseDidTimeout = true;\n          flushRoot(root, suspendedExpirationTime);\n          suspenseDidTimeout = false;\n        } else {\n          flushRoot(root, suspendedExpirationTime);\n        }\n      }\n    }\n\n    function onCommit(root, expirationTime) {\n      root.expirationTime = expirationTime;\n      root.finishedWork = null;\n    }\n\n    function requestCurrentTime() {\n      if (isRendering) {\n        return currentSchedulerTime;\n      }\n\n      findHighestPriorityRoot();\n\n      if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {\n        recomputeCurrentRendererTime();\n        currentSchedulerTime = currentRendererTime;\n        return currentSchedulerTime;\n      }\n\n      return currentSchedulerTime;\n    }\n\n    function requestWork(root, expirationTime) {\n      addRootToSchedule(root, expirationTime);\n\n      if (isRendering) {\n        return;\n      }\n\n      if (isBatchingUpdates) {\n        if (isUnbatchingUpdates) {\n          nextFlushedRoot = root;\n          nextFlushedExpirationTime = Sync;\n          performWorkOnRoot(root, Sync, true);\n        }\n\n        return;\n      }\n\n      if (expirationTime === Sync) {\n        performSyncWork();\n      } else {\n        scheduleCallbackWithExpirationTime(root, expirationTime);\n      }\n    }\n\n    function addRootToSchedule(root, expirationTime) {\n      if (root.nextScheduledRoot === null) {\n        root.expirationTime = expirationTime;\n\n        if (lastScheduledRoot === null) {\n          firstScheduledRoot = lastScheduledRoot = root;\n          root.nextScheduledRoot = root;\n        } else {\n          lastScheduledRoot.nextScheduledRoot = root;\n          lastScheduledRoot = root;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n        }\n      } else {\n        var remainingExpirationTime = root.expirationTime;\n\n        if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n          root.expirationTime = expirationTime;\n        }\n      }\n    }\n\n    function findHighestPriorityRoot() {\n      var highestPriorityWork = NoWork;\n      var highestPriorityRoot = null;\n\n      if (lastScheduledRoot !== null) {\n        var previousScheduledRoot = lastScheduledRoot;\n        var root = firstScheduledRoot;\n\n        while (root !== null) {\n          var remainingExpirationTime = root.expirationTime;\n\n          if (remainingExpirationTime === NoWork) {\n            invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, \"Should have a previous and last root. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n\n            if (root === root.nextScheduledRoot) {\n              root.nextScheduledRoot = null;\n              firstScheduledRoot = lastScheduledRoot = null;\n              break;\n            } else if (root === firstScheduledRoot) {\n              var next = root.nextScheduledRoot;\n              firstScheduledRoot = next;\n              lastScheduledRoot.nextScheduledRoot = next;\n              root.nextScheduledRoot = null;\n            } else if (root === lastScheduledRoot) {\n              lastScheduledRoot = previousScheduledRoot;\n              lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n              root.nextScheduledRoot = null;\n              break;\n            } else {\n              previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n              root.nextScheduledRoot = null;\n            }\n\n            root = previousScheduledRoot.nextScheduledRoot;\n          } else {\n            if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n              highestPriorityWork = remainingExpirationTime;\n              highestPriorityRoot = root;\n            }\n\n            if (root === lastScheduledRoot) {\n              break;\n            }\n\n            if (highestPriorityWork === Sync) {\n              break;\n            }\n\n            previousScheduledRoot = root;\n            root = root.nextScheduledRoot;\n          }\n        }\n      }\n\n      nextFlushedRoot = highestPriorityRoot;\n      nextFlushedExpirationTime = highestPriorityWork;\n    }\n\n    function performAsyncWork(dl) {\n      if (dl.didTimeout) {\n        if (firstScheduledRoot !== null) {\n          recomputeCurrentRendererTime();\n          var root = firstScheduledRoot;\n\n          do {\n            didExpireAtExpirationTime(root, currentRendererTime);\n            root = root.nextScheduledRoot;\n          } while (root !== firstScheduledRoot);\n        }\n      }\n\n      performWork(NoWork, dl);\n    }\n\n    function performSyncWork() {\n      performWork(Sync, null);\n    }\n\n    function performWork(minExpirationTime, dl) {\n      deadline = dl;\n      findHighestPriorityRoot();\n\n      if (deadline !== null) {\n        recomputeCurrentRendererTime();\n        currentSchedulerTime = currentRendererTime;\n\n        if (enableUserTimingAPI) {\n          var didExpire = nextFlushedExpirationTime < currentRendererTime;\n          var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n          stopRequestCallbackTimer(didExpire, timeout);\n        }\n\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime >= nextFlushedExpirationTime);\n          findHighestPriorityRoot();\n          recomputeCurrentRendererTime();\n          currentSchedulerTime = currentRendererTime;\n        }\n      } else {\n        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n          findHighestPriorityRoot();\n        }\n      }\n\n      if (deadline !== null) {\n        callbackExpirationTime = NoWork;\n        callbackID = null;\n      }\n\n      if (nextFlushedExpirationTime !== NoWork) {\n        scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n\n      deadline = null;\n      deadlineDidExpire = false;\n      finishRendering();\n    }\n\n    function flushRoot(root, expirationTime) {\n      invariant(!isRendering, \"work.commit(): Cannot commit while already rendering. This likely \" + \"means you attempted to commit from inside a lifecycle method.\");\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = expirationTime;\n      performWorkOnRoot(root, expirationTime, true);\n      performSyncWork();\n    }\n\n    function finishRendering() {\n      nestedUpdateCount = 0;\n      lastCommittedRootDuringThisBatch = null;\n\n      if (completedBatches !== null) {\n        var batches = completedBatches;\n        completedBatches = null;\n\n        for (var i = 0; i < batches.length; i++) {\n          var batch = batches[i];\n\n          try {\n            batch._onComplete();\n          } catch (error) {\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n\n      if (hasUnhandledError) {\n        var error = unhandledError;\n        unhandledError = null;\n        hasUnhandledError = false;\n        throw error;\n      }\n    }\n\n    function performWorkOnRoot(root, expirationTime, isExpired) {\n      invariant(!isRendering, \"performWorkOnRoot was called recursively. This error is likely caused \" + \"by a bug in React. Please file an issue.\");\n      isRendering = true;\n\n      if (deadline === null || isExpired) {\n        var finishedWork = root.finishedWork;\n\n        if (finishedWork !== null) {\n          completeRoot(root, finishedWork, expirationTime);\n        } else {\n          root.finishedWork = null;\n          var timeoutHandle = root.timeoutHandle;\n\n          if (enableSuspense && timeoutHandle !== noTimeout) {\n            root.timeoutHandle = noTimeout;\n            cancelTimeout(timeoutHandle);\n          }\n\n          var isYieldy = false;\n          renderRoot(root, isYieldy, isExpired);\n          finishedWork = root.finishedWork;\n\n          if (finishedWork !== null) {\n            completeRoot(root, finishedWork, expirationTime);\n          }\n        }\n      } else {\n        var _finishedWork = root.finishedWork;\n\n        if (_finishedWork !== null) {\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          root.finishedWork = null;\n          var _timeoutHandle = root.timeoutHandle;\n\n          if (enableSuspense && _timeoutHandle !== noTimeout) {\n            root.timeoutHandle = noTimeout;\n            cancelTimeout(_timeoutHandle);\n          }\n\n          var _isYieldy = true;\n          renderRoot(root, _isYieldy, isExpired);\n          _finishedWork = root.finishedWork;\n\n          if (_finishedWork !== null) {\n            if (!shouldYield()) {\n              completeRoot(root, _finishedWork, expirationTime);\n            } else {\n              root.finishedWork = _finishedWork;\n            }\n          }\n        }\n      }\n\n      isRendering = false;\n    }\n\n    function completeRoot(root, finishedWork, expirationTime) {\n      var firstBatch = root.firstBatch;\n\n      if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n        if (completedBatches === null) {\n          completedBatches = [firstBatch];\n        } else {\n          completedBatches.push(firstBatch);\n        }\n\n        if (firstBatch._defer) {\n          root.finishedWork = finishedWork;\n          root.expirationTime = NoWork;\n          return;\n        }\n      }\n\n      root.finishedWork = null;\n\n      if (root === lastCommittedRootDuringThisBatch) {\n        nestedUpdateCount++;\n      } else {\n        lastCommittedRootDuringThisBatch = root;\n        nestedUpdateCount = 0;\n      }\n\n      commitRoot(root, finishedWork);\n    }\n\n    function shouldYield() {\n      if (deadlineDidExpire) {\n        return true;\n      }\n\n      if (deadline === null || deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n        return false;\n      }\n\n      deadlineDidExpire = true;\n      return true;\n    }\n\n    function onUncaughtError(error) {\n      invariant(nextFlushedRoot !== null, \"Should be working on a root. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n      nextFlushedRoot.expirationTime = NoWork;\n\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    }\n\n    function batchedUpdates$1(fn, a) {\n      var previousIsBatchingUpdates = isBatchingUpdates;\n      isBatchingUpdates = true;\n\n      try {\n        return fn(a);\n      } finally {\n        isBatchingUpdates = previousIsBatchingUpdates;\n\n        if (!isBatchingUpdates && !isRendering) {\n          performSyncWork();\n        }\n      }\n    }\n\n    function interactiveUpdates$1(fn, a, b) {\n      if (isBatchingInteractiveUpdates) {\n        return fn(a, b);\n      }\n\n      if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n        performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n        lowestPriorityPendingInteractiveExpirationTime = NoWork;\n      }\n\n      var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n      var previousIsBatchingUpdates = isBatchingUpdates;\n      isBatchingInteractiveUpdates = true;\n      isBatchingUpdates = true;\n\n      try {\n        return fn(a, b);\n      } finally {\n        isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n        isBatchingUpdates = previousIsBatchingUpdates;\n\n        if (!isBatchingUpdates && !isRendering) {\n          performSyncWork();\n        }\n      }\n    }\n\n    function flushInteractiveUpdates$1() {\n      if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n        performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n        lowestPriorityPendingInteractiveExpirationTime = NoWork;\n      }\n    }\n\n    var didWarnAboutNestedUpdates = void 0;\n    {\n      didWarnAboutNestedUpdates = false;\n    }\n\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyContextObject;\n      }\n\n      var fiber = get$1(parentComponent);\n      var parentContext = findCurrentUnmaskedContext(fiber);\n\n      if (fiber.tag === ClassComponent) {\n        var Component = fiber.type;\n\n        if (isContextProvider(Component)) {\n          return processChildContext(fiber, Component, parentContext);\n        }\n      } else if (fiber.tag === ClassComponentLazy) {\n        var _Component = getResultFromResolvedThenable(fiber.type);\n\n        if (isContextProvider(_Component)) {\n          return processChildContext(fiber, _Component, parentContext);\n        }\n      }\n\n      return parentContext;\n    }\n\n    function scheduleRootUpdate(current$$1, element, expirationTime, callback) {\n      {\n        if (phase === \"render\" && current !== null && !didWarnAboutNestedUpdates) {\n          didWarnAboutNestedUpdates = true;\n          warningWithoutStack$1(false, \"Render methods should be a pure function of props and state; \" + \"triggering nested component updates from render is not allowed. \" + \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" + \"Check the render method of %s.\", getComponentName(current.type) || \"Unknown\");\n        }\n      }\n      var update = createUpdate(expirationTime);\n      update.payload = {\n        element: element\n      };\n      callback = callback === undefined ? null : callback;\n\n      if (callback !== null) {\n        !(typeof callback === \"function\") ? warningWithoutStack$1(false, \"render(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callback) : void 0;\n        update.callback = callback;\n      }\n\n      enqueueUpdate(current$$1, update);\n      scheduleWork(current$$1, expirationTime);\n      return expirationTime;\n    }\n\n    function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {\n      var current$$1 = container.current;\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current$$1.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n      var context = getContextForSubtree(parentComponent);\n\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      return scheduleRootUpdate(current$$1, element, expirationTime, callback);\n    }\n\n    function findHostInstance$1(component) {\n      var fiber = get$1(component);\n\n      if (fiber === undefined) {\n        if (typeof component.render === \"function\") {\n          invariant(false, \"Unable to find node on an unmounted component.\");\n        } else {\n          invariant(false, \"Argument appears to not be a ReactComponent. Keys: %s\", Object.keys(component));\n        }\n      }\n\n      var hostFiber = findCurrentHostFiber(fiber);\n\n      if (hostFiber === null) {\n        return null;\n      }\n\n      return hostFiber.stateNode;\n    }\n\n    function createContainer(containerInfo, isAsync, hydrate) {\n      return createFiberRoot(containerInfo, isAsync, hydrate);\n    }\n\n    function updateContainer(element, container, parentComponent, callback) {\n      var current$$1 = container.current;\n      var currentTime = requestCurrentTime();\n      var expirationTime = computeExpirationForFiber(currentTime, current$$1);\n      return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);\n    }\n\n    function getPublicRootInstance(container) {\n      var containerFiber = container.current;\n\n      if (!containerFiber.child) {\n        return null;\n      }\n\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n\n        default:\n          return containerFiber.child.stateNode;\n      }\n    }\n\n    function injectIntoDevTools(devToolsConfig) {\n      var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n      return injectInternals(_extends({}, devToolsConfig, {\n        findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        },\n        findFiberByHostInstance: function findFiberByHostInstance(instance) {\n          if (!_findFiberByHostInstance) {\n            return null;\n          }\n\n          return _findFiberByHostInstance(instance);\n        }\n      }));\n    }\n\n    function _createPortal(children, containerInfo, implementation) {\n      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      return {\n        $$typeof: REACT_PORTAL_TYPE,\n        key: key == null ? null : \"\" + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    }\n\n    var ReactVersion = \"16.5.0\";\n\n    var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {\n      var NativeMethodsMixin = {\n        measure: function measure(callback) {\n          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n        },\n        measureInWindow: function measureInWindow(callback) {\n          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n        },\n        measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {\n          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));\n        },\n        setNativeProps: function setNativeProps(nativeProps) {\n          var maybeInstance = void 0;\n\n          try {\n            maybeInstance = findHostInstance(this);\n          } catch (error) {}\n\n          if (maybeInstance == null) {\n            return;\n          }\n\n          var viewConfig = maybeInstance.viewConfig;\n          {\n            warnForStyleProps(nativeProps, viewConfig.validAttributes);\n          }\n          var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n          if (updatePayload != null) {\n            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);\n          }\n        },\n        focus: function focus() {\n          TextInputState.focusTextInput(findNodeHandle(this));\n        },\n        blur: function blur() {\n          TextInputState.blurTextInput(findNodeHandle(this));\n        }\n      };\n      {\n        var NativeMethodsMixin_DEV = NativeMethodsMixin;\n        invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, \"Do not override existing functions.\");\n\n        NativeMethodsMixin_DEV.componentWillMount = function () {\n          throwOnStylesProp(this, this.props);\n        };\n\n        NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {\n          throwOnStylesProp(this, newProps);\n        };\n\n        NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {\n          throwOnStylesProp(this, this.props);\n        };\n\n        NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {\n          throwOnStylesProp(this, newProps);\n        };\n\n        NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n        NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n      }\n      return NativeMethodsMixin;\n    };\n\n    function _classCallCheck$1(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n    }\n\n    function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n    }\n\n    var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {\n      var ReactNativeComponent = function (_React$Component) {\n        _inherits(ReactNativeComponent, _React$Component);\n\n        function ReactNativeComponent() {\n          _classCallCheck$1(this, ReactNativeComponent);\n\n          return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n        }\n\n        ReactNativeComponent.prototype.blur = function blur() {\n          TextInputState.blurTextInput(findNodeHandle(this));\n        };\n\n        ReactNativeComponent.prototype.focus = function focus() {\n          TextInputState.focusTextInput(findNodeHandle(this));\n        };\n\n        ReactNativeComponent.prototype.measure = function measure(callback) {\n          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n        };\n\n        ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {\n          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));\n        };\n\n        ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {\n          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));\n        };\n\n        ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {\n          var maybeInstance = void 0;\n\n          try {\n            maybeInstance = findHostInstance(this);\n          } catch (error) {}\n\n          if (maybeInstance == null) {\n            return;\n          }\n\n          var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n          var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n          if (updatePayload != null) {\n            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);\n          }\n        };\n\n        return ReactNativeComponent;\n      }(React.Component);\n\n      return ReactNativeComponent;\n    };\n\n    var emptyObject$2 = {};\n    {\n      Object.freeze(emptyObject$2);\n    }\n    var getInspectorDataForViewTag = void 0;\n    {\n      var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {\n        if (instance) {\n          hierarchy.unshift(instance);\n          traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n        }\n      };\n\n      var getOwnerHierarchy = function getOwnerHierarchy(instance) {\n        var hierarchy = [];\n        traverseOwnerTreeUp(hierarchy, instance);\n        return hierarchy;\n      };\n\n      var lastNonHostInstance = function lastNonHostInstance(hierarchy) {\n        for (var i = hierarchy.length - 1; i > 1; i--) {\n          var instance = hierarchy[i];\n\n          if (instance.tag !== HostComponent) {\n            return instance;\n          }\n        }\n\n        return hierarchy[0];\n      };\n\n      var getHostProps = function getHostProps(fiber) {\n        var host = findCurrentHostFiber(fiber);\n\n        if (host) {\n          return host.memoizedProps || emptyObject$2;\n        }\n\n        return emptyObject$2;\n      };\n\n      var getHostNode = function getHostNode(fiber, findNodeHandle) {\n        var hostNode = void 0;\n\n        while (fiber) {\n          if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n            hostNode = findNodeHandle(fiber.stateNode);\n          }\n\n          if (hostNode) {\n            return hostNode;\n          }\n\n          fiber = fiber.child;\n        }\n\n        return null;\n      };\n\n      var createHierarchy = function createHierarchy(fiberHierarchy) {\n        return fiberHierarchy.map(function (fiber) {\n          return {\n            name: getComponentName(fiber.type),\n            getInspectorData: function getInspectorData(findNodeHandle) {\n              return {\n                measure: function measure(callback) {\n                  return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);\n                },\n                props: getHostProps(fiber),\n                source: fiber._debugSource\n              };\n            }\n          };\n        });\n      };\n\n      getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {\n        var closestInstance = getInstanceFromTag(viewTag);\n\n        if (!closestInstance) {\n          return {\n            hierarchy: [],\n            props: emptyObject$2,\n            selection: null,\n            source: null\n          };\n        }\n\n        var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n        var fiberHierarchy = getOwnerHierarchy(fiber);\n        var instance = lastNonHostInstance(fiberHierarchy);\n        var hierarchy = createHierarchy(fiberHierarchy);\n        var props = getHostProps(instance);\n        var source = instance._debugSource;\n        var selection = fiberHierarchy.indexOf(instance);\n        return {\n          hierarchy: hierarchy,\n          props: props,\n          selection: selection,\n          source: source\n        };\n      };\n    }\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var findHostInstance = findHostInstance$1;\n\n    function findNodeHandle(componentOrHandle) {\n      {\n        var owner = ReactCurrentOwner.current;\n\n        if (owner !== null && owner.stateNode !== null) {\n          !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, \"%s is accessing findNodeHandle inside its render(). \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentName(owner.type) || \"A component\") : void 0;\n          owner.stateNode._warnedAboutRefsInRender = true;\n        }\n      }\n\n      if (componentOrHandle == null) {\n        return null;\n      }\n\n      if (typeof componentOrHandle === \"number\") {\n        return componentOrHandle;\n      }\n\n      if (componentOrHandle._nativeTag) {\n        return componentOrHandle._nativeTag;\n      }\n\n      if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {\n        return componentOrHandle.canonical._nativeTag;\n      }\n\n      var hostInstance = findHostInstance(componentOrHandle);\n\n      if (hostInstance == null) {\n        return hostInstance;\n      }\n\n      if (hostInstance.canonical) {\n        return hostInstance.canonical._nativeTag;\n      }\n\n      return hostInstance._nativeTag;\n    }\n\n    setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);\n\n    function computeComponentStackForErrorReporting(reactTag) {\n      var fiber = getInstanceFromTag(reactTag);\n\n      if (!fiber) {\n        return \"\";\n      }\n\n      return getStackByFiberInDevAndProd(fiber);\n    }\n\n    var roots = new Map();\n    var ReactNativeRenderer = {\n      NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),\n      findNodeHandle: findNodeHandle,\n      render: function render(element, containerTag, callback) {\n        var root = roots.get(containerTag);\n\n        if (!root) {\n          root = createContainer(containerTag, false, false);\n          roots.set(containerTag, root);\n        }\n\n        updateContainer(element, root, null, callback);\n        return getPublicRootInstance(root);\n      },\n      unmountComponentAtNode: function unmountComponentAtNode(containerTag) {\n        var root = roots.get(containerTag);\n\n        if (root) {\n          updateContainer(null, root, null, function () {\n            roots.delete(containerTag);\n          });\n        }\n      },\n      unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {\n        ReactNativeRenderer.unmountComponentAtNode(containerTag);\n        UIManager.removeRootView(containerTag);\n      },\n      createPortal: function createPortal(children, containerTag) {\n        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        return _createPortal(children, containerTag, null, key);\n      },\n      unstable_batchedUpdates: batchedUpdates,\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),\n        computeComponentStackForErrorReporting: computeComponentStackForErrorReporting\n      }\n    };\n    injectIntoDevTools({\n      findFiberByHostInstance: getInstanceFromTag,\n      getInspectorDataForViewTag: getInspectorDataForViewTag,\n      bundleType: 1,\n      version: ReactVersion,\n      rendererPackageName: \"react-native-renderer\"\n    });\n    var ReactNativeRenderer$2 = Object.freeze({\n      default: ReactNativeRenderer\n    });\n    var ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;\n    var reactNativeRenderer = ReactNativeRenderer$3.default || ReactNativeRenderer$3;\n    module.exports = reactNativeRenderer;\n  })();\n}","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js"],"names":["__DEV__","require","ReactNativeViewConfigRegistry","UIManager","RCTEventEmitter","React","deepFreezeAndThrowOnMutationInDev","deepDiffer","flattenStyle","TextInputState","checkPropTypes","tracking","ExceptionsManager","validateFormat","format","undefined","Error","invariant","condition","a","b","c","d","e","f","error","args","argIndex","replace","name","framesToPop","invokeGuardedCallbackImpl","func","context","funcArgs","Array","prototype","slice","call","arguments","apply","onError","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","windowEvent","event","callCallback","removeEventListener","evtType","hasOwnProperty","didSetError","isCrossOriginError","handleWindowError","colno","lineno","defaultPrevented","_suppressLogging","inner","addEventListener","initEvent","invokeGuardedCallbackImpl$1","hasError","caughtError","hasRethrowError","rethrowError","reporter","invokeGuardedCallback","invokeGuardedCallbackAndCatchFirstError","clearCaughtError","rethrowCaughtError","hasCaughtError","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","warningWithoutStack","_len","length","_key","console","_console","stringArgs","map","item","concat","message","x","warningWithoutStack$1","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","setComponentTree","getFiberCurrentPropsFromNodeImpl","getInstanceFromNodeImpl","getNodeFromInstanceImpl","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","injection","getListener","stateNode","topLevelType","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","runEventsInBatch","processingEventQueue","runExtractedEventsInBatch","FunctionalComponent","FunctionalComponentLazy","ClassComponent","ClassComponentLazy","IndeterminateComponent","HostRoot","HostPortal","HostComponent","HostText","Fragment","Mode","ContextConsumer","ContextProvider","ForwardRef","ForwardRefLazy","Profiler","PlaceholderComponent","getParent","return","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","EVENT_POOL_SIZE","EventInterface","target","eventPhase","bubbles","cancelable","timeStamp","Date","now","isTrusted","functionThatReturnsTrue","functionThatReturnsFalse","SyntheticEvent","preventDefault","stopPropagation","isDefaultPrevented","Interface","propName","normalize","returnValue","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","extend","Super","E","Class","addEventPoolingTo","getVal","isFunction","configurable","set","get","get$$1","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","ResponderSyntheticEvent","touchHistory","TOP_TOUCH_START","TOP_TOUCH_MOVE","TOP_TOUCH_END","TOP_TOUCH_CANCEL","TOP_SCROLL","TOP_SELECTION_CHANGE","isStartish","isMoveish","isEndish","startDependencies","moveDependencies","endDependencies","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","eventTypes$1","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","injectGlobalResponderHandler","customBubblingEventTypes$1","customBubblingEventTypes","customDirectEventTypes$1","customDirectEventTypes","eventTypes$2","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","ReactNativeEventPluginOrder","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","canonical","getFiberCurrentPropsFromNode$1","updateFiberProps","restoreImpl","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","needsStateRestore","restoreStateIfNeeded","queuedTargets","_batchedUpdatesImpl","bookkeeping","_flushInteractiveUpdatesImpl","isBatching","batchedUpdates","controlledComponentsHavePendingUpdates","setBatchingImplementation","batchedUpdatesImpl","interactiveUpdatesImpl","flushInteractiveUpdatesImpl","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","freeze","registrationNames","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","register","get$1","key","_reactInternalFiber","value","ReactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","hasSymbol","Symbol","for","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_PLACEHOLDER_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","Pending","Resolved","Rejected","getResultFromResolvedThenable","thenable","_reactResult","refineResolvedThenable","_reactStatus","getComponentName","displayName","$$typeof","renderFn","render","functionName","then","resolvedThenable","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","DidCapture","Ref","Snapshot","LifecycleEffectMask","HostEffectMask","Incomplete","ShouldCapture","ReactCurrentOwner$1","ReactCurrentOwner","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","fiber","node","effectTag","isFiberMounted","isMounted","component","owner","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","emptyObject","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","restoreDeletedValuesInNestedArray","updatePayload","validAttributes","obj","propKey","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","_nextValue","_propKey","create","mountSafeCallback_NOT_REALLY_SAFE","callback","__isMounted","throwOnStylesProp","styles","_owner","msg","warnForStyleProps","style","_classCallCheck","Constructor","TypeError","ReactNativeFiberHostComponent","viewConfig","_children","blur","blurTextInput","focus","focusTextInput","measure","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","updateView","uiViewClassName","hasNativePerformanceNow","performance","now$1","scheduledCallback","frameDeadline","frameDeadlineObject","timeRemaining","didTimeout","setTimeoutCallback","scheduleDeferredCallback$1","options","timeoutId","setTimeout","cancelDeferredCallback$1","callbackID","clearTimeout","shim","supportsPersistence","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","replaceContainerChildren","shim$1","supportsHydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","UPDATE_SIGNAL","nextReactTag","allocateTag","recursivelyUncacheFiberNode","appendInitialChild","parentInstance","createInstance","rootContainerInstance","hostContext","internalInstanceHandle","isInAParentText","createView","createTextInstance","text","finalizeInitialChildren","nativeTags","setChildren","getRootHostContext","getChildHostContext","parentHostContext","prevIsInAParentText","getPublicInstance","prepareForCommit","containerInfo","prepareUpdate","oldProps","newProps","resetAfterCommit","isPrimaryRenderer","scheduleDeferredCallback","cancelDeferredCallback","scheduleTimeout","cancelTimeout","noTimeout","shouldDeprioritizeSubtree","shouldSetTextContent","supportsMutation","appendChild","childTag","children","splice","manageChildren","appendChildToContainer","commitTextUpdate","textInstance","oldText","newText","commitUpdate","updatePayloadTODO","insertBefore","beforeChild","beforeChildIndex","_beforeChildIndex","insertInContainerBefore","removeChild","removeChildFromContainer","resetTextContent","BEFORE_SLASH_RE","describeComponentFrame","source","ownerName","sourceInfo","fileName","test","match","pathBeforeSlash","folderName","lineNumber","ReactDebugCurrentFrame","describeFiber","_debugOwner","_debugSource","getStackByFiberInDevAndProd","workInProgress","info","getCurrentFiberOwnerNameInDevOrNull","getCurrentFiberStackInDev","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","lifeCyclePhase","debugRenderPhaseSideEffects","debugRenderPhaseSideEffectsForStrictMode","enableGetDerivedStateFromCatch","enableSuspense","enableUserTimingAPI","replayFailedUnitOfWorkWithInvokeGuardedCallback","warnAboutDeprecatedLifecycles","warnAboutLegacyContextAPI","enableProfilerTimer","enableSchedulerTracking","reactEmoji","warningEmoji","supportsUserTiming","mark","clearMarks","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","componentName","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","expirationTime","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","didCompleteRoot","startCommitTimer","clear","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","count","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","valueStack","fiberStack","createCursor","defaultValue","cursor","checkThatStackIsEmpty","resetStackAfterFatalErrorInDev","warnedAboutMissingGetChildContext","emptyContextObject","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","Component","didPushOwnContextIfProvider","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","childContextTypes","popContext","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","_Component","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","isDevToolsPresent","__REACT_DEVTOOLS_GLOBAL_HOOK__","injectInternals","internals","hook","isDisabled","supportsFiber","rendererID","inject","root","onCommitRoot","onCommitUnmount","maxSigned31BitInt","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","LOW_PRIORITY_EXPIRATION","LOW_PRIORITY_BATCH_SIZE","computeAsyncExpiration","HIGH_PRIORITY_EXPIRATION","HIGH_PRIORITY_BATCH_SIZE","computeInteractiveExpiration","NoContext","AsyncMode","StrictMode","ProfileMode","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","testMap","Map","testSet","debugCounter","FiberNode","pendingProps","mode","ref","memoizedProps","updateQueue","memoizedState","firstContextDependency","nextEffect","firstEffect","lastEffect","childExpirationTime","actualDuration","actualStartTime","selfBaseDuration","treeBaseDuration","createFiber","shouldConstruct","isReactComponent","resolveLazyComponentTag","createWorkInProgress","createHostRootFiber","isAsync","createFiberFromElement","element","fiberTag","getTag","createFiberFromFragment","createFiberFromProfiler","keys","_source","elements","id","onRender","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromPortal","portal","pendingChildren","implementation","assignFiberPropertiesInDEV","createFiberRoot","hydrate","uninitializedFiber","earliestPendingTime","latestPendingTime","earliestSuspendedTime","latestSuspendedTime","latestPingedTime","pendingCommitExpirationTime","finishedWork","timeoutHandle","pendingContext","nextExpirationTimeToWorkOn","firstBatch","nextScheduledRoot","interactionThreadID","unstable_getThreadID","memoizedInteractions","pendingInteractionMap","lowPriorityWarning","printWarning","_len2","_key2","lowPriorityWarning$1","ReactStrictModeWarnings","discardPendingWarnings","flushPendingDeprecationWarnings","flushPendingUnsafeLifecycleWarnings","recordDeprecationWarnings","recordUnsafeLifecycleWarnings","recordLegacyContextWarning","flushLegacyContextWarning","LIFECYCLE_SUGGESTIONS","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","pendingComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUnsafeLifecycleWarnings","pendingLegacyContextWarning","didWarnAboutDeprecatedLifecycles","didWarnAboutUnsafeLifecycles","didWarnAboutLegacyContext","setToSortedString","array","sort","join","lifecycleWarningsMap","strictRoot","lifecyclesWarningMesages","lifecycle","lifecycleWarnings","componentNames","formatted","suggestion","sortedComponentNames","strictRootComponentStack","findStrictRoot","maybeStrictRoot","uniqueNames","sortedNames","_uniqueNames","_sortedNames","_uniqueNames2","_sortedNames2","componentWillMount","__suppressDeprecationWarning","componentWillReceiveProps","componentWillUpdate","warningsForRoot","unsafeLifecycles","fiberArray","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","markPendingPriorityLevel","findNextExpirationTimeToWorkOn","markCommittedPriorityLevels","earliestRemainingTime","hasLowerPriorityWork","erroredExpirationTime","isPriorityLevelSuspended","markSuspendedPriorityLevel","suspendedTime","clearPing","markPingedPriorityLevel","pingedTime","completedTime","findEarliestOutstandingPriorityLevel","renderExpirationTime","earliestExpirationTime","didExpireAtExpirationTime","completedExpirationTime","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","createUpdateQueue","baseState","queue","firstUpdate","lastUpdate","firstCapturedUpdate","lastCapturedUpdate","firstCapturedEffect","lastCapturedEffect","cloneUpdateQueue","currentQueue","createUpdate","payload","appendUpdateToQueue","update","enqueueUpdate","queue1","queue2","enqueueCapturedUpdate","workInProgressQueue","ensureWorkInProgressQueueIsAClone","getStateFromUpdate","prevState","_payload","_payload2","partialState","processUpdateQueue","newBaseState","newFirstUpdate","newExpirationTime","resultState","updateExpirationTime","_callback","newFirstCapturedUpdate","_updateExpirationTime","_callback2","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedQueue","commitUpdateEffects","effect","_callback3","createCapturedValue","stack","getStackAddendum","warning$1","valueCursor","rendererSigil","currentlyRenderingFiber","lastContextDependency","lastContextWithAllBitsObserved","resetContextDependences","pushProvider","providerFiber","_context","_currentValue","_currentRenderer","_currentValue2","_currentRenderer2","popProvider","currentValue","calculateChangedBits","newValue","oldValue","changedBits","_calculateChangedBits","propagateContextChange","nextFiber","dependency","observedBits","prepareToReadContext","readContext","resolvedObservedBits","contextItem","NO_CONTEXT","contextStackCursor$1","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","getRootHostContainer","rootInstance","pushHostContainer","nextRootInstance","nextRootContext","popHostContainer","getHostContext","pushHostContext","nextContext","popHostContext","commitTime","profilerStartTime","getCommitTime","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunning","stopProfilerTimerIfRunningAndRecordDelta","overrideBaseTime","elapsedTime","is","y","shallowEqual","objA","objB","keysA","keysB","fakeInternalInstance","emptyRefsObject","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnOnInvalidCallback","callerName","enumerable","applyDerivedStateFromProps","ctor","getDerivedStateFromProps","classComponentUpdater","enqueueSetState","requestCurrentTime","computeExpirationForFiber","scheduleWork","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldState","newState","nextLegacyContext","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","noUnsafeComponentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","noInstanceGetDerivedStateFromProps","noInstanceGetDerivedStateFromCatch","getDerivedStateFromCatch","noStaticGetSnapshotBeforeUpdate","_state","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","isContextConsumer","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","_componentName","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","componentDidMount","resumeMountClassInstance","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefInStrictMode","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","returnFiber","current$$1","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","newChild","addendum","toString","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","last","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","delete","reconcileChildrenIterator","newChildrenIterable","iteratorFn","toStringTag","entries","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created4","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","hydrationParentFiber","nextHydratableInstance","isHydrating","enterHydrationState","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","tryToClaimNextHydratableInstance","firstAttemptedInstance","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popToNextHostParent","popHydrationState","resetHydrationState","readLazyComponentType","status","resolvedValue","defaultExport","default","ReactCurrentOwner$3","didWarnAboutBadClass","didWarnAboutGetDerivedStateOnFunctionalComponent","didWarnAboutStatelessRefs","reconcileChildren","nextChildren","updateForwardRef","currentRef","bailoutOnAlreadyFinishedWork","memoizeProps","updateMode","updateProfiler","markRef","updateFunctionalComponent","updateClassComponent","hasContext","finishClassComponent","didCaptureError","memoizeState","pushHostRootContext","updateHostRoot","prevChildren","nextState","updateHostComponent","isDirectTextChild","updateHostText","resolveDefaultProps","baseProps","mountIndeterminateComponent","resolvedTag","resolvedProps","warningKey","debugSource","updatePlaceholderComponent","alreadyCaptured","nextDidTimeout","fallback","updatePortalComponent","updateContextProvider","providerType","providerPropTypes","updateContextConsumer","unstable_observedBits","beginWork","_Component3","_Component4","_unresolvedProps","_thenable2","_Component5","_unresolvedProps2","_Component6","_unresolvedProps3","_thenable3","_Component7","_unresolvedProps4","_child2","_thenable","_Component2","unresolvedProps","markUpdate","markRef$1","appendAllChildren","updateHostContainer","updateHostComponent$1","updateHostText$1","currentHostContext","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","completeWork","fiberRoot","wasHydrated","_rootContainerInstance","_currentHostContext","_wasHydrated","showErrorDialog","capturedError","componentStack","errorToHandle","summary","handleException","logCapturedError","logError","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","emptyObject$1","didWarnAboutUndefinedSnapshotBeforeUpdate","boundary","errorInfo","errorBoundary","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","captureCommitPhaseError","safelyDetachRef","refError","commitBeforeMutationLifeCycles","snapshot","didWarnSet","__reactInternalSnapshotBeforeUpdate","commitLifeCycles","finishedRoot","committedExpirationTime","_updateQueue","_instance","_instance2","timedOutAt","commitAttachRef","instanceToUse","commitDetachRef","commitUnmount","unmountHostComponents","emptyPortalContainer","commitNestedUnmounts","detachFiber","emptyChildSet","commitContainer","_pendingChildren","getHostParentFiber","isHostParent","getHostSibling","siblings","commitPlacement","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","commitDeletion","commitWork","commitResetTextContent","NoopComponent","createRootErrorUpdate","onUncaughtError","createClassErrorUpdate","componentDidCatch","markLegacyErrorBoundaryAsFailed","throwException","sourceFiber","_workInProgress","earliestTimeoutMs","startTimeMs","timeoutPropMs","delayMs","pingTime","onResolveOrReject","retrySuspendedRoot","bind","absoluteTimeoutMs","earliestExpirationTimeMs","renderDidSuspend","renderDidError","_errorInfo","isAlreadyFailedLegacyErrorBoundary","_update","unwindWork","_effectTag","_effectTag2","_effectTag3","unwindInterruptedWork","interruptedWork","_childContextTypes","Dispatcher","ReactCurrentOwner$2","didWarnAboutStateTransition","didWarnSetStateChildContext","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","__interactionsRef","didWarnStateUpdateForUnmountedComponent","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","nextLatestAbsoluteTimeoutMs","nextRenderDidError","isCommitting$1","legacyErrorBoundariesThatAlreadyFailed","suspenseDidTimeout","stashedWorkInProgressProperties","replayUnitOfWork","isReplayingFailedUnitOfWork","originalReplayError","rethrowOriginalError","failedUnitOfWork","thrownValue","isYieldy","workLoop","replayError","resetStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitBeforeMutationLifecycles","commitAllLifeCycles","commitRoot","updateExpirationTimeBeforeCommit","childExpirationTimeBeforeCommit","earliestRemainingTimeBeforeCommit","prevInteractions","committedInteractions","scheduledInteractions","scheduledExpirationTime","_didError","_error","_didError2","_error2","onCommitWork","updateExpirationTimeAfterCommit","childExpirationTimeAfterCommit","earliestRemainingTimeAfterCommit","onCommit","subscriber","__subscriberRef","size","threadID","computeThreadID","onWorkStopped","hasUnhandledError","unhandledError","interaction","__count","onInteractionScheduledWorkCompleted","resetChildExpirationTime","renderTime","newChildExpirationTime","shouldBubbleActualDurations","childUpdateExpirationTime","childChildExpirationTime","_childUpdateExpirationTime","_childChildExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","_next","performUnitOfWork","onBeginWork","shouldYield","renderRoot","isExpired","currentDispatcher","interactions","onWorkStarted","didFatal","_didCompleteRoot","onFatal","_didCompleteRoot2","onYield","rootWorkInProgress","suspendedExpirationTime","rootExpirationTime","onSuspend","_suspendedExpirationTime","_rootExpirationTime","_suspendedExpirationTime2","currentTimeMs","msUntilTimeout","_rootExpirationTime2","onComplete","dispatch","rootFiber","_errorInfo2","_update2","isBatchingInteractiveUpdates","lowestPriorityPendingInteractiveExpirationTime","retryTime","scheduleWorkToRoot","storeInteractionsForExpirationTime","requestWork","updateInteractionCounts","pendingInteractions","onWorkScheduled","nestedUpdateCount","NESTED_UPDATE_LIMIT","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","originalStartTimeMs","currentRendererTime","currentSchedulerTime","lastCommittedRootDuringThisBatch","timeHeuristicForUnitOfWork","recomputeCurrentRendererTime","scheduleCallbackWithExpirationTime","currentMs","expirationTimeMs","timeout","performAsyncWork","onTimeout","flushRoot","findHighestPriorityRoot","addRootToSchedule","performWorkOnRoot","performSyncWork","remainingExpirationTime","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","dl","performWork","minExpirationTime","finishRendering","batches","batch","_onComplete","completeRoot","_finishedWork","_timeoutHandle","_isYieldy","_expirationTime","_defer","batchedUpdates$1","previousIsBatchingUpdates","interactiveUpdates$1","previousIsBatchingInteractiveUpdates","flushInteractiveUpdates$1","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","findHostInstance$1","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","createPortal","ReactVersion","NativeMethodsMixin","findNodeHandle","findHostInstance","maybeInstance","NativeMethodsMixin_DEV","_classCallCheck$1","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","emptyObject$2","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","componentOrHandle","hostInstance","computeComponentStackForErrorReporting","reactTag","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","bundleType","version","rendererPackageName","ReactNativeRenderer$2","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"AAYA;;;;AAEA,IAAIA,OAAJ,EAAa;AACX,GAAC,YAAW;AACd;;AAEAC,IAAAA,OAAO,6BAAP;;AACA,QAAIC,6BAA6B,GAAGD,OAAO,0CAA3C;;AACA,QAAIE,SAAS,GAAGF,OAAO,+BAAvB;;AACA,QAAIG,eAAe,GAAGH,OAAO,sCAA7B;;AACA,QAAII,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAAnB;;AACA,QAAIK,iCAAiC,GAAGL,OAAO,qDAA/C;;AACA,QAAIM,UAAU,GAAGN,OAAO,qCAAxB;;AACA,QAAIO,YAAY,GAAGP,OAAO,iCAA1B;;AACA,QAAIQ,cAAc,GAAGR,OAAO,6CAA5B;;AACA,QAAIS,cAAc,GAAGT,OAAO,CAAC,2BAAD,CAA5B;;AACA,QAAIU,QAAQ,GAAGV,OAAO,CAAC,mBAAD,CAAtB;;AACA,QAAIW,iBAAiB,GAAGX,OAAO,gCAA/B;;AAaA,QAAIY,cAAc,GAAG,0BAAW,CAAE,CAAlC;;AAEA;AACEA,MAAAA,cAAc,GAAG,wBAASC,MAAT,EAAiB;AAChC,YAAIA,MAAM,KAAKC,SAAf,EAA0B;AACxB,gBAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF,OAJD;AAKD;;AAED,aAASC,SAAT,CAAmBC,SAAnB,EAA8BJ,MAA9B,EAAsCK,CAAtC,EAAyCC,CAAzC,EAA4CC,CAA5C,EAA+CC,CAA/C,EAAkDC,CAAlD,EAAqDC,CAArD,EAAwD;AACtDX,MAAAA,cAAc,CAACC,MAAD,CAAd;;AAEA,UAAI,CAACI,SAAL,EAAgB;AACd,YAAIO,KAAK,GAAG,KAAK,CAAjB;;AACA,YAAIX,MAAM,KAAKC,SAAf,EAA0B;AACxBU,UAAAA,KAAK,GAAG,IAAIT,KAAJ,CACN,uEACE,6DAFI,CAAR;AAID,SALD,MAKO;AACL,cAAIU,IAAI,GAAG,CAACP,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAaC,CAAb,EAAgBC,CAAhB,CAAX;AACA,cAAIG,QAAQ,GAAG,CAAf;AACAF,UAAAA,KAAK,GAAG,IAAIT,KAAJ,CACNF,MAAM,CAACc,OAAP,CAAe,KAAf,EAAsB,YAAW;AAC/B,mBAAOF,IAAI,CAACC,QAAQ,EAAT,CAAX;AACD,WAFD,CADM,CAAR;AAKAF,UAAAA,KAAK,CAACI,IAAN,GAAa,qBAAb;AACD;;AAEDJ,QAAAA,KAAK,CAACK,WAAN,GAAoB,CAApB;AACA,cAAML,KAAN;AACD;AACF;;AAED,QAAIM,yBAAyB,GAAG,mCAC9BF,IAD8B,EAE9BG,IAF8B,EAG9BC,OAH8B,EAI9Bd,CAJ8B,EAK9BC,CAL8B,EAM9BC,CAN8B,EAO9BC,CAP8B,EAQ9BC,CAR8B,EAS9BC,CAT8B,EAU9B;AACA,UAAIU,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAf;;AACA,UAAI;AACFP,QAAAA,IAAI,CAACQ,KAAL,CAAWP,OAAX,EAAoBC,QAApB;AACD,OAFD,CAEE,OAAOT,KAAP,EAAc;AACd,aAAKgB,OAAL,CAAahB,KAAb;AACD;AACF,KAjBD;;AAmBA;AAsBE,UACE,OAAOiB,MAAP,KAAkB,WAAlB,IACA,OAAOA,MAAM,CAACC,aAAd,KAAgC,UADhC,IAEA,OAAOC,QAAP,KAAoB,WAFpB,IAGA,OAAOA,QAAQ,CAACC,WAAhB,KAAgC,UAJlC,EAKE;AACA,YAAIC,QAAQ,GAAGF,QAAQ,CAACG,aAAT,CAAuB,OAAvB,CAAf;;AAEA,YAAIC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAC7BnB,IAD6B,EAE7BG,IAF6B,EAG7BC,OAH6B,EAI7Bd,CAJ6B,EAK7BC,CAL6B,EAM7BC,CAN6B,EAO7BC,CAP6B,EAQ7BC,CAR6B,EAS7BC,CAT6B,EAU7B;AAKAP,UAAAA,SAAS,CACP,OAAO2B,QAAP,KAAoB,WADb,EAEP,8EACE,wEADF,GAEE,8EAFF,GAGE,2EAHF,GAIE,wEAJF,GAKE,yEALF,GAME,qBARK,CAAT;AAUA,cAAIK,GAAG,GAAGL,QAAQ,CAACC,WAAT,CAAqB,OAArB,CAAV;AAQA,cAAIK,QAAQ,GAAG,IAAf;AAKA,cAAIC,WAAW,GAAGT,MAAM,CAACU,KAAzB;AAKA,cAAIlB,QAAQ,GAAGC,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAf;;AACA,mBAASc,YAAT,GAAwB;AAKtBP,YAAAA,QAAQ,CAACQ,mBAAT,CAA6BC,OAA7B,EAAsCF,YAAtC,EAAoD,KAApD;;AAMA,gBACE,OAAOX,MAAM,CAACU,KAAd,KAAwB,WAAxB,IACAV,MAAM,CAACc,cAAP,CAAsB,OAAtB,CAFF,EAGE;AACAd,cAAAA,MAAM,CAACU,KAAP,GAAeD,WAAf;AACD;;AAEDnB,YAAAA,IAAI,CAACQ,KAAL,CAAWP,OAAX,EAAoBC,QAApB;AACAgB,YAAAA,QAAQ,GAAG,KAAX;AACD;;AAaD,cAAIzB,KAAK,GAAG,KAAK,CAAjB;AAEA,cAAIgC,WAAW,GAAG,KAAlB;AACA,cAAIC,kBAAkB,GAAG,KAAzB;;AAEA,mBAASC,iBAAT,CAA2BP,KAA3B,EAAkC;AAChC3B,YAAAA,KAAK,GAAG2B,KAAK,CAAC3B,KAAd;AACAgC,YAAAA,WAAW,GAAG,IAAd;;AACA,gBAAIhC,KAAK,KAAK,IAAV,IAAkB2B,KAAK,CAACQ,KAAN,KAAgB,CAAlC,IAAuCR,KAAK,CAACS,MAAN,KAAiB,CAA5D,EAA+D;AAC7DH,cAAAA,kBAAkB,GAAG,IAArB;AACD;;AACD,gBAAIN,KAAK,CAACU,gBAAV,EAA4B;AAI1B,kBAAIrC,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAtC,EAAgD;AAC9C,oBAAI;AACFA,kBAAAA,KAAK,CAACsC,gBAAN,GAAyB,IAAzB;AACD,iBAFD,CAEE,OAAOC,KAAP,EAAc,CAEf;AACF;AACF;AACF;;AAGD,cAAIT,OAAO,GAAG,YAAY1B,IAAI,GAAGA,IAAH,GAAU,uBAA1B,CAAd;AAGAa,UAAAA,MAAM,CAACuB,gBAAP,CAAwB,OAAxB,EAAiCN,iBAAjC;AACAb,UAAAA,QAAQ,CAACmB,gBAAT,CAA0BV,OAA1B,EAAmCF,YAAnC,EAAiD,KAAjD;AAIAJ,UAAAA,GAAG,CAACiB,SAAJ,CAAcX,OAAd,EAAuB,KAAvB,EAA8B,KAA9B;AACAT,UAAAA,QAAQ,CAACH,aAAT,CAAuBM,GAAvB;;AAEA,cAAIC,QAAJ,EAAc;AACZ,gBAAI,CAACO,WAAL,EAAkB;AAEhBhC,cAAAA,KAAK,GAAG,IAAIT,KAAJ,CACN,kEACE,0DADF,GAEE,2DAFF,GAGE,4DAHF,GAIE,+DAJF,GAKE,6DALF,GAME,gEANF,GAOE,qDARI,CAAR;AAUD,aAZD,MAYO,IAAI0C,kBAAJ,EAAwB;AAC7BjC,cAAAA,KAAK,GAAG,IAAIT,KAAJ,CACN,mEACE,0CADF,GAEE,iEAHI,CAAR;AAKD;;AACD,iBAAKyB,OAAL,CAAahB,KAAb;AACD;;AAGDiB,UAAAA,MAAM,CAACY,mBAAP,CAA2B,OAA3B,EAAoCK,iBAApC;AACD,SA3ID;;AA6IA5B,QAAAA,yBAAyB,GAAGiB,wBAA5B;AACD;AACF;AAED,QAAImB,2BAA2B,GAAGpC,yBAAlC;AAGA,QAAIqC,QAAQ,GAAG,KAAf;AACA,QAAIC,WAAW,GAAG,IAAlB;AAGA,QAAIC,eAAe,GAAG,KAAtB;AACA,QAAIC,YAAY,GAAG,IAAnB;AAEA,QAAIC,QAAQ,GAAG;AACb/B,MAAAA,OAAO,EAAE,iBAAShB,KAAT,EAAgB;AACvB2C,QAAAA,QAAQ,GAAG,IAAX;AACAC,QAAAA,WAAW,GAAG5C,KAAd;AACD;AAJY,KAAf;;AAoBA,aAASgD,qBAAT,CAA+B5C,IAA/B,EAAqCG,IAArC,EAA2CC,OAA3C,EAAoDd,CAApD,EAAuDC,CAAvD,EAA0DC,CAA1D,EAA6DC,CAA7D,EAAgEC,CAAhE,EAAmEC,CAAnE,EAAsE;AACpE4C,MAAAA,QAAQ,GAAG,KAAX;AACAC,MAAAA,WAAW,GAAG,IAAd;AACAF,MAAAA,2BAA2B,CAAC3B,KAA5B,CAAkCgC,QAAlC,EAA4CjC,SAA5C;AACD;;AAYD,aAASmC,uCAAT,CACE7C,IADF,EAEEG,IAFF,EAGEC,OAHF,EAIEd,CAJF,EAKEC,CALF,EAMEC,CANF,EAOEC,CAPF,EAQEC,CARF,EASEC,CATF,EAUE;AACAiD,MAAAA,qBAAqB,CAACjC,KAAtB,CAA4B,IAA5B,EAAkCD,SAAlC;;AACA,UAAI6B,QAAJ,EAAc;AACZ,YAAI3C,KAAK,GAAGkD,gBAAgB,EAA5B;;AACA,YAAI,CAACL,eAAL,EAAsB;AACpBA,UAAAA,eAAe,GAAG,IAAlB;AACAC,UAAAA,YAAY,GAAG9C,KAAf;AACD;AACF;AACF;;AAMD,aAASmD,kBAAT,GAA8B;AAC5B,UAAIN,eAAJ,EAAqB;AACnB,YAAI7C,KAAK,GAAG8C,YAAZ;AACAD,QAAAA,eAAe,GAAG,KAAlB;AACAC,QAAAA,YAAY,GAAG,IAAf;AACA,cAAM9C,KAAN;AACD;AACF;;AAED,aAASoD,cAAT,GAA0B;AACxB,aAAOT,QAAP;AACD;;AAED,aAASO,gBAAT,GAA4B;AAC1B,UAAIP,QAAJ,EAAc;AACZ,YAAI3C,KAAK,GAAG4C,WAAZ;AACAD,QAAAA,QAAQ,GAAG,KAAX;AACAC,QAAAA,WAAW,GAAG,IAAd;AACA,eAAO5C,KAAP;AACD,OALD,MAKO;AACLR,QAAAA,SAAS,CACP,KADO,EAEP,uEACE,2DAHK,CAAT;AAKD;AACF;;AAKD,QAAI6D,gBAAgB,GAAG,IAAvB;AAKA,QAAIC,cAAc,GAAG,EAArB;;AAOA,aAASC,uBAAT,GAAmC;AACjC,UAAI,CAACF,gBAAL,EAAuB;AAErB;AACD;;AACD,WAAK,IAAIG,UAAT,IAAuBF,cAAvB,EAAuC;AACrC,YAAIG,YAAY,GAAGH,cAAc,CAACE,UAAD,CAAjC;AACA,YAAIE,WAAW,GAAGL,gBAAgB,CAACM,OAAjB,CAAyBH,UAAzB,CAAlB;AACAhE,QAAAA,SAAS,CACPkE,WAAW,GAAG,CAAC,CADR,EAEP,2EACE,4BAHK,EAIPF,UAJO,CAAT;;AAMA,YAAII,OAAO,CAACF,WAAD,CAAX,EAA0B;AACxB;AACD;;AACDlE,QAAAA,SAAS,CACPiE,YAAY,CAACI,aADN,EAEP,0EACE,4BAHK,EAIPL,UAJO,CAAT;AAMAI,QAAAA,OAAO,CAACF,WAAD,CAAP,GAAuBD,YAAvB;AACA,YAAIK,eAAe,GAAGL,YAAY,CAACM,UAAnC;;AACA,aAAK,IAAIC,SAAT,IAAsBF,eAAtB,EAAuC;AACrCtE,UAAAA,SAAS,CACPyE,qBAAqB,CACnBH,eAAe,CAACE,SAAD,CADI,EAEnBP,YAFmB,EAGnBO,SAHmB,CADd,EAMP,oEANO,EAOPA,SAPO,EAQPR,UARO,CAAT;AAUD;AACF;AACF;;AAUD,aAASS,qBAAT,CAA+BC,cAA/B,EAA+CT,YAA/C,EAA6DO,SAA7D,EAAwE;AACtExE,MAAAA,SAAS,CACP,CAAC2E,wBAAwB,CAACpC,cAAzB,CAAwCiC,SAAxC,CADM,EAEP,wEACE,mBAHK,EAIPA,SAJO,CAAT;AAMAG,MAAAA,wBAAwB,CAACH,SAAD,CAAxB,GAAsCE,cAAtC;AAEA,UAAIE,uBAAuB,GAAGF,cAAc,CAACE,uBAA7C;;AACA,UAAIA,uBAAJ,EAA6B;AAC3B,aAAK,IAAIC,SAAT,IAAsBD,uBAAtB,EAA+C;AAC7C,cAAIA,uBAAuB,CAACrC,cAAxB,CAAuCsC,SAAvC,CAAJ,EAAuD;AACrD,gBAAIC,sBAAsB,GAAGF,uBAAuB,CAACC,SAAD,CAApD;AACAE,YAAAA,uBAAuB,CACrBD,sBADqB,EAErBb,YAFqB,EAGrBO,SAHqB,CAAvB;AAKD;AACF;;AACD,eAAO,IAAP;AACD,OAZD,MAYO,IAAIE,cAAc,CAACM,gBAAnB,EAAqC;AAC1CD,QAAAA,uBAAuB,CACrBL,cAAc,CAACM,gBADM,EAErBf,YAFqB,EAGrBO,SAHqB,CAAvB;AAKA,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;AASD,aAASO,uBAAT,CAAiCC,gBAAjC,EAAmDf,YAAnD,EAAiEO,SAAjE,EAA4E;AAC1ExE,MAAAA,SAAS,CACP,CAACiF,uBAAuB,CAACD,gBAAD,CADjB,EAEP,wEACE,0BAHK,EAIPA,gBAJO,CAAT;AAMAC,MAAAA,uBAAuB,CAACD,gBAAD,CAAvB,GAA4Cf,YAA5C;AACAiB,MAAAA,4BAA4B,CAACF,gBAAD,CAA5B,GACEf,YAAY,CAACM,UAAb,CAAwBC,SAAxB,EAAmCW,YADrC;AAGA;AACE,YAAIC,cAAc,GAAGJ,gBAAgB,CAACK,WAAjB,EAArB;AACD;AACF;;AAWD,QAAIjB,OAAO,GAAG,EAAd;AAKA,QAAIO,wBAAwB,GAAG,EAA/B;AAKA,QAAIM,uBAAuB,GAAG,EAA9B;AAKA,QAAIC,4BAA4B,GAAG,EAAnC;;AAoBA,aAASI,sBAAT,CAAgCC,wBAAhC,EAA0D;AACxDvF,MAAAA,SAAS,CACP,CAAC6D,gBADM,EAEP,wEACE,kEAHK,CAAT;AAMAA,MAAAA,gBAAgB,GAAG3C,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BkE,wBAA3B,CAAnB;AACAxB,MAAAA,uBAAuB;AACxB;;AAYD,aAASyB,wBAAT,CAAkCC,sBAAlC,EAA0D;AACxD,UAAIC,eAAe,GAAG,KAAtB;;AACA,WAAK,IAAI1B,UAAT,IAAuByB,sBAAvB,EAA+C;AAC7C,YAAI,CAACA,sBAAsB,CAAClD,cAAvB,CAAsCyB,UAAtC,CAAL,EAAwD;AACtD;AACD;;AACD,YAAIC,YAAY,GAAGwB,sBAAsB,CAACzB,UAAD,CAAzC;;AACA,YACE,CAACF,cAAc,CAACvB,cAAf,CAA8ByB,UAA9B,CAAD,IACAF,cAAc,CAACE,UAAD,CAAd,KAA+BC,YAFjC,EAGE;AACAjE,UAAAA,SAAS,CACP,CAAC8D,cAAc,CAACE,UAAD,CADR,EAEP,oEACE,4BAHK,EAIPA,UAJO,CAAT;AAMAF,UAAAA,cAAc,CAACE,UAAD,CAAd,GAA6BC,YAA7B;AACAyB,UAAAA,eAAe,GAAG,IAAlB;AACD;AACF;;AACD,UAAIA,eAAJ,EAAqB;AACnB3B,QAAAA,uBAAuB;AACxB;AACF;;AASD,QAAI4B,mBAAmB,GAAG,+BAAW,CAAE,CAAvC;;AAEA;AACEA,MAAAA,mBAAmB,GAAG,6BAAS1F,SAAT,EAAoBJ,MAApB,EAA4B;AAChD,aACE,IAAI+F,IAAI,GAAGtE,SAAS,CAACuE,MAArB,EACEpF,IAAI,GAAGS,KAAK,CAAC0E,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAvB,CADd,EAEEE,IAAI,GAAG,CAHX,EAIEA,IAAI,GAAGF,IAJT,EAKEE,IAAI,EALN,EAME;AACArF,UAAAA,IAAI,CAACqF,IAAI,GAAG,CAAR,CAAJ,GAAiBxE,SAAS,CAACwE,IAAD,CAA1B;AACD;;AAED,YAAIjG,MAAM,KAAKC,SAAf,EAA0B;AACxB,gBAAM,IAAIC,KAAJ,CACJ,0EACE,kBAFE,CAAN;AAID;;AACD,YAAIE,SAAJ,EAAe;AACb;AACD;;AACD,YAAI,OAAO8F,OAAP,KAAmB,WAAvB,EAAoC;AAClC,cAAIC,QAAJ;;AAEA,cAAIC,UAAU,GAAGxF,IAAI,CAACyF,GAAL,CAAS,UAASC,IAAT,EAAe;AACvC,mBAAO,KAAKA,IAAZ;AACD,WAFgB,CAAjB;;AAGA,WAACH,QAAQ,GAAGD,OAAZ,EAAqBvF,KAArB,CAA2Be,KAA3B,CACEyE,QADF,EAEE,CAAC,cAAcnG,MAAf,EAAuBuG,MAAvB,CAA8BH,UAA9B,CAFF;AAID;;AACD,YAAI;AAIF,cAAIvF,QAAQ,GAAG,CAAf;AACA,cAAI2F,OAAO,GACT,cACAxG,MAAM,CAACc,OAAP,CAAe,KAAf,EAAsB,YAAW;AAC/B,mBAAOF,IAAI,CAACC,QAAQ,EAAT,CAAX;AACD,WAFD,CAFF;AAKA,gBAAM,IAAIX,KAAJ,CAAUsG,OAAV,CAAN;AACD,SAXD,CAWE,OAAOC,CAAP,EAAU,CAAE;AACf,OA3CD;AA4CD;AAED,QAAIC,qBAAqB,GAAGZ,mBAA5B;AAEA,QAAIa,4BAA4B,GAAG,IAAnC;AACA,QAAIC,mBAAmB,GAAG,IAA1B;AACA,QAAIC,mBAAmB,GAAG,IAA1B;;AAEA,aAASC,gBAAT,CACEC,gCADF,EAEEC,uBAFF,EAGEC,uBAHF,EAIE;AACAN,MAAAA,4BAA4B,GAAGI,gCAA/B;AACAH,MAAAA,mBAAmB,GAAGI,uBAAtB;AACAH,MAAAA,mBAAmB,GAAGI,uBAAtB;AACA;AACE,UAAEJ,mBAAmB,IAAID,mBAAzB,IACIF,qBAAqB,CACnB,KADmB,EAEnB,sDACE,+DAHiB,CADzB,GAMI,KAAK,CANT;AAOD;AACF;;AAED,QAAIQ,uBAAuB,GAAG,KAAK,CAAnC;AACA;AACEA,MAAAA,uBAAuB,GAAG,iCAAS5E,KAAT,EAAgB;AACxC,YAAI6E,iBAAiB,GAAG7E,KAAK,CAAC8E,kBAA9B;AACA,YAAIC,iBAAiB,GAAG/E,KAAK,CAACgF,kBAA9B;AAEA,YAAIC,cAAc,GAAGlG,KAAK,CAACmG,OAAN,CAAcL,iBAAd,CAArB;AACA,YAAIM,YAAY,GAAGF,cAAc,GAC7BJ,iBAAiB,CAACnB,MADW,GAE7BmB,iBAAiB,GACf,CADe,GAEf,CAJN;AAMA,YAAIO,cAAc,GAAGrG,KAAK,CAACmG,OAAN,CAAcH,iBAAd,CAArB;AACA,YAAIM,YAAY,GAAGD,cAAc,GAC7BL,iBAAiB,CAACrB,MADW,GAE7BqB,iBAAiB,GACf,CADe,GAEf,CAJN;AAMA,UAAEK,cAAc,KAAKH,cAAnB,IAAqCI,YAAY,KAAKF,YAAxD,IACIf,qBAAqB,CAAC,KAAD,EAAQ,oCAAR,CADzB,GAEI,KAAK,CAFT;AAGD,OArBD;AAsBD;;AASD,aAASkB,eAAT,CAAyBtF,KAAzB,EAAgCuF,SAAhC,EAA2CC,QAA3C,EAAqDC,IAArD,EAA2D;AACzD,UAAIC,IAAI,GAAG1F,KAAK,CAAC0F,IAAN,IAAc,eAAzB;AACA1F,MAAAA,KAAK,CAAC2F,aAAN,GAAsBpB,mBAAmB,CAACkB,IAAD,CAAzC;AACAnE,MAAAA,uCAAuC,CAACoE,IAAD,EAAOF,QAAP,EAAiB7H,SAAjB,EAA4BqC,KAA5B,CAAvC;AACAA,MAAAA,KAAK,CAAC2F,aAAN,GAAsB,IAAtB;AACD;;AAKD,aAASC,wBAAT,CAAkC5F,KAAlC,EAAyCuF,SAAzC,EAAoD;AAClD,UAAIV,iBAAiB,GAAG7E,KAAK,CAAC8E,kBAA9B;AACA,UAAIC,iBAAiB,GAAG/E,KAAK,CAACgF,kBAA9B;AACA;AACEJ,QAAAA,uBAAuB,CAAC5E,KAAD,CAAvB;AACD;;AACD,UAAIjB,KAAK,CAACmG,OAAN,CAAcL,iBAAd,CAAJ,EAAsC;AACpC,aAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,iBAAiB,CAACnB,MAAtC,EAA8CmC,CAAC,EAA/C,EAAmD;AACjD,cAAI7F,KAAK,CAAC8F,oBAAN,EAAJ,EAAkC;AAChC;AACD;;AAEDR,UAAAA,eAAe,CACbtF,KADa,EAEbuF,SAFa,EAGbV,iBAAiB,CAACgB,CAAD,CAHJ,EAIbd,iBAAiB,CAACc,CAAD,CAJJ,CAAf;AAMD;AACF,OAbD,MAaO,IAAIhB,iBAAJ,EAAuB;AAC5BS,QAAAA,eAAe,CAACtF,KAAD,EAAQuF,SAAR,EAAmBV,iBAAnB,EAAsCE,iBAAtC,CAAf;AACD;;AACD/E,MAAAA,KAAK,CAAC8E,kBAAN,GAA2B,IAA3B;AACA9E,MAAAA,KAAK,CAACgF,kBAAN,GAA2B,IAA3B;AACD;;AASD,aAASe,sCAAT,CAAgD/F,KAAhD,EAAuD;AACrD,UAAI6E,iBAAiB,GAAG7E,KAAK,CAAC8E,kBAA9B;AACA,UAAIC,iBAAiB,GAAG/E,KAAK,CAACgF,kBAA9B;AACA;AACEJ,QAAAA,uBAAuB,CAAC5E,KAAD,CAAvB;AACD;;AACD,UAAIjB,KAAK,CAACmG,OAAN,CAAcL,iBAAd,CAAJ,EAAsC;AACpC,aAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,iBAAiB,CAACnB,MAAtC,EAA8CmC,CAAC,EAA/C,EAAmD;AACjD,cAAI7F,KAAK,CAAC8F,oBAAN,EAAJ,EAAkC;AAChC;AACD;;AAED,cAAIjB,iBAAiB,CAACgB,CAAD,CAAjB,CAAqB7F,KAArB,EAA4B+E,iBAAiB,CAACc,CAAD,CAA7C,CAAJ,EAAuD;AACrD,mBAAOd,iBAAiB,CAACc,CAAD,CAAxB;AACD;AACF;AACF,OAVD,MAUO,IAAIhB,iBAAJ,EAAuB;AAC5B,YAAIA,iBAAiB,CAAC7E,KAAD,EAAQ+E,iBAAR,CAArB,EAAiD;AAC/C,iBAAOA,iBAAP;AACD;AACF;;AACD,aAAO,IAAP;AACD;;AAKD,aAASiB,kCAAT,CAA4ChG,KAA5C,EAAmD;AACjD,UAAIiG,GAAG,GAAGF,sCAAsC,CAAC/F,KAAD,CAAhD;AACAA,MAAAA,KAAK,CAACgF,kBAAN,GAA2B,IAA3B;AACAhF,MAAAA,KAAK,CAAC8E,kBAAN,GAA2B,IAA3B;AACA,aAAOmB,GAAP;AACD;;AAWD,aAASC,qBAAT,CAA+BlG,KAA/B,EAAsC;AACpC;AACE4E,QAAAA,uBAAuB,CAAC5E,KAAD,CAAvB;AACD;AACD,UAAImG,gBAAgB,GAAGnG,KAAK,CAAC8E,kBAA7B;AACA,UAAIsB,gBAAgB,GAAGpG,KAAK,CAACgF,kBAA7B;AACAnH,MAAAA,SAAS,CACP,CAACkB,KAAK,CAACmG,OAAN,CAAciB,gBAAd,CADM,EAEP,8CAFO,CAAT;AAIAnG,MAAAA,KAAK,CAAC2F,aAAN,GAAsBQ,gBAAgB,GAClC5B,mBAAmB,CAAC6B,gBAAD,CADe,GAElC,IAFJ;AAGA,UAAIC,GAAG,GAAGF,gBAAgB,GAAGA,gBAAgB,CAACnG,KAAD,CAAnB,GAA6B,IAAvD;AACAA,MAAAA,KAAK,CAAC2F,aAAN,GAAsB,IAAtB;AACA3F,MAAAA,KAAK,CAAC8E,kBAAN,GAA2B,IAA3B;AACA9E,MAAAA,KAAK,CAACgF,kBAAN,GAA2B,IAA3B;AACA,aAAOqB,GAAP;AACD;;AAMD,aAASC,aAAT,CAAuBtG,KAAvB,EAA8B;AAC5B,aAAO,CAAC,CAACA,KAAK,CAAC8E,kBAAf;AACD;;AAeD,aAASyB,cAAT,CAAwBC,OAAxB,EAAiCC,IAAjC,EAAuC;AACrC5I,MAAAA,SAAS,CACP4I,IAAI,IAAI,IADD,EAEP,uEAFO,CAAT;;AAKA,UAAID,OAAO,IAAI,IAAf,EAAqB;AACnB,eAAOC,IAAP;AACD;;AAID,UAAI1H,KAAK,CAACmG,OAAN,CAAcsB,OAAd,CAAJ,EAA4B;AAC1B,YAAIzH,KAAK,CAACmG,OAAN,CAAcuB,IAAd,CAAJ,EAAyB;AACvBD,UAAAA,OAAO,CAACE,IAAR,CAAatH,KAAb,CAAmBoH,OAAnB,EAA4BC,IAA5B;AACA,iBAAOD,OAAP;AACD;;AACDA,QAAAA,OAAO,CAACE,IAAR,CAAaD,IAAb;AACA,eAAOD,OAAP;AACD;;AAED,UAAIzH,KAAK,CAACmG,OAAN,CAAcuB,IAAd,CAAJ,EAAyB;AAEvB,eAAO,CAACD,OAAD,EAAUvC,MAAV,CAAiBwC,IAAjB,CAAP;AACD;;AAED,aAAO,CAACD,OAAD,EAAUC,IAAV,CAAP;AACD;;AAWD,aAASE,kBAAT,CAA4BC,GAA5B,EAAiCC,EAAjC,EAAqCC,KAArC,EAA4C;AAC1C,UAAI/H,KAAK,CAACmG,OAAN,CAAc0B,GAAd,CAAJ,EAAwB;AACtBA,QAAAA,GAAG,CAACG,OAAJ,CAAYF,EAAZ,EAAgBC,KAAhB;AACD,OAFD,MAEO,IAAIF,GAAJ,EAAS;AACdC,QAAAA,EAAE,CAAC3H,IAAH,CAAQ4H,KAAR,EAAeF,GAAf;AACD;AACF;;AAMD,QAAII,UAAU,GAAG,IAAjB;;AASA,QAAIC,2BAA2B,GAAG,SAA9BA,2BAA8B,CAASjH,KAAT,EAAgBuF,SAAhB,EAA2B;AAC3D,UAAIvF,KAAJ,EAAW;AACT4F,QAAAA,wBAAwB,CAAC5F,KAAD,EAAQuF,SAAR,CAAxB;;AAEA,YAAI,CAACvF,KAAK,CAACkH,YAAN,EAAL,EAA2B;AACzBlH,UAAAA,KAAK,CAACmH,WAAN,CAAkBC,OAAlB,CAA0BpH,KAA1B;AACD;AACF;AACF,KARD;;AASA,QAAIqH,oCAAoC,GAAG,SAAvCA,oCAAuC,CAASlJ,CAAT,EAAY;AACrD,aAAO8I,2BAA2B,CAAC9I,CAAD,EAAI,IAAJ,CAAlC;AACD,KAFD;;AAGA,QAAImJ,mCAAmC,GAAG,SAAtCA,mCAAsC,CAASnJ,CAAT,EAAY;AACpD,aAAO8I,2BAA2B,CAAC9I,CAAD,EAAI,KAAJ,CAAlC;AACD,KAFD;;AAIA,aAASoJ,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B,aACEA,GAAG,KAAK,QAAR,IACAA,GAAG,KAAK,OADR,IAEAA,GAAG,KAAK,QAFR,IAGAA,GAAG,KAAK,UAJV;AAMD;;AAED,aAASC,uBAAT,CAAiChJ,IAAjC,EAAuCiH,IAAvC,EAA6CgC,KAA7C,EAAoD;AAClD,cAAQjJ,IAAR;AACE,aAAK,SAAL;AACA,aAAK,gBAAL;AACA,aAAK,eAAL;AACA,aAAK,sBAAL;AACA,aAAK,aAAL;AACA,aAAK,oBAAL;AACA,aAAK,aAAL;AACA,aAAK,oBAAL;AACA,aAAK,WAAL;AACA,aAAK,kBAAL;AACE,iBAAO,CAAC,EAAEiJ,KAAK,CAACC,QAAN,IAAkBJ,aAAa,CAAC7B,IAAD,CAAjC,CAAR;;AACF;AACE,iBAAO,KAAP;AAbJ;AAeD;;AA4BD,QAAIkC,SAAS,GAAG;AAKdzE,MAAAA,sBAAsB,EAAEA,sBALV;AAUdE,MAAAA,wBAAwB,EAAEA;AAVZ,KAAhB;;AAkBA,aAASwE,WAAT,CAAqBpC,IAArB,EAA2B5C,gBAA3B,EAA6C;AAC3C,UAAI2C,QAAQ,GAAG,KAAK,CAApB;AAIA,UAAIsC,SAAS,GAAGrC,IAAI,CAACqC,SAArB;;AACA,UAAI,CAACA,SAAL,EAAgB;AAEd,eAAO,IAAP;AACD;;AACD,UAAIJ,KAAK,GAAGrD,4BAA4B,CAACyD,SAAD,CAAxC;;AACA,UAAI,CAACJ,KAAL,EAAY;AAEV,eAAO,IAAP;AACD;;AACDlC,MAAAA,QAAQ,GAAGkC,KAAK,CAAC7E,gBAAD,CAAhB;;AACA,UAAI4E,uBAAuB,CAAC5E,gBAAD,EAAmB4C,IAAI,CAACC,IAAxB,EAA8BgC,KAA9B,CAA3B,EAAiE;AAC/D,eAAO,IAAP;AACD;;AACD7J,MAAAA,SAAS,CACP,CAAC2H,QAAD,IAAa,OAAOA,QAAP,KAAoB,UAD1B,EAEP,4EAFO,EAGP3C,gBAHO,EAIP,OAAO2C,QAJA,CAAT;AAMA,aAAOA,QAAP;AACD;;AASD,aAAStD,aAAT,CACE6F,YADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,iBAJF,EAKE;AACA,UAAIC,MAAM,GAAG,IAAb;;AACA,WAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5D,OAAO,CAACyB,MAA5B,EAAoCmC,CAAC,EAArC,EAAyC;AAEvC,YAAIuC,cAAc,GAAGnG,OAAO,CAAC4D,CAAD,CAA5B;;AACA,YAAIuC,cAAJ,EAAoB;AAClB,cAAIC,eAAe,GAAGD,cAAc,CAAClG,aAAf,CACpB6F,YADoB,EAEpBC,UAFoB,EAGpBC,WAHoB,EAIpBC,iBAJoB,CAAtB;;AAMA,cAAIG,eAAJ,EAAqB;AACnBF,YAAAA,MAAM,GAAG5B,cAAc,CAAC4B,MAAD,EAASE,eAAT,CAAvB;AACD;AACF;AACF;;AACD,aAAOF,MAAP;AACD;;AAED,aAASG,gBAAT,CAA0BH,MAA1B,EAAkC5C,SAAlC,EAA6C;AAC3C,UAAI4C,MAAM,KAAK,IAAf,EAAqB;AACnBnB,QAAAA,UAAU,GAAGT,cAAc,CAACS,UAAD,EAAamB,MAAb,CAA3B;AACD;;AAID,UAAII,oBAAoB,GAAGvB,UAA3B;AACAA,MAAAA,UAAU,GAAG,IAAb;;AAEA,UAAI,CAACuB,oBAAL,EAA2B;AACzB;AACD;;AAED,UAAIhD,SAAJ,EAAe;AACboB,QAAAA,kBAAkB,CAChB4B,oBADgB,EAEhBlB,oCAFgB,CAAlB;AAID,OALD,MAKO;AACLV,QAAAA,kBAAkB,CAChB4B,oBADgB,EAEhBjB,mCAFgB,CAAlB;AAID;;AACDzJ,MAAAA,SAAS,CACP,CAACmJ,UADM,EAEP,2EACE,gEAHK,CAAT;AAMAxF,MAAAA,kBAAkB;AACnB;;AAED,aAASgH,yBAAT,CACET,YADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,iBAJF,EAKE;AACA,UAAIC,MAAM,GAAGjG,aAAa,CACxB6F,YADwB,EAExBC,UAFwB,EAGxBC,WAHwB,EAIxBC,iBAJwB,CAA1B;AAMAI,MAAAA,gBAAgB,CAACH,MAAD,EAAS,KAAT,CAAhB;AACD;;AAED,QAAIM,mBAAmB,GAAG,CAA1B;AACA,QAAIC,uBAAuB,GAAG,CAA9B;AACA,QAAIC,cAAc,GAAG,CAArB;AACA,QAAIC,kBAAkB,GAAG,CAAzB;AACA,QAAIC,sBAAsB,GAAG,CAA7B;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,aAAa,GAAG,CAApB;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,IAAI,GAAG,EAAX;AACA,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,eAAe,GAAG,EAAtB;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,QAAIC,cAAc,GAAG,EAArB;AACA,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,oBAAoB,GAAG,EAA3B;;AAEA,aAASC,SAAT,CAAmBjE,IAAnB,EAAyB;AACvB,SAAG;AACDA,QAAAA,IAAI,GAAGA,IAAI,CAACkE,MAAZ;AAMD,OAPD,QAOSlE,IAAI,IAAIA,IAAI,CAAC+B,GAAL,KAAawB,aAP9B;;AAQA,UAAIvD,IAAJ,EAAU;AACR,eAAOA,IAAP;AACD;;AACD,aAAO,IAAP;AACD;;AAMD,aAASmE,uBAAT,CAAiCC,KAAjC,EAAwCC,KAAxC,EAA+C;AAC7C,UAAIC,MAAM,GAAG,CAAb;;AACA,WAAK,IAAIC,KAAK,GAAGH,KAAjB,EAAwBG,KAAxB,EAA+BA,KAAK,GAAGN,SAAS,CAACM,KAAD,CAAhD,EAAyD;AACvDD,QAAAA,MAAM;AACP;;AACD,UAAIE,MAAM,GAAG,CAAb;;AACA,WAAK,IAAIC,KAAK,GAAGJ,KAAjB,EAAwBI,KAAxB,EAA+BA,KAAK,GAAGR,SAAS,CAACQ,KAAD,CAAhD,EAAyD;AACvDD,QAAAA,MAAM;AACP;;AAGD,aAAOF,MAAM,GAAGE,MAAT,GAAkB,CAAzB,EAA4B;AAC1BJ,QAAAA,KAAK,GAAGH,SAAS,CAACG,KAAD,CAAjB;AACAE,QAAAA,MAAM;AACP;;AAGD,aAAOE,MAAM,GAAGF,MAAT,GAAkB,CAAzB,EAA4B;AAC1BD,QAAAA,KAAK,GAAGJ,SAAS,CAACI,KAAD,CAAjB;AACAG,QAAAA,MAAM;AACP;;AAGD,UAAIE,KAAK,GAAGJ,MAAZ;;AACA,aAAOI,KAAK,EAAZ,EAAgB;AACd,YAAIN,KAAK,KAAKC,KAAV,IAAmBD,KAAK,KAAKC,KAAK,CAACM,SAAvC,EAAkD;AAChD,iBAAOP,KAAP;AACD;;AACDA,QAAAA,KAAK,GAAGH,SAAS,CAACG,KAAD,CAAjB;AACAC,QAAAA,KAAK,GAAGJ,SAAS,CAACI,KAAD,CAAjB;AACD;;AACD,aAAO,IAAP;AACD;;AAKD,aAASO,UAAT,CAAoBR,KAApB,EAA2BC,KAA3B,EAAkC;AAChC,aAAOA,KAAP,EAAc;AACZ,YAAID,KAAK,KAAKC,KAAV,IAAmBD,KAAK,KAAKC,KAAK,CAACM,SAAvC,EAAkD;AAChD,iBAAO,IAAP;AACD;;AACDN,QAAAA,KAAK,GAAGJ,SAAS,CAACI,KAAD,CAAjB;AACD;;AACD,aAAO,KAAP;AACD;;AAKD,aAASQ,iBAAT,CAA2B7E,IAA3B,EAAiC;AAC/B,aAAOiE,SAAS,CAACjE,IAAD,CAAhB;AACD;;AAKD,aAAS8E,gBAAT,CAA0B9E,IAA1B,EAAgC+E,EAAhC,EAAoCC,GAApC,EAAyC;AACvC,UAAIC,IAAI,GAAG,EAAX;;AACA,aAAOjF,IAAP,EAAa;AACXiF,QAAAA,IAAI,CAAChE,IAAL,CAAUjB,IAAV;AACAA,QAAAA,IAAI,GAAGiE,SAAS,CAACjE,IAAD,CAAhB;AACD;;AACD,UAAII,CAAC,GAAG,KAAK,CAAb;;AACA,WAAKA,CAAC,GAAG6E,IAAI,CAAChH,MAAd,EAAsBmC,CAAC,KAAK,CAA5B,GAAiC;AAC/B2E,QAAAA,EAAE,CAACE,IAAI,CAAC7E,CAAD,CAAL,EAAU,UAAV,EAAsB4E,GAAtB,CAAF;AACD;;AACD,WAAK5E,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG6E,IAAI,CAAChH,MAArB,EAA6BmC,CAAC,EAA9B,EAAkC;AAChC2E,QAAAA,EAAE,CAACE,IAAI,CAAC7E,CAAD,CAAL,EAAU,SAAV,EAAqB4E,GAArB,CAAF;AACD;AACF;;AAcD,aAASE,eAAT,CAAyBlF,IAAzB,EAA+BzF,KAA/B,EAAsC4K,gBAAtC,EAAwD;AACtD,UAAI/H,gBAAgB,GAClB7C,KAAK,CAACuC,cAAN,CAAqBE,uBAArB,CAA6CmI,gBAA7C,CADF;AAEA,aAAO/C,WAAW,CAACpC,IAAD,EAAO5C,gBAAP,CAAlB;AACD;;AAkBD,aAASgI,+BAAT,CAAyCpF,IAAzC,EAA+CqF,KAA/C,EAAsD9K,KAAtD,EAA6D;AAC3D;AACE,SAACyF,IAAD,GACIrB,qBAAqB,CAAC,KAAD,EAAQ,mCAAR,CADzB,GAEI,KAAK,CAFT;AAGD;AACD,UAAIoB,QAAQ,GAAGmF,eAAe,CAAClF,IAAD,EAAOzF,KAAP,EAAc8K,KAAd,CAA9B;;AACA,UAAItF,QAAJ,EAAc;AACZxF,QAAAA,KAAK,CAAC8E,kBAAN,GAA2ByB,cAAc,CACvCvG,KAAK,CAAC8E,kBADiC,EAEvCU,QAFuC,CAAzC;AAIAxF,QAAAA,KAAK,CAACgF,kBAAN,GAA2BuB,cAAc,CAACvG,KAAK,CAACgF,kBAAP,EAA2BS,IAA3B,CAAzC;AACD;AACF;;AASD,aAASsF,kCAAT,CAA4C/K,KAA5C,EAAmD;AACjD,UAAIA,KAAK,IAAIA,KAAK,CAACuC,cAAN,CAAqBE,uBAAlC,EAA2D;AACzD8H,QAAAA,gBAAgB,CAACvK,KAAK,CAACgL,WAAP,EAAoBH,+BAApB,EAAqD7K,KAArD,CAAhB;AACD;AACF;;AAKD,aAASiL,4CAAT,CAAsDjL,KAAtD,EAA6D;AAC3D,UAAIA,KAAK,IAAIA,KAAK,CAACuC,cAAN,CAAqBE,uBAAlC,EAA2D;AACzD,YAAIuF,UAAU,GAAGhI,KAAK,CAACgL,WAAvB;AACA,YAAIE,UAAU,GAAGlD,UAAU,GAAGsC,iBAAiB,CAACtC,UAAD,CAApB,GAAmC,IAA9D;AACAuC,QAAAA,gBAAgB,CAACW,UAAD,EAAaL,+BAAb,EAA8C7K,KAA9C,CAAhB;AACD;AACF;;AAOD,aAASmL,oBAAT,CAA8B1F,IAA9B,EAAoC2F,gBAApC,EAAsDpL,KAAtD,EAA6D;AAC3D,UAAIyF,IAAI,IAAIzF,KAAR,IAAiBA,KAAK,CAACuC,cAAN,CAAqBM,gBAA1C,EAA4D;AAC1D,YAAIA,gBAAgB,GAAG7C,KAAK,CAACuC,cAAN,CAAqBM,gBAA5C;AACA,YAAI2C,QAAQ,GAAGqC,WAAW,CAACpC,IAAD,EAAO5C,gBAAP,CAA1B;;AACA,YAAI2C,QAAJ,EAAc;AACZxF,UAAAA,KAAK,CAAC8E,kBAAN,GAA2ByB,cAAc,CACvCvG,KAAK,CAAC8E,kBADiC,EAEvCU,QAFuC,CAAzC;AAIAxF,UAAAA,KAAK,CAACgF,kBAAN,GAA2BuB,cAAc,CAACvG,KAAK,CAACgF,kBAAP,EAA2BS,IAA3B,CAAzC;AACD;AACF;AACF;;AAOD,aAAS4F,gCAAT,CAA0CrL,KAA1C,EAAiD;AAC/C,UAAIA,KAAK,IAAIA,KAAK,CAACuC,cAAN,CAAqBM,gBAAlC,EAAoD;AAClDsI,QAAAA,oBAAoB,CAACnL,KAAK,CAACgL,WAAP,EAAoB,IAApB,EAA0BhL,KAA1B,CAApB;AACD;AACF;;AAED,aAASsL,4BAAT,CAAsCnD,MAAtC,EAA8C;AAC5CxB,MAAAA,kBAAkB,CAACwB,MAAD,EAAS4C,kCAAT,CAAlB;AACD;;AAED,aAASQ,sCAAT,CAAgDpD,MAAhD,EAAwD;AACtDxB,MAAAA,kBAAkB,CAACwB,MAAD,EAAS8C,4CAAT,CAAlB;AACD;;AAED,aAASO,0BAAT,CAAoCrD,MAApC,EAA4C;AAC1CxB,MAAAA,kBAAkB,CAACwB,MAAD,EAASkD,gCAAT,CAAlB;AACD;;AAID,QAAII,eAAe,GAAG,EAAtB;AAMA,QAAIC,cAAc,GAAG;AACnBhG,MAAAA,IAAI,EAAE,IADa;AAEnBiG,MAAAA,MAAM,EAAE,IAFW;AAInBhG,MAAAA,aAAa,EAAE,yBAAW;AACxB,eAAO,IAAP;AACD,OANkB;AAOnBiG,MAAAA,UAAU,EAAE,IAPO;AAQnBC,MAAAA,OAAO,EAAE,IARU;AASnBC,MAAAA,UAAU,EAAE,IATO;AAUnBC,MAAAA,SAAS,EAAE,mBAAS/L,KAAT,EAAgB;AACzB,eAAOA,KAAK,CAAC+L,SAAN,IAAmBC,IAAI,CAACC,GAAL,EAA1B;AACD,OAZkB;AAanBvL,MAAAA,gBAAgB,EAAE,IAbC;AAcnBwL,MAAAA,SAAS,EAAE;AAdQ,KAArB;;AAiBA,aAASC,uBAAT,GAAmC;AACjC,aAAO,IAAP;AACD;;AAED,aAASC,wBAAT,GAAoC;AAClC,aAAO,KAAP;AACD;;AAoBD,aAASC,cAAT,CACE9J,cADF,EAEEyF,UAFF,EAGEC,WAHF,EAIEC,iBAJF,EAKE;AACA;AAEE,eAAO,KAAKD,WAAZ;AACA,eAAO,KAAKqE,cAAZ;AACA,eAAO,KAAKC,eAAZ;AACA,eAAO,KAAKC,kBAAZ;AACA,eAAO,KAAK1G,oBAAZ;AACD;AAED,WAAKvD,cAAL,GAAsBA,cAAtB;AACA,WAAKyI,WAAL,GAAmBhD,UAAnB;AACA,WAAKC,WAAL,GAAmBA,WAAnB;AAEA,UAAIwE,SAAS,GAAG,KAAKtF,WAAL,CAAiBsF,SAAjC;;AACA,WAAK,IAAIC,QAAT,IAAqBD,SAArB,EAAgC;AAC9B,YAAI,CAACA,SAAS,CAACrM,cAAV,CAAyBsM,QAAzB,CAAL,EAAyC;AACvC;AACD;;AACD;AACE,iBAAO,KAAKA,QAAL,CAAP;AACD;AACD,YAAIC,SAAS,GAAGF,SAAS,CAACC,QAAD,CAAzB;;AACA,YAAIC,SAAJ,EAAe;AACb,eAAKD,QAAL,IAAiBC,SAAS,CAAC1E,WAAD,CAA1B;AACD,SAFD,MAEO;AACL,cAAIyE,QAAQ,KAAK,QAAjB,EAA2B;AACzB,iBAAKf,MAAL,GAAczD,iBAAd;AACD,WAFD,MAEO;AACL,iBAAKwE,QAAL,IAAiBzE,WAAW,CAACyE,QAAD,CAA5B;AACD;AACF;AACF;;AAED,UAAIhM,gBAAgB,GAClBuH,WAAW,CAACvH,gBAAZ,IAAgC,IAAhC,GACIuH,WAAW,CAACvH,gBADhB,GAEIuH,WAAW,CAAC2E,WAAZ,KAA4B,KAHlC;;AAIA,UAAIlM,gBAAJ,EAAsB;AACpB,aAAK8L,kBAAL,GAA0BL,uBAA1B;AACD,OAFD,MAEO;AACL,aAAKK,kBAAL,GAA0BJ,wBAA1B;AACD;;AACD,WAAKtG,oBAAL,GAA4BsG,wBAA5B;AACA,aAAO,IAAP;AACD;;AAED,aAAcC,cAAc,CAACrN,SAA7B,EAAwC;AACtCsN,MAAAA,cAAc,EAAE,0BAAW;AACzB,aAAK5L,gBAAL,GAAwB,IAAxB;AACA,YAAIV,KAAK,GAAG,KAAKiI,WAAjB;;AACA,YAAI,CAACjI,KAAL,EAAY;AACV;AACD;;AAED,YAAIA,KAAK,CAACsM,cAAV,EAA0B;AACxBtM,UAAAA,KAAK,CAACsM,cAAN;AACD,SAFD,MAEO,IAAI,OAAOtM,KAAK,CAAC4M,WAAb,KAA6B,SAAjC,EAA4C;AACjD5M,UAAAA,KAAK,CAAC4M,WAAN,GAAoB,KAApB;AACD;;AACD,aAAKJ,kBAAL,GAA0BL,uBAA1B;AACD,OAdqC;AAgBtCI,MAAAA,eAAe,EAAE,2BAAW;AAC1B,YAAIvM,KAAK,GAAG,KAAKiI,WAAjB;;AACA,YAAI,CAACjI,KAAL,EAAY;AACV;AACD;;AAED,YAAIA,KAAK,CAACuM,eAAV,EAA2B;AACzBvM,UAAAA,KAAK,CAACuM,eAAN;AACD,SAFD,MAEO,IAAI,OAAOvM,KAAK,CAAC6M,YAAb,KAA8B,SAAlC,EAA6C;AAMlD7M,UAAAA,KAAK,CAAC6M,YAAN,GAAqB,IAArB;AACD;;AAED,aAAK/G,oBAAL,GAA4BqG,uBAA5B;AACD,OAlCqC;AAyCtCW,MAAAA,OAAO,EAAE,mBAAW;AAClB,aAAK5F,YAAL,GAAoBiF,uBAApB;AACD,OA3CqC;AAkDtCjF,MAAAA,YAAY,EAAEkF,wBAlDwB;AAuDtCW,MAAAA,UAAU,EAAE,sBAAW;AACrB,YAAIN,SAAS,GAAG,KAAKtF,WAAL,CAAiBsF,SAAjC;;AACA,aAAK,IAAIC,QAAT,IAAqBD,SAArB,EAAgC;AAC9B;AACEO,YAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEEP,QAFF,EAGEQ,kCAAkC,CAACR,QAAD,EAAWD,SAAS,CAACC,QAAD,CAApB,CAHpC;AAKD;AACF;;AACD,aAAKnK,cAAL,GAAsB,IAAtB;AACA,aAAKyI,WAAL,GAAmB,IAAnB;AACA,aAAK/C,WAAL,GAAmB,IAAnB;AACA,aAAKuE,kBAAL,GAA0BJ,wBAA1B;AACA,aAAKtG,oBAAL,GAA4BsG,wBAA5B;AACA,aAAKtH,kBAAL,GAA0B,IAA1B;AACA,aAAKE,kBAAL,GAA0B,IAA1B;AACA;AACEgI,UAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEE,aAFF,EAGEC,kCAAkC,CAAC,aAAD,EAAgB,IAAhB,CAHpC;AAKAF,UAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEE,oBAFF,EAGEC,kCAAkC,CAChC,oBADgC,EAEhCd,wBAFgC,CAHpC;AAQAY,UAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEE,sBAFF,EAGEC,kCAAkC,CAChC,sBADgC,EAEhCd,wBAFgC,CAHpC;AAQAY,UAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEE,gBAFF,EAGEC,kCAAkC,CAAC,gBAAD,EAAmB,YAAW,CAAE,CAAhC,CAHpC;AAKAF,UAAAA,MAAM,CAACC,cAAP,CACE,IADF,EAEE,iBAFF,EAGEC,kCAAkC,CAAC,iBAAD,EAAoB,YAAW,CAAE,CAAjC,CAHpC;AAKD;AACF;AA1GqC,KAAxC;;AA6GAb,IAAAA,cAAc,CAACI,SAAf,GAA2Bf,cAA3B;;AAKAW,IAAAA,cAAc,CAACc,MAAf,GAAwB,UAASV,SAAT,EAAoB;AAC1C,UAAIW,KAAK,GAAG,IAAZ;;AAEA,UAAIC,CAAC,GAAG,SAAJA,CAAI,GAAW,CAAE,CAArB;;AACAA,MAAAA,CAAC,CAACrO,SAAF,GAAcoO,KAAK,CAACpO,SAApB;AACA,UAAIA,SAAS,GAAG,IAAIqO,CAAJ,EAAhB;;AAEA,eAASC,KAAT,GAAiB;AACf,eAAOF,KAAK,CAAChO,KAAN,CAAY,IAAZ,EAAkBD,SAAlB,CAAP;AACD;;AACD,eAAcH,SAAd,EAAyBsO,KAAK,CAACtO,SAA/B;;AACAsO,MAAAA,KAAK,CAACtO,SAAN,GAAkBA,SAAlB;AACAsO,MAAAA,KAAK,CAACtO,SAAN,CAAgBmI,WAAhB,GAA8BmG,KAA9B;AAEAA,MAAAA,KAAK,CAACb,SAAN,GAAkB,SAAc,EAAd,EAAkBW,KAAK,CAACX,SAAxB,EAAmCA,SAAnC,CAAlB;AACAa,MAAAA,KAAK,CAACH,MAAN,GAAeC,KAAK,CAACD,MAArB;AACAI,MAAAA,iBAAiB,CAACD,KAAD,CAAjB;AAEA,aAAOA,KAAP;AACD,KAnBD;;AAqBAC,IAAAA,iBAAiB,CAAClB,cAAD,CAAjB;;AASA,aAASa,kCAAT,CAA4CR,QAA5C,EAAsDc,MAAtD,EAA8D;AAC5D,UAAIC,UAAU,GAAG,OAAOD,MAAP,KAAkB,UAAnC;AACA,aAAO;AACLE,QAAAA,YAAY,EAAE,IADT;AAELC,QAAAA,GAAG,EAAEA,GAFA;AAGLC,QAAAA,GAAG,EAAEC;AAHA,OAAP;;AAMA,eAASF,GAAT,CAAaG,GAAb,EAAkB;AAChB,YAAIC,MAAM,GAAGN,UAAU,GAAG,oBAAH,GAA0B,sBAAjD;AACAO,QAAAA,IAAI,CAACD,MAAD,EAAS,6BAAT,CAAJ;AACA,eAAOD,GAAP;AACD;;AAED,eAASD,MAAT,GAAkB;AAChB,YAAIE,MAAM,GAAGN,UAAU,GAAG,sBAAH,GAA4B,wBAAnD;AACA,YAAIQ,MAAM,GAAGR,UAAU,GACnB,0BADmB,GAEnB,qBAFJ;AAGAO,QAAAA,IAAI,CAACD,MAAD,EAASE,MAAT,CAAJ;AACA,eAAOT,MAAP;AACD;;AAED,eAASQ,IAAT,CAAcD,MAAd,EAAsBE,MAAtB,EAA8B;AAC5B,YAAIC,gBAAgB,GAAG,KAAvB;AACA,SAACA,gBAAD,GACI9J,qBAAqB,CACnB,KADmB,EAEnB,oFACE,8DADF,GAEE,6EAFF,GAGE,6DALiB,EAMnB2J,MANmB,EAOnBrB,QAPmB,EAQnBuB,MARmB,CADzB,GAWI,KAAK,CAXT;AAYD;AACF;;AAED,aAASE,cAAT,CAAwB5L,cAAxB,EAAwCyF,UAAxC,EAAoDC,WAApD,EAAiEmG,UAAjE,EAA6E;AAC3E,UAAIC,gBAAgB,GAAG,IAAvB;;AACA,UAAIA,gBAAgB,CAACC,SAAjB,CAA2B5K,MAA/B,EAAuC;AACrC,YAAI6K,QAAQ,GAAGF,gBAAgB,CAACC,SAAjB,CAA2BE,GAA3B,EAAf;AACAH,QAAAA,gBAAgB,CAACnP,IAAjB,CACEqP,QADF,EAEEhM,cAFF,EAGEyF,UAHF,EAIEC,WAJF,EAKEmG,UALF;AAOA,eAAOG,QAAP;AACD;;AACD,aAAO,IAAIF,gBAAJ,CACL9L,cADK,EAELyF,UAFK,EAGLC,WAHK,EAILmG,UAJK,CAAP;AAMD;;AAED,aAASK,kBAAT,CAA4BzO,KAA5B,EAAmC;AACjC,UAAIqO,gBAAgB,GAAG,IAAvB;AACAxQ,MAAAA,SAAS,CACPmC,KAAK,YAAYqO,gBADV,EAEP,sEAFO,CAAT;AAIArO,MAAAA,KAAK,CAAC+M,UAAN;;AACA,UAAIsB,gBAAgB,CAACC,SAAjB,CAA2B5K,MAA3B,GAAoC+H,eAAxC,EAAyD;AACvD4C,QAAAA,gBAAgB,CAACC,SAAjB,CAA2B5H,IAA3B,CAAgC1G,KAAhC;AACD;AACF;;AAED,aAASuN,iBAAT,CAA2Bc,gBAA3B,EAA6C;AAC3CA,MAAAA,gBAAgB,CAACC,SAAjB,GAA6B,EAA7B;AACAD,MAAAA,gBAAgB,CAACK,SAAjB,GAA6BP,cAA7B;AACAE,MAAAA,gBAAgB,CAACjH,OAAjB,GAA2BqH,kBAA3B;AACD;;AAOD,QAAIE,uBAAuB,GAAGtC,cAAc,CAACc,MAAf,CAAsB;AAClDyB,MAAAA,YAAY,EAAE,sBAAS3G,WAAT,EAAsB;AAClC,eAAO,IAAP;AACD;AAHiD,KAAtB,CAA9B;AAMA,QAAI4G,eAAe,GAAG,eAAtB;AACA,QAAIC,cAAc,GAAG,cAArB;AACA,QAAIC,aAAa,GAAG,aAApB;AACA,QAAIC,gBAAgB,GAAG,gBAAvB;AACA,QAAIC,UAAU,GAAG,WAAjB;AACA,QAAIC,oBAAoB,GAAG,oBAA3B;;AAEA,aAASC,UAAT,CAAoBpH,YAApB,EAAkC;AAChC,aAAOA,YAAY,KAAK8G,eAAxB;AACD;;AAED,aAASO,SAAT,CAAmBrH,YAAnB,EAAiC;AAC/B,aAAOA,YAAY,KAAK+G,cAAxB;AACD;;AAED,aAASO,QAAT,CAAkBtH,YAAlB,EAAgC;AAC9B,aAAOA,YAAY,KAAKgH,aAAjB,IAAkChH,YAAY,KAAKiH,gBAA1D;AACD;;AAED,QAAIM,iBAAiB,GAAG,CAACT,eAAD,CAAxB;AACA,QAAIU,gBAAgB,GAAG,CAACT,cAAD,CAAvB;AACA,QAAIU,eAAe,GAAG,CAACR,gBAAD,EAAmBD,aAAnB,CAAtB;AAQA,QAAIU,cAAc,GAAG,EAArB;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAId,YAAY,GAAG;AACjBc,MAAAA,SAAS,EAAEA,SADM;AAEjBC,MAAAA,mBAAmB,EAAE,CAFJ;AAMjBC,MAAAA,wBAAwB,EAAE,CAAC,CANV;AAOjBC,MAAAA,mBAAmB,EAAE;AAPJ,KAAnB;;AAUA,aAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAIhC,aAAOA,KAAK,CAAChE,SAAN,IAAmBgE,KAAK,CAACC,SAAhC;AACD;;AAMD,aAASC,iBAAT,CAA2BF,KAA3B,EAAkC;AAChC,aAAO;AACLG,QAAAA,WAAW,EAAE,IADR;AAELC,QAAAA,UAAU,EAAEJ,KAAK,CAACK,KAFb;AAGLC,QAAAA,UAAU,EAAEN,KAAK,CAACO,KAHb;AAILC,QAAAA,cAAc,EAAET,iBAAiB,CAACC,KAAD,CAJ5B;AAKLS,QAAAA,YAAY,EAAET,KAAK,CAACK,KALf;AAMLK,QAAAA,YAAY,EAAEV,KAAK,CAACO,KANf;AAOLI,QAAAA,gBAAgB,EAAEZ,iBAAiB,CAACC,KAAD,CAP9B;AAQLY,QAAAA,aAAa,EAAEZ,KAAK,CAACK,KARhB;AASLQ,QAAAA,aAAa,EAAEb,KAAK,CAACO,KAThB;AAULO,QAAAA,iBAAiB,EAAEf,iBAAiB,CAACC,KAAD;AAV/B,OAAP;AAYD;;AAED,aAASe,gBAAT,CAA0BC,WAA1B,EAAuChB,KAAvC,EAA8C;AAC5CgB,MAAAA,WAAW,CAACb,WAAZ,GAA0B,IAA1B;AACAa,MAAAA,WAAW,CAACZ,UAAZ,GAAyBJ,KAAK,CAACK,KAA/B;AACAW,MAAAA,WAAW,CAACV,UAAZ,GAAyBN,KAAK,CAACO,KAA/B;AACAS,MAAAA,WAAW,CAACR,cAAZ,GAA6BT,iBAAiB,CAACC,KAAD,CAA9C;AACAgB,MAAAA,WAAW,CAACP,YAAZ,GAA2BT,KAAK,CAACK,KAAjC;AACAW,MAAAA,WAAW,CAACN,YAAZ,GAA2BV,KAAK,CAACO,KAAjC;AACAS,MAAAA,WAAW,CAACL,gBAAZ,GAA+BZ,iBAAiB,CAACC,KAAD,CAAhD;AACAgB,MAAAA,WAAW,CAACJ,aAAZ,GAA4BZ,KAAK,CAACK,KAAlC;AACAW,MAAAA,WAAW,CAACH,aAAZ,GAA4Bb,KAAK,CAACO,KAAlC;AACAS,MAAAA,WAAW,CAACF,iBAAZ,GAAgCf,iBAAiB,CAACC,KAAD,CAAjD;AACD;;AAED,aAASiB,kBAAT,CAA4BC,IAA5B,EAAkC;AAChC,UAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;AAEArT,MAAAA,SAAS,CAACqT,UAAU,IAAI,IAAf,EAAqB,qCAArB,CAAT;AACA;AACE,UAAEA,UAAU,IAAIzB,cAAhB,IACIrL,qBAAqB,CACnB,KADmB,EAEnB,2EACE,wEAHiB,EAInB8M,UAJmB,EAKnBzB,cALmB,CADzB,GAQI,KAAK,CART;AASD;AACD,aAAOyB,UAAP;AACD;;AAED,aAASC,gBAAT,CAA0BpB,KAA1B,EAAiC;AAC/B,UAAImB,UAAU,GAAGF,kBAAkB,CAACjB,KAAD,CAAnC;AACA,UAAIgB,WAAW,GAAGrB,SAAS,CAACwB,UAAD,CAA3B;;AACA,UAAIH,WAAJ,EAAiB;AACfD,QAAAA,gBAAgB,CAACC,WAAD,EAAchB,KAAd,CAAhB;AACD,OAFD,MAEO;AACLL,QAAAA,SAAS,CAACwB,UAAD,CAAT,GAAwBjB,iBAAiB,CAACF,KAAD,CAAzC;AACD;;AACDnB,MAAAA,YAAY,CAACiB,mBAAb,GAAmCC,iBAAiB,CAACC,KAAD,CAApD;AACD;;AAED,aAASqB,eAAT,CAAyBrB,KAAzB,EAAgC;AAC9B,UAAIgB,WAAW,GAAGrB,SAAS,CAACsB,kBAAkB,CAACjB,KAAD,CAAnB,CAA3B;;AACA,UAAIgB,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACb,WAAZ,GAA0B,IAA1B;AACAa,QAAAA,WAAW,CAACJ,aAAZ,GAA4BI,WAAW,CAACP,YAAxC;AACAO,QAAAA,WAAW,CAACH,aAAZ,GAA4BG,WAAW,CAACN,YAAxC;AACAM,QAAAA,WAAW,CAACF,iBAAZ,GAAgCE,WAAW,CAACL,gBAA5C;AACAK,QAAAA,WAAW,CAACP,YAAZ,GAA2BT,KAAK,CAACK,KAAjC;AACAW,QAAAA,WAAW,CAACN,YAAZ,GAA2BV,KAAK,CAACO,KAAjC;AACAS,QAAAA,WAAW,CAACL,gBAAZ,GAA+BZ,iBAAiB,CAACC,KAAD,CAAhD;AACAnB,QAAAA,YAAY,CAACiB,mBAAb,GAAmCC,iBAAiB,CAACC,KAAD,CAApD;AACD,OATD,MASO;AACLnM,QAAAA,OAAO,CAACvF,KAAR,CACE,sDAAsD,kBADxD,EAEE,gBAFF,EAGEgT,UAAU,CAACtB,KAAD,CAHZ,EAIEuB,cAAc,EAJhB;AAMD;AACF;;AAED,aAASC,cAAT,CAAwBxB,KAAxB,EAA+B;AAC7B,UAAIgB,WAAW,GAAGrB,SAAS,CAACsB,kBAAkB,CAACjB,KAAD,CAAnB,CAA3B;;AACA,UAAIgB,WAAJ,EAAiB;AACfA,QAAAA,WAAW,CAACb,WAAZ,GAA0B,KAA1B;AACAa,QAAAA,WAAW,CAACJ,aAAZ,GAA4BI,WAAW,CAACP,YAAxC;AACAO,QAAAA,WAAW,CAACH,aAAZ,GAA4BG,WAAW,CAACN,YAAxC;AACAM,QAAAA,WAAW,CAACF,iBAAZ,GAAgCE,WAAW,CAACL,gBAA5C;AACAK,QAAAA,WAAW,CAACP,YAAZ,GAA2BT,KAAK,CAACK,KAAjC;AACAW,QAAAA,WAAW,CAACN,YAAZ,GAA2BV,KAAK,CAACO,KAAjC;AACAS,QAAAA,WAAW,CAACL,gBAAZ,GAA+BZ,iBAAiB,CAACC,KAAD,CAAhD;AACAnB,QAAAA,YAAY,CAACiB,mBAAb,GAAmCC,iBAAiB,CAACC,KAAD,CAApD;AACD,OATD,MASO;AACLnM,QAAAA,OAAO,CAACvF,KAAR,CACE,qDAAqD,iBADvD,EAEE,gBAFF,EAGEgT,UAAU,CAACtB,KAAD,CAHZ,EAIEuB,cAAc,EAJhB;AAMD;AACF;;AAED,aAASD,UAAT,CAAoBtB,KAApB,EAA2B;AACzB,aAAOyB,IAAI,CAACC,SAAL,CAAe;AACpBP,QAAAA,UAAU,EAAEnB,KAAK,CAACmB,UADE;AAEpBd,QAAAA,KAAK,EAAEL,KAAK,CAACK,KAFO;AAGpBE,QAAAA,KAAK,EAAEP,KAAK,CAACO,KAHO;AAIpBN,QAAAA,SAAS,EAAEF,iBAAiB,CAACC,KAAD;AAJR,OAAf,CAAP;AAMD;;AAED,aAASuB,cAAT,GAA0B;AACxB,UAAII,OAAO,GAAGF,IAAI,CAACC,SAAL,CAAe/B,SAAS,CAACzQ,KAAV,CAAgB,CAAhB,EAAmBwQ,cAAnB,CAAf,CAAd;;AACA,UAAIC,SAAS,CAAChM,MAAV,GAAmB+L,cAAvB,EAAuC;AACrCiC,QAAAA,OAAO,IAAI,sBAAsBhC,SAAS,CAAChM,MAAhC,GAAyC,GAApD;AACD;;AACD,aAAOgO,OAAP;AACD;;AAED,QAAIC,0BAA0B,GAAG;AAC/BC,MAAAA,gBAAgB,EAAE,0BAAS7J,YAAT,EAAuBE,WAAvB,EAAoC;AACpD,YAAImH,SAAS,CAACrH,YAAD,CAAb,EAA6B;AAC3BE,UAAAA,WAAW,CAAC4J,cAAZ,CAA2B9K,OAA3B,CAAmCqK,eAAnC;AACD,SAFD,MAEO,IAAIjC,UAAU,CAACpH,YAAD,CAAd,EAA8B;AACnCE,UAAAA,WAAW,CAAC4J,cAAZ,CAA2B9K,OAA3B,CAAmCoK,gBAAnC;AACAvC,UAAAA,YAAY,CAACe,mBAAb,GAAmC1H,WAAW,CAAC6J,OAAZ,CAAoBpO,MAAvD;;AACA,cAAIkL,YAAY,CAACe,mBAAb,KAAqC,CAAzC,EAA4C;AAC1Cf,YAAAA,YAAY,CAACgB,wBAAb,GACE3H,WAAW,CAAC6J,OAAZ,CAAoB,CAApB,EAAuBZ,UADzB;AAED;AACF,SAPM,MAOA,IAAI7B,QAAQ,CAACtH,YAAD,CAAZ,EAA4B;AACjCE,UAAAA,WAAW,CAAC4J,cAAZ,CAA2B9K,OAA3B,CAAmCwK,cAAnC;AACA3C,UAAAA,YAAY,CAACe,mBAAb,GAAmC1H,WAAW,CAAC6J,OAAZ,CAAoBpO,MAAvD;;AACA,cAAIkL,YAAY,CAACe,mBAAb,KAAqC,CAAzC,EAA4C;AAC1C,iBAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6J,SAAS,CAAChM,MAA9B,EAAsCmC,CAAC,EAAvC,EAA2C;AACzC,kBAAIkM,iBAAiB,GAAGrC,SAAS,CAAC7J,CAAD,CAAjC;;AACA,kBAAIkM,iBAAiB,IAAI,IAArB,IAA6BA,iBAAiB,CAAC7B,WAAnD,EAAgE;AAC9DtB,gBAAAA,YAAY,CAACgB,wBAAb,GAAwC/J,CAAxC;AACA;AACD;AACF;;AACD;AACE,kBAAImM,YAAY,GAAGtC,SAAS,CAACd,YAAY,CAACgB,wBAAd,CAA5B;AACA,gBAAEoC,YAAY,IAAI,IAAhB,IAAwBA,YAAY,CAAC9B,WAAvC,IACI9L,qBAAqB,CAAC,KAAD,EAAQ,kCAAR,CADzB,GAEI,KAAK,CAFT;AAGD;AACF;AACF;AACF,OA9B8B;AAgC/BwK,MAAAA,YAAY,EAAEA;AAhCiB,KAAjC;;AA0CA,aAASqD,UAAT,CAAoBzL,OAApB,EAA6BC,IAA7B,EAAmC;AACjC5I,MAAAA,SAAS,CACP4I,IAAI,IAAI,IADD,EAEP,sEAFO,CAAT;;AAKA,UAAID,OAAO,IAAI,IAAf,EAAqB;AACnB,eAAOC,IAAP;AACD;;AAID,UAAI1H,KAAK,CAACmG,OAAN,CAAcsB,OAAd,CAAJ,EAA4B;AAC1B,eAAOA,OAAO,CAACvC,MAAR,CAAewC,IAAf,CAAP;AACD;;AAED,UAAI1H,KAAK,CAACmG,OAAN,CAAcuB,IAAd,CAAJ,EAAyB;AACvB,eAAO,CAACD,OAAD,EAAUvC,MAAV,CAAiBwC,IAAjB,CAAP;AACD;;AAED,aAAO,CAACD,OAAD,EAAUC,IAAV,CAAP;AACD;;AAMD,QAAIyL,aAAa,GAAG,IAApB;AAMA,QAAIC,iBAAiB,GAAG,CAAxB;;AAEA,QAAIC,eAAe,GAAG,SAAlBA,eAAkB,CAASC,iBAAT,EAA4BC,kBAA5B,EAAgD;AACpE,UAAIC,gBAAgB,GAAGL,aAAvB;AACAA,MAAAA,aAAa,GAAGG,iBAAhB;;AACA,UAAIG,oBAAoB,CAACC,sBAArB,KAAgD,IAApD,EAA0D;AACxDD,QAAAA,oBAAoB,CAACC,sBAArB,CAA4CC,QAA5C,CACEH,gBADF,EAEEF,iBAFF,EAGEC,kBAHF;AAKD;AACF,KAVD;;AAYA,QAAIK,YAAY,GAAG;AAKjBC,MAAAA,uBAAuB,EAAE;AACvBnQ,QAAAA,uBAAuB,EAAE;AACvBoQ,UAAAA,OAAO,EAAE,2BADc;AAEvBC,UAAAA,QAAQ,EAAE;AAFa,SADF;AAKvB9P,QAAAA,YAAY,EAAEsM;AALS,OALR;AAsBjByD,MAAAA,wBAAwB,EAAE;AACxBtQ,QAAAA,uBAAuB,EAAE;AACvBoQ,UAAAA,OAAO,EAAE,4BADc;AAEvBC,UAAAA,QAAQ,EAAE;AAFa,SADD;AAKxB9P,QAAAA,YAAY,EAAE,CAACiM,UAAD;AALU,OAtBT;AAqCjB+D,MAAAA,iCAAiC,EAAE;AACjCvQ,QAAAA,uBAAuB,EAAE;AACvBoQ,UAAAA,OAAO,EAAE,qCADc;AAEvBC,UAAAA,QAAQ,EAAE;AAFa,SADQ;AAKjC9P,QAAAA,YAAY,EAAE,CAACkM,oBAAD;AALmB,OArClB;AAiDjB+D,MAAAA,sBAAsB,EAAE;AACtBxQ,QAAAA,uBAAuB,EAAE;AACvBoQ,UAAAA,OAAO,EAAE,0BADc;AAEvBC,UAAAA,QAAQ,EAAE;AAFa,SADH;AAKtB9P,QAAAA,YAAY,EAAEuM;AALQ,OAjDP;AA4DjB2D,MAAAA,cAAc,EAAE;AACdrQ,QAAAA,gBAAgB,EAAE,kBADJ;AAEdG,QAAAA,YAAY,EAAEsM;AAFA,OA5DC;AAgEjB6D,MAAAA,aAAa,EAAE;AACbtQ,QAAAA,gBAAgB,EAAE,iBADL;AAEbG,QAAAA,YAAY,EAAEuM;AAFD,OAhEE;AAoEjB6D,MAAAA,YAAY,EAAE;AACZvQ,QAAAA,gBAAgB,EAAE,gBADN;AAEZG,QAAAA,YAAY,EAAEwM;AAFF,OApEG;AAwEjB6D,MAAAA,gBAAgB,EAAE;AAChBxQ,QAAAA,gBAAgB,EAAE,oBADF;AAEhBG,QAAAA,YAAY,EAAEwM;AAFE,OAxED;AA4EjB8D,MAAAA,2BAA2B,EAAE;AAC3BzQ,QAAAA,gBAAgB,EAAE,+BADS;AAE3BG,QAAAA,YAAY,EAAE;AAFa,OA5EZ;AAgFjBuQ,MAAAA,cAAc,EAAE;AACd1Q,QAAAA,gBAAgB,EAAE,kBADJ;AAEdG,QAAAA,YAAY,EAAE;AAFA,OAhFC;AAoFjBwQ,MAAAA,eAAe,EAAE;AACf3Q,QAAAA,gBAAgB,EAAE,mBADH;AAEfG,QAAAA,YAAY,EAAE;AAFC,OApFA;AAwFjByQ,MAAAA,kBAAkB,EAAE;AAClB5Q,QAAAA,gBAAgB,EAAE,sBADA;AAElBG,QAAAA,YAAY,EAAE;AAFI;AAxFH,KAAnB;;AA4RA,aAAS0Q,8BAAT,CACE3L,YADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,iBAJF,EAKE;AACA,UAAIyL,kBAAkB,GAAGxE,UAAU,CAACpH,YAAD,CAAV,GACrB4K,YAAY,CAACC,uBADQ,GAErBxD,SAAS,CAACrH,YAAD,CAAT,GACE4K,YAAY,CAACM,sBADf,GAEElL,YAAY,KAAKmH,oBAAjB,GACEyD,YAAY,CAACK,iCADf,GAEEL,YAAY,CAACI,wBANrB;AASA,UAAIa,mBAAmB,GAAG,CAAC1B,aAAD,GACtBlK,UADsB,GAEtB4B,uBAAuB,CAACsI,aAAD,EAAgBlK,UAAhB,CAF3B;AAQA,UAAI6L,2BAA2B,GAAGD,mBAAmB,KAAK1B,aAA1D;AACA,UAAI4B,cAAc,GAAGnF,uBAAuB,CAACD,SAAxB,CACnBiF,kBADmB,EAEnBC,mBAFmB,EAGnB3L,WAHmB,EAInBC,iBAJmB,CAArB;AAMA4L,MAAAA,cAAc,CAAClF,YAAf,GAA8B+C,0BAA0B,CAAC/C,YAAzD;;AACA,UAAIiF,2BAAJ,EAAiC;AAC/BtI,QAAAA,sCAAsC,CAACuI,cAAD,CAAtC;AACD,OAFD,MAEO;AACLxI,QAAAA,4BAA4B,CAACwI,cAAD,CAA5B;AACD;;AACD,UAAIC,kBAAkB,GAAG/N,kCAAkC,CAAC8N,cAAD,CAA3D;;AACA,UAAI,CAACA,cAAc,CAAC5M,YAAf,EAAL,EAAoC;AAClC4M,QAAAA,cAAc,CAAC3M,WAAf,CAA2BC,OAA3B,CAAmC0M,cAAnC;AACD;;AAED,UAAI,CAACC,kBAAD,IAAuBA,kBAAkB,KAAK7B,aAAlD,EAAiE;AAC/D,eAAO,IAAP;AACD;;AACD,UAAI8B,SAAS,GAAG,KAAK,CAArB;AACA,UAAIC,UAAU,GAAGtF,uBAAuB,CAACD,SAAxB,CACfiE,YAAY,CAACY,cADE,EAEfQ,kBAFe,EAGf9L,WAHe,EAIfC,iBAJe,CAAjB;AAMA+L,MAAAA,UAAU,CAACrF,YAAX,GAA0B+C,0BAA0B,CAAC/C,YAArD;AAEApD,MAAAA,0BAA0B,CAACyI,UAAD,CAA1B;AACA,UAAI3B,kBAAkB,GAAGpM,qBAAqB,CAAC+N,UAAD,CAArB,KAAsC,IAA/D;;AACA,UAAI/B,aAAJ,EAAmB;AACjB,YAAIgC,uBAAuB,GAAGvF,uBAAuB,CAACD,SAAxB,CAC5BiE,YAAY,CAACW,2BADe,EAE5BpB,aAF4B,EAG5BjK,WAH4B,EAI5BC,iBAJ4B,CAA9B;AAMAgM,QAAAA,uBAAuB,CAACtF,YAAxB,GACE+C,0BAA0B,CAAC/C,YAD7B;AAEApD,QAAAA,0BAA0B,CAAC0I,uBAAD,CAA1B;AACA,YAAIC,YAAY,GACd,CAAC7N,aAAa,CAAC4N,uBAAD,CAAd,IACAhO,qBAAqB,CAACgO,uBAAD,CAFvB;;AAGA,YAAI,CAACA,uBAAuB,CAAChN,YAAxB,EAAL,EAA6C;AAC3CgN,UAAAA,uBAAuB,CAAC/M,WAAxB,CAAoCC,OAApC,CAA4C8M,uBAA5C;AACD;;AAED,YAAIC,YAAJ,EAAkB;AAChB,cAAIC,cAAc,GAAGzF,uBAAuB,CAACD,SAAxB,CACnBiE,YAAY,CAACc,kBADM,EAEnBvB,aAFmB,EAGnBjK,WAHmB,EAInBC,iBAJmB,CAArB;AAMAkM,UAAAA,cAAc,CAACxF,YAAf,GAA8B+C,0BAA0B,CAAC/C,YAAzD;AACApD,UAAAA,0BAA0B,CAAC4I,cAAD,CAA1B;AACAJ,UAAAA,SAAS,GAAG/B,UAAU,CAAC+B,SAAD,EAAY,CAACC,UAAD,EAAaG,cAAb,CAAZ,CAAtB;AACAhC,UAAAA,eAAe,CAAC2B,kBAAD,EAAqBzB,kBAArB,CAAf;AACD,SAXD,MAWO;AACL,cAAI+B,WAAW,GAAG1F,uBAAuB,CAACD,SAAxB,CAChBiE,YAAY,CAACa,eADG,EAEhBO,kBAFgB,EAGhB9L,WAHgB,EAIhBC,iBAJgB,CAAlB;AAMAmM,UAAAA,WAAW,CAACzF,YAAZ,GAA2B+C,0BAA0B,CAAC/C,YAAtD;AACApD,UAAAA,0BAA0B,CAAC6I,WAAD,CAA1B;AACAL,UAAAA,SAAS,GAAG/B,UAAU,CAAC+B,SAAD,EAAYK,WAAZ,CAAtB;AACD;AACF,OAvCD,MAuCO;AACLL,QAAAA,SAAS,GAAG/B,UAAU,CAAC+B,SAAD,EAAYC,UAAZ,CAAtB;AACA7B,QAAAA,eAAe,CAAC2B,kBAAD,EAAqBzB,kBAArB,CAAf;AACD;;AACD,aAAO0B,SAAP;AACD;;AAUD,aAASM,kBAAT,CAA4BvM,YAA5B,EAA0CwM,YAA1C,EAAwDtM,WAAxD,EAAqE;AACnE,aACEsM,YAAY,KAIVxM,YAAY,KAAKkH,UAAjB,IAA+B,CAAChH,WAAW,CAACuM,qBAA7C,IACErC,iBAAiB,GAAG,CAApB,IAAyBpK,YAAY,KAAKmH,oBAD5C,IAECC,UAAU,CAACpH,YAAD,CAFX,IAGCqH,SAAS,CAACrH,YAAD,CAPC,CADd;AAUD;;AASD,aAAS0M,kBAAT,CAA4BxM,WAA5B,EAAyC;AACvC,UAAI6J,OAAO,GAAG7J,WAAW,CAAC6J,OAA1B;;AACA,UAAI,CAACA,OAAD,IAAYA,OAAO,CAACpO,MAAR,KAAmB,CAAnC,EAAsC;AACpC,eAAO,IAAP;AACD;;AACD,WAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiM,OAAO,CAACpO,MAA5B,EAAoCmC,CAAC,EAArC,EAAyC;AACvC,YAAI6O,WAAW,GAAG5C,OAAO,CAACjM,CAAD,CAAzB;AACA,YAAI8F,MAAM,GAAG+I,WAAW,CAAC/I,MAAzB;;AACA,YAAIA,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKhO,SAA9B,IAA2CgO,MAAM,KAAK,CAA1D,EAA6D;AAE3D,cAAI3D,UAAU,GAAG1D,mBAAmB,CAACqH,MAAD,CAApC;;AACA,cAAItB,UAAU,CAAC6H,aAAD,EAAgBlK,UAAhB,CAAd,EAA2C;AACzC,mBAAO,KAAP;AACD;AACF;AACF;;AACD,aAAO,IAAP;AACD;;AAED,QAAIwK,oBAAoB,GAAG;AAEzBmC,MAAAA,aAAa,EAAE,yBAAW;AACxB,eAAOzC,aAAP;AACD,OAJwB;AAMzB9P,MAAAA,UAAU,EAAEuQ,YANa;AAazBzQ,MAAAA,aAAa,EAAE,uBACb6F,YADa,EAEbC,UAFa,EAGbC,WAHa,EAIbC,iBAJa,EAKb;AACA,YAAIiH,UAAU,CAACpH,YAAD,CAAd,EAA8B;AAC5BoK,UAAAA,iBAAiB,IAAI,CAArB;AACD,SAFD,MAEO,IAAI9C,QAAQ,CAACtH,YAAD,CAAZ,EAA4B;AACjC,cAAIoK,iBAAiB,IAAI,CAAzB,EAA4B;AAC1BA,YAAAA,iBAAiB,IAAI,CAArB;AACD,WAFD,MAEO;AACLvO,YAAAA,OAAO,CAACvF,KAAR,CACE,mEADF;AAGA,mBAAO,IAAP;AACD;AACF;;AAEDsT,QAAAA,0BAA0B,CAACC,gBAA3B,CAA4C7J,YAA5C,EAA0DE,WAA1D;AAEA,YAAI+L,SAAS,GAAGM,kBAAkB,CAACvM,YAAD,EAAeC,UAAf,EAA2BC,WAA3B,CAAlB,GACZyL,8BAA8B,CAC5B3L,YAD4B,EAE5BC,UAF4B,EAG5BC,WAH4B,EAI5BC,iBAJ4B,CADlB,GAOZ,IAPJ;AAkBA,YAAI0M,qBAAqB,GAAG1C,aAAa,IAAI/C,UAAU,CAACpH,YAAD,CAAvD;AACA,YAAI8M,oBAAoB,GAAG3C,aAAa,IAAI9C,SAAS,CAACrH,YAAD,CAArD;AACA,YAAI+M,mBAAmB,GAAG5C,aAAa,IAAI7C,QAAQ,CAACtH,YAAD,CAAnD;AACA,YAAIgN,gBAAgB,GAAGH,qBAAqB,GACxCjC,YAAY,CAACO,cAD2B,GAExC2B,oBAAoB,GAClBlC,YAAY,CAACQ,aADK,GAElB2B,mBAAmB,GACjBnC,YAAY,CAACS,YADI,GAEjB,IANR;;AAQA,YAAI2B,gBAAJ,EAAsB;AACpB,cAAIC,OAAO,GAAGrG,uBAAuB,CAACD,SAAxB,CACZqG,gBADY,EAEZ7C,aAFY,EAGZjK,WAHY,EAIZC,iBAJY,CAAd;AAMA8M,UAAAA,OAAO,CAACpG,YAAR,GAAuB+C,0BAA0B,CAAC/C,YAAlD;AACApD,UAAAA,0BAA0B,CAACwJ,OAAD,CAA1B;AACAhB,UAAAA,SAAS,GAAG/B,UAAU,CAAC+B,SAAD,EAAYgB,OAAZ,CAAtB;AACD;;AAED,YAAIC,oBAAoB,GACtB/C,aAAa,IAAInK,YAAY,KAAKiH,gBADpC;AAEA,YAAIkG,kBAAkB,GACpBhD,aAAa,IACb,CAAC+C,oBADD,IAEA5F,QAAQ,CAACtH,YAAD,CAFR,IAGA0M,kBAAkB,CAACxM,WAAD,CAJpB;AAKA,YAAIkN,UAAU,GAAGF,oBAAoB,GACjCtC,YAAY,CAACc,kBADoB,GAEjCyB,kBAAkB,GAChBvC,YAAY,CAACU,gBADG,GAEhB,IAJN;;AAKA,YAAI8B,UAAJ,EAAgB;AACd,cAAIC,UAAU,GAAGzG,uBAAuB,CAACD,SAAxB,CACfyG,UADe,EAEfjD,aAFe,EAGfjK,WAHe,EAIfC,iBAJe,CAAjB;AAMAkN,UAAAA,UAAU,CAACxG,YAAX,GAA0B+C,0BAA0B,CAAC/C,YAArD;AACApD,UAAAA,0BAA0B,CAAC4J,UAAD,CAA1B;AACApB,UAAAA,SAAS,GAAG/B,UAAU,CAAC+B,SAAD,EAAYoB,UAAZ,CAAtB;AACAhD,UAAAA,eAAe,CAAC,IAAD,CAAf;AACD;;AAED,eAAO4B,SAAP;AACD,OArGwB;AAuGzBvB,MAAAA,sBAAsB,EAAE,IAvGC;AAyGzB7K,MAAAA,SAAS,EAAE;AAMTyN,QAAAA,4BAA4B,EAAE,sCAAS5C,sBAAT,EAAiC;AAC7DD,UAAAA,oBAAoB,CAACC,sBAArB,GAA8CA,sBAA9C;AACD;AARQ;AAzGc,KAA3B;AAqHA,QAAI6C,0BAA0B,GAC5BxY,6BAA6B,CAACyY,wBADhC;AAEA,QAAIC,wBAAwB,GAC1B1Y,6BAA6B,CAAC2Y,sBADhC;AAEA,QAAIC,YAAY,GAAG5Y,6BAA6B,CAACsF,UAAjD;AAEA,QAAIuT,4BAA4B,GAAG;AACjCvT,MAAAA,UAAU,EAAEsT,YADqB;AAMjCxT,MAAAA,aAAa,EAAE,uBACb6F,YADa,EAEbC,UAFa,EAGbC,WAHa,EAIbC,iBAJa,EAKb;AACA,YAAIF,UAAU,IAAI,IAAlB,EAAwB;AAEtB,iBAAO,IAAP;AACD;;AACD,YAAI4N,oBAAoB,GAAGN,0BAA0B,CAACvN,YAAD,CAArD;AACA,YAAI8N,oBAAoB,GAAGL,wBAAwB,CAACzN,YAAD,CAAnD;AACAlK,QAAAA,SAAS,CACP+X,oBAAoB,IAAIC,oBADjB,EAEP,kDAFO,EAGP9N,YAHO,CAAT;AAKA,YAAI/H,KAAK,GAAGqM,cAAc,CAACqC,SAAf,CACVkH,oBAAoB,IAAIC,oBADd,EAEV7N,UAFU,EAGVC,WAHU,EAIVC,iBAJU,CAAZ;;AAMA,YAAI0N,oBAAJ,EAA0B;AACxBtK,UAAAA,4BAA4B,CAACtL,KAAD,CAA5B;AACD,SAFD,MAEO,IAAI6V,oBAAJ,EAA0B;AAC/BrK,UAAAA,0BAA0B,CAACxL,KAAD,CAA1B;AACD,SAFM,MAEA;AACL,iBAAO,IAAP;AACD;;AACD,eAAOA,KAAP;AACD;AArCgC,KAAnC;AAwCA,QAAI8V,2BAA2B,GAAG,CAChC,sBADgC,EAEhC,8BAFgC,CAAlC;AAeAlO,IAAAA,SAAS,CAACzE,sBAAV,CAAiC2S,2BAAjC;AAMAlO,IAAAA,SAAS,CAACvE,wBAAV,CAAmC;AACjCmP,MAAAA,oBAAoB,EAAEA,oBADW;AAEjCmD,MAAAA,4BAA4B,EAAEA;AAFG,KAAnC;AAKA,QAAII,aAAa,GAAG,EAApB;AACA,QAAIC,aAAa,GAAG,EAApB;;AAEA,aAASC,iBAAT,CAA2BC,QAA3B,EAAqC1O,GAArC,EAA0C;AACxCuO,MAAAA,aAAa,CAACvO,GAAD,CAAb,GAAqB0O,QAArB;AACD;;AAED,aAASC,gBAAT,CAA0B3O,GAA1B,EAA+B;AAC7B,aAAOuO,aAAa,CAACvO,GAAD,CAApB;AACA,aAAOwO,aAAa,CAACxO,GAAD,CAApB;AACD;;AAED,aAAS4O,kBAAT,CAA4B5O,GAA5B,EAAiC;AAC/B,aAAOuO,aAAa,CAACvO,GAAD,CAAb,IAAsB,IAA7B;AACD;;AAED,aAAS6O,kBAAT,CAA4B5Q,IAA5B,EAAkC;AAChC,UAAI+B,GAAG,GAAG/B,IAAI,CAACqC,SAAL,CAAewO,UAAzB;;AACA,UAAI9O,GAAG,KAAK7J,SAAZ,EAAuB;AACrB6J,QAAAA,GAAG,GAAG/B,IAAI,CAACqC,SAAL,CAAeyO,SAAf,CAAyBD,UAA/B;AACD;;AACDzY,MAAAA,SAAS,CAAC2J,GAAD,EAAM,yCAAN,CAAT;AACA,aAAOA,GAAP;AACD;;AAED,aAASgP,8BAAT,CAAwC1O,SAAxC,EAAmD;AACjD,aAAOkO,aAAa,CAAClO,SAAS,CAACwO,UAAX,CAAb,IAAuC,IAA9C;AACD;;AAED,aAASG,gBAAT,CAA0BjP,GAA1B,EAA+BE,KAA/B,EAAsC;AACpCsO,MAAAA,aAAa,CAACxO,GAAD,CAAb,GAAqBE,KAArB;AACD;;AAID,QAAIgP,WAAW,GAAG,IAAlB;AACA,QAAIC,aAAa,GAAG,IAApB;AACA,QAAIC,YAAY,GAAG,IAAnB;;AAEA,aAASC,oBAAT,CAA8BlL,MAA9B,EAAsC;AAGpC,UAAImL,gBAAgB,GAAGxS,mBAAmB,CAACqH,MAAD,CAA1C;;AACA,UAAI,CAACmL,gBAAL,EAAuB;AAErB;AACD;;AACDjZ,MAAAA,SAAS,CACP,OAAO6Y,WAAP,KAAuB,UADhB,EAEP,qFACE,8EAHK,CAAT;AAKA,UAAIhP,KAAK,GAAGrD,4BAA4B,CAACyS,gBAAgB,CAAChP,SAAlB,CAAxC;AACA4O,MAAAA,WAAW,CAACI,gBAAgB,CAAChP,SAAlB,EAA6BgP,gBAAgB,CAACpR,IAA9C,EAAoDgC,KAApD,CAAX;AACD;;AAED,aAASqP,iBAAT,GAA6B;AAC3B,aAAOJ,aAAa,KAAK,IAAlB,IAA0BC,YAAY,KAAK,IAAlD;AACD;;AAED,aAASI,oBAAT,GAAgC;AAC9B,UAAI,CAACL,aAAL,EAAoB;AAClB;AACD;;AACD,UAAIhL,MAAM,GAAGgL,aAAb;AACA,UAAIM,aAAa,GAAGL,YAApB;AACAD,MAAAA,aAAa,GAAG,IAAhB;AACAC,MAAAA,YAAY,GAAG,IAAf;AAEAC,MAAAA,oBAAoB,CAAClL,MAAD,CAApB;;AACA,UAAIsL,aAAJ,EAAmB;AACjB,aAAK,IAAIpR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoR,aAAa,CAACvT,MAAlC,EAA0CmC,CAAC,EAA3C,EAA+C;AAC7CgR,UAAAA,oBAAoB,CAACI,aAAa,CAACpR,CAAD,CAAd,CAApB;AACD;AACF;AACF;;AASD,QAAIqR,mBAAmB,GAAG,6BAAS1M,EAAT,EAAa2M,WAAb,EAA0B;AAClD,aAAO3M,EAAE,CAAC2M,WAAD,CAAT;AACD,KAFD;;AAGA,QAAIC,4BAA4B,GAAG,wCAAW,CAAE,CAAhD;;AAEA,QAAIC,UAAU,GAAG,KAAjB;;AACA,aAASC,cAAT,CAAwB9M,EAAxB,EAA4B2M,WAA5B,EAAyC;AACvC,UAAIE,UAAJ,EAAgB;AAGd,eAAO7M,EAAE,CAAC2M,WAAD,CAAT;AACD;;AACDE,MAAAA,UAAU,GAAG,IAAb;;AACA,UAAI;AACF,eAAOH,mBAAmB,CAAC1M,EAAD,EAAK2M,WAAL,CAA1B;AACD,OAFD,SAEU;AAKRE,QAAAA,UAAU,GAAG,KAAb;AACA,YAAIE,sCAAsC,GAAGR,iBAAiB,EAA9D;;AACA,YAAIQ,sCAAJ,EAA4C;AAI1CH,UAAAA,4BAA4B;;AAC5BJ,UAAAA,oBAAoB;AACrB;AACF;AACF;;AAED,aAASQ,yBAAT,CACEC,kBADF,EAEEC,sBAFF,EAGEC,2BAHF,EAIE;AACAT,MAAAA,mBAAmB,GAAGO,kBAAtB;AACAL,MAAAA,4BAA4B,GAAGO,2BAA/B;AACD;;AAQD,QAAIC,kBAAkB,GAAG,EAAzB;;AASA,QAAIC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAS/F,OAAT,EAAkBgG,OAAlB,EAA2B;AAChD,UAAI7R,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiS,OAAO,CAACpU,MAA5B,EAAoCmC,CAAC,EAArC,EAAyC;AACvCI,QAAAA,GAAG,CAACS,IAAJ,CAASoL,OAAO,CAACgG,OAAO,CAACjS,CAAD,CAAR,CAAhB;AACD;;AACD,aAAOI,GAAP;AACD,KAND;;AAmBA,QAAI8R,sBAAsB,GAAG,SAAzBA,sBAAyB,CAASjG,OAAT,EAAkBgG,OAAlB,EAA2B;AACtD,UAAIE,SAAS,GAAG,EAAhB;AAGA,UAAIC,IAAI,GAAGnG,OAAX;;AACA,WAAK,IAAIjM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiS,OAAO,CAACpU,MAA5B,EAAoCmC,CAAC,EAArC,EAAyC;AACvC,YAAIqS,KAAK,GAAGJ,OAAO,CAACjS,CAAD,CAAnB;AACAmS,QAAAA,SAAS,CAACtR,IAAV,CAAeoL,OAAO,CAACoG,KAAD,CAAtB;AACAD,QAAAA,IAAI,CAACC,KAAD,CAAJ,GAAc,IAAd;AACD;;AACD,UAAIC,MAAM,GAAG,CAAb;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACvU,MAAzB,EAAiC0U,CAAC,EAAlC,EAAsC;AACpC,YAAIC,GAAG,GAAGJ,IAAI,CAACG,CAAD,CAAd;;AACA,YAAIC,GAAG,KAAK,IAAZ,EAAkB;AAChBJ,UAAAA,IAAI,CAACE,MAAM,EAAP,CAAJ,GAAiBE,GAAjB;AACD;AACF;;AACDJ,MAAAA,IAAI,CAACvU,MAAL,GAAcyU,MAAd;AACA,aAAOH,SAAP;AACD,KAnBD;;AA+BA,aAASM,uBAAT,CAAiCC,UAAjC,EAA6CxQ,YAA7C,EAA2DyQ,gBAA3D,EAA6E;AAC3E,UAAIvQ,WAAW,GAAGuQ,gBAAgB,IAAIZ,kBAAtC;AACA,UAAInS,IAAI,GAAG2Q,kBAAkB,CAACmC,UAAD,CAA7B;AACAjB,MAAAA,cAAc,CAAC,YAAW;AACxB9O,QAAAA,yBAAyB,CACvBT,YADuB,EAEvBtC,IAFuB,EAGvBwC,WAHuB,EAIvBA,WAAW,CAAC0D,MAJW,CAAzB;AAMD,OAPa,CAAd;AAUD;;AASD,aAAS8M,YAAT,CAAsBF,UAAtB,EAAkCxQ,YAAlC,EAAgDyQ,gBAAhD,EAAkE;AAChEF,MAAAA,uBAAuB,CAACC,UAAD,EAAaxQ,YAAb,EAA2ByQ,gBAA3B,CAAvB;AACD;;AA0BD,aAASE,cAAT,CAAwBC,iBAAxB,EAA2C7G,OAA3C,EAAoD8G,cAApD,EAAoE;AAClE,UAAI/G,cAAc,GAChB8G,iBAAiB,KAAK,aAAtB,IACAA,iBAAiB,KAAK,gBADtB,GAEIZ,sBAAsB,CAACjG,OAAD,EAAU8G,cAAV,CAF1B,GAGIf,gBAAgB,CAAC/F,OAAD,EAAU8G,cAAV,CAJtB;;AAMA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGhH,cAAc,CAACnO,MAArC,EAA6CmV,EAAE,EAA/C,EAAmD;AACjD,YAAI9I,KAAK,GAAG8B,cAAc,CAACgH,EAAD,CAA1B;AAGA9I,QAAAA,KAAK,CAAC8B,cAAN,GAAuBA,cAAvB;AACA9B,QAAAA,KAAK,CAAC+B,OAAN,GAAgBA,OAAhB;AACA,YAAI7J,WAAW,GAAG8H,KAAlB;AACA,YAAIwI,UAAU,GAAG,IAAjB;AACA,YAAI5M,MAAM,GAAG1D,WAAW,CAAC0D,MAAzB;;AACA,YAAIA,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKhO,SAAlC,EAA6C;AAC3C,cAAIgO,MAAM,GAAG,CAAb,EAAgB;AACd;AACEvH,cAAAA,qBAAqB,CACnB,KADmB,EAEnB,wDAFmB,CAArB;AAID;AACF,WAPD,MAOO;AACLmU,YAAAA,UAAU,GAAG5M,MAAb;AACD;AACF;;AAED2M,QAAAA,uBAAuB,CAACC,UAAD,EAAaI,iBAAb,EAAgC1Q,WAAhC,CAAvB;AACD;AACF;;AAED,QAAI6Q,uBAAuB,GAAG9L,MAAM,CAAC+L,MAAP,CAAc;AAC1ClR,MAAAA,WAAW,EAAEA,WAD6B;AAE1CmR,MAAAA,iBAAiB,EAAElW,uBAFuB;AAG1CwV,MAAAA,uBAAuB,EAAEA,uBAHiB;AAI1CG,MAAAA,YAAY,EAAEA,YAJ4B;AAK1CC,MAAAA,cAAc,EAAEA;AAL0B,KAAd,CAA9B;AASA,QAAIO,iCAAiC,GAAG;AACtCvG,MAAAA,QAAQ,EAAE,kBAASwG,IAAT,EAAeC,EAAf,EAAmBC,oBAAnB,EAAyC;AACjD,YAAID,EAAE,KAAK,IAAX,EAAiB;AACf,cAAI3R,GAAG,GAAG2R,EAAE,CAACrR,SAAH,CAAawO,UAAvB;AACAvZ,UAAAA,SAAS,CAACsc,cAAV,CAAyB7R,GAAzB,EAA8B4R,oBAA9B;AACD,SAHD,MAGO;AACLrc,UAAAA,SAAS,CAACuc,gBAAV;AACD;AACF;AARqC,KAAxC;AAeAtc,IAAAA,eAAe,CAACuc,QAAhB,CAAyBT,uBAAzB;AAEAtU,IAAAA,gBAAgB,CACdgS,8BADc,EAEdJ,kBAFc,EAGdC,kBAHc,CAAhB;AAMA7D,IAAAA,oBAAoB,CAAC5K,SAArB,CAA+ByN,4BAA/B,CACE4D,iCADF;;AAoBA,aAASO,KAAT,CAAeC,GAAf,EAAoB;AAClB,aAAOA,GAAG,CAACC,mBAAX;AACD;;AAED,aAAS/L,GAAT,CAAa8L,GAAb,EAAkBE,KAAlB,EAAyB;AACvBF,MAAAA,GAAG,CAACC,mBAAJ,GAA0BC,KAA1B;AACD;;AAED,QAAIC,oBAAoB,GACtB3c,KAAK,CAAC4c,kDADR;AAKA,QAAIC,SAAS,GAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAAvD;AAEA,QAAIC,kBAAkB,GAAGH,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,eAAX,CAAH,GAAiC,MAAnE;AACA,QAAIE,iBAAiB,GAAGJ,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,cAAX,CAAH,GAAgC,MAAjE;AACA,QAAIG,mBAAmB,GAAGL,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,gBAAX,CAAH,GAAkC,MAArE;AACA,QAAII,sBAAsB,GAAGN,SAAS,GAClCC,MAAM,CAACC,GAAP,CAAW,mBAAX,CADkC,GAElC,MAFJ;AAGA,QAAIK,mBAAmB,GAAGP,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,gBAAX,CAAH,GAAkC,MAArE;AACA,QAAIM,mBAAmB,GAAGR,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,gBAAX,CAAH,GAAkC,MAArE;AACA,QAAIO,kBAAkB,GAAGT,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,eAAX,CAAH,GAAiC,MAAnE;AACA,QAAIQ,qBAAqB,GAAGV,SAAS,GAAGC,MAAM,CAACC,GAAP,CAAW,kBAAX,CAAH,GAAoC,MAAzE;AACA,QAAIS,sBAAsB,GAAGX,SAAS,GAClCC,MAAM,CAACC,GAAP,CAAW,mBAAX,CADkC,GAElC,MAFJ;AAGA,QAAIU,sBAAsB,GAAGZ,SAAS,GAClCC,MAAM,CAACC,GAAP,CAAW,mBAAX,CADkC,GAElC,MAFJ;AAIA,QAAIW,qBAAqB,GAAG,OAAOZ,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACa,QAAnE;AACA,QAAIC,oBAAoB,GAAG,YAA3B;;AAEA,aAASC,aAAT,CAAuBC,aAAvB,EAAsC;AACpC,UAAIA,aAAa,KAAK,IAAlB,IAA0B,OAAOA,aAAP,KAAyB,QAAvD,EAAiE;AAC/D,eAAO,IAAP;AACD;;AACD,UAAIC,aAAa,GACdL,qBAAqB,IAAII,aAAa,CAACJ,qBAAD,CAAvC,IACAI,aAAa,CAACF,oBAAD,CAFf;;AAGA,UAAI,OAAOG,aAAP,KAAyB,UAA7B,EAAyC;AACvC,eAAOA,aAAP;AACD;;AACD,aAAO,IAAP;AACD;;AAED,QAAIC,OAAO,GAAG,CAAd;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,QAAQ,GAAG,CAAf;;AAEA,aAASC,6BAAT,CAAuCC,QAAvC,EAAiD;AAC/C,aAAOA,QAAQ,CAACC,YAAhB;AACD;;AAED,aAASC,sBAAT,CAAgCF,QAAhC,EAA0C;AACxC,aAAOA,QAAQ,CAACG,YAAT,KAA0BN,QAA1B,GAAqCG,QAAQ,CAACC,YAA9C,GAA6D,IAApE;AACD;;AAED,aAASG,gBAAT,CAA0B/V,IAA1B,EAAgC;AAC9B,UAAIA,IAAI,IAAI,IAAZ,EAAkB;AAEhB,eAAO,IAAP;AACD;;AACD;AACE,YAAI,OAAOA,IAAI,CAAC8B,GAAZ,KAAoB,QAAxB,EAAkC;AAChCpD,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,0DACE,sDAHiB,CAArB;AAKD;AACF;;AACD,UAAI,OAAOsB,IAAP,KAAgB,UAApB,EAAgC;AAC9B,eAAOA,IAAI,CAACgW,WAAL,IAAoBhW,IAAI,CAACjH,IAAzB,IAAiC,IAAxC;AACD;;AACD,UAAI,OAAOiH,IAAP,KAAgB,QAApB,EAA8B;AAC5B,eAAOA,IAAP;AACD;;AACD,cAAQA,IAAR;AACE,aAAK8U,qBAAL;AACE,iBAAO,WAAP;;AACF,aAAKL,mBAAL;AACE,iBAAO,UAAP;;AACF,aAAKD,iBAAL;AACE,iBAAO,QAAP;;AACF,aAAKG,mBAAL;AACE,iBAAO,UAAP;;AACF,aAAKD,sBAAL;AACE,iBAAO,YAAP;;AACF,aAAKM,sBAAL;AACE,iBAAO,aAAP;AAZJ;;AAcA,UAAI,OAAOhV,IAAP,KAAgB,QAApB,EAA8B;AAC5B,gBAAQA,IAAI,CAACiW,QAAb;AACE,eAAKpB,kBAAL;AACE,mBAAO,kBAAP;;AACF,eAAKD,mBAAL;AACE,mBAAO,kBAAP;;AACF,eAAKG,sBAAL;AACE,gBAAImB,QAAQ,GAAGlW,IAAI,CAACmW,MAApB;AACA,gBAAIC,YAAY,GAAGF,QAAQ,CAACF,WAAT,IAAwBE,QAAQ,CAACnd,IAAjC,IAAyC,EAA5D;AACA,mBAAOqd,YAAY,KAAK,EAAjB,GACH,gBAAgBA,YAAhB,GAA+B,GAD5B,GAEH,YAFJ;AARJ;;AAYA,YAAI,OAAOpW,IAAI,CAACqW,IAAZ,KAAqB,UAAzB,EAAqC;AACnC,cAAIV,QAAQ,GAAG3V,IAAf;AACA,cAAIsW,gBAAgB,GAAGT,sBAAsB,CAACF,QAAD,CAA7C;;AACA,cAAIW,gBAAJ,EAAsB;AACpB,mBAAOP,gBAAgB,CAACO,gBAAD,CAAvB;AACD;AACF;AACF;;AACD,aAAO,IAAP;AACD;;AAGD,QAAIC,QAAQ,GAAsB,CAAlC;AACA,QAAIC,aAAa,GAAiB,CAAlC;AAGA,QAAIC,SAAS,GAAqB,CAAlC;AACA,QAAIC,MAAM,GAAwB,CAAlC;AACA,QAAIC,kBAAkB,GAAY,CAAlC;AACA,QAAIC,QAAQ,GAAsB,CAAlC;AACA,QAAIC,YAAY,GAAkB,EAAlC;AACA,QAAIC,QAAQ,GAAsB,EAAlC;AACA,QAAIC,UAAU,GAAoB,EAAlC;AACA,QAAIC,GAAG,GAA2B,GAAlC;AACA,QAAIC,QAAQ,GAAsB,GAAlC;AAGA,QAAIC,mBAAmB,GAAW,GAAlC;AAGA,QAAIC,cAAc,GAAgB,GAAlC;AAEA,QAAIC,UAAU,GAAoB,GAAlC;AACA,QAAIC,aAAa,GAAiB,IAAlC;AAEA,QAAIC,mBAAmB,GAAGpD,oBAAoB,CAACqD,iBAA/C;AAEA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,OAAO,GAAG,CAAd;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,aAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AACjC,UAAIC,IAAI,GAAGD,KAAX;;AACA,UAAI,CAACA,KAAK,CAAClT,SAAX,EAAsB;AAGpB,YAAI,CAACmT,IAAI,CAACC,SAAL,GAAiBrB,SAAlB,MAAiCF,QAArC,EAA+C;AAC7C,iBAAOiB,QAAP;AACD;;AACD,eAAOK,IAAI,CAAC5T,MAAZ,EAAoB;AAClB4T,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;;AACA,cAAI,CAAC4T,IAAI,CAACC,SAAL,GAAiBrB,SAAlB,MAAiCF,QAArC,EAA+C;AAC7C,mBAAOiB,QAAP;AACD;AACF;AACF,OAZD,MAYO;AACL,eAAOK,IAAI,CAAC5T,MAAZ,EAAoB;AAClB4T,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;AACF;;AACD,UAAI4T,IAAI,CAAC/V,GAAL,KAAasB,QAAjB,EAA2B;AAGzB,eAAOqU,OAAP;AACD;;AAGD,aAAOC,SAAP;AACD;;AAED,aAASK,cAAT,CAAwBH,KAAxB,EAA+B;AAC7B,aAAOD,kBAAkB,CAACC,KAAD,CAAlB,KAA8BH,OAArC;AACD;;AAED,aAASO,SAAT,CAAmBC,SAAnB,EAA8B;AAC5B;AACE,YAAIC,KAAK,GAAGZ,mBAAmB,CAACxW,OAAhC;;AACA,YACEoX,KAAK,KAAK,IAAV,KACCA,KAAK,CAACpW,GAAN,KAAcmB,cAAd,IAAgCiV,KAAK,CAACpW,GAAN,KAAcoB,kBAD/C,CADF,EAGE;AACA,cAAIiV,UAAU,GAAGD,KAAjB;AACA,cAAIrP,QAAQ,GAAGsP,UAAU,CAAC/V,SAA1B;AACA,WAACyG,QAAQ,CAACuP,wBAAV,GACI1Z,qBAAqB,CACnB,KADmB,EAEnB,6DACE,mEADF,GAEE,oEAFF,GAGE,iEAHF,GAIE,6BANiB,EAOnBqX,gBAAgB,CAACoC,UAAU,CAACnY,IAAZ,CAAhB,IAAqC,aAPlB,CADzB,GAUI,KAAK,CAVT;AAWA6I,UAAAA,QAAQ,CAACuP,wBAAT,GAAoC,IAApC;AACD;AACF;AAED,UAAIR,KAAK,GAAG9D,KAAK,CAACmE,SAAD,CAAjB;;AACA,UAAI,CAACL,KAAL,EAAY;AACV,eAAO,KAAP;AACD;;AACD,aAAOD,kBAAkB,CAACC,KAAD,CAAlB,KAA8BH,OAArC;AACD;;AAED,aAASY,eAAT,CAAyBT,KAAzB,EAAgC;AAC9Bzf,MAAAA,SAAS,CACPwf,kBAAkB,CAACC,KAAD,CAAlB,KAA8BH,OADvB,EAEP,gDAFO,CAAT;AAID;;AAED,aAASa,6BAAT,CAAuCV,KAAvC,EAA8C;AAC5C,UAAIlT,SAAS,GAAGkT,KAAK,CAAClT,SAAtB;;AACA,UAAI,CAACA,SAAL,EAAgB;AAEd,YAAI6T,KAAK,GAAGZ,kBAAkB,CAACC,KAAD,CAA9B;AACAzf,QAAAA,SAAS,CACPogB,KAAK,KAAKb,SADH,EAEP,gDAFO,CAAT;;AAIA,YAAIa,KAAK,KAAKf,QAAd,EAAwB;AACtB,iBAAO,IAAP;AACD;;AACD,eAAOI,KAAP;AACD;;AAID,UAAIvf,CAAC,GAAGuf,KAAR;AACA,UAAItf,CAAC,GAAGoM,SAAR;;AACA,aAAO,IAAP,EAAa;AACX,YAAI8T,OAAO,GAAGngB,CAAC,CAAC4L,MAAhB;AACA,YAAIwU,OAAO,GAAGD,OAAO,GAAGA,OAAO,CAAC9T,SAAX,GAAuB,IAA5C;;AACA,YAAI,CAAC8T,OAAD,IAAY,CAACC,OAAjB,EAA0B;AAExB;AACD;;AAKD,YAAID,OAAO,CAACE,KAAR,KAAkBD,OAAO,CAACC,KAA9B,EAAqC;AACnC,cAAIA,KAAK,GAAGF,OAAO,CAACE,KAApB;;AACA,iBAAOA,KAAP,EAAc;AACZ,gBAAIA,KAAK,KAAKrgB,CAAd,EAAiB;AAEfggB,cAAAA,eAAe,CAACG,OAAD,CAAf;AACA,qBAAOZ,KAAP;AACD;;AACD,gBAAIc,KAAK,KAAKpgB,CAAd,EAAiB;AAEf+f,cAAAA,eAAe,CAACG,OAAD,CAAf;AACA,qBAAO9T,SAAP;AACD;;AACDgU,YAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AAGDxgB,UAAAA,SAAS,CAAC,KAAD,EAAQ,gDAAR,CAAT;AACD;;AAED,YAAIE,CAAC,CAAC4L,MAAF,KAAa3L,CAAC,CAAC2L,MAAnB,EAA2B;AAKzB5L,UAAAA,CAAC,GAAGmgB,OAAJ;AACAlgB,UAAAA,CAAC,GAAGmgB,OAAJ;AACD,SAPD,MAOO;AAML,cAAIG,YAAY,GAAG,KAAnB;AACA,cAAIC,MAAM,GAAGL,OAAO,CAACE,KAArB;;AACA,iBAAOG,MAAP,EAAe;AACb,gBAAIA,MAAM,KAAKxgB,CAAf,EAAkB;AAChBugB,cAAAA,YAAY,GAAG,IAAf;AACAvgB,cAAAA,CAAC,GAAGmgB,OAAJ;AACAlgB,cAAAA,CAAC,GAAGmgB,OAAJ;AACA;AACD;;AACD,gBAAII,MAAM,KAAKvgB,CAAf,EAAkB;AAChBsgB,cAAAA,YAAY,GAAG,IAAf;AACAtgB,cAAAA,CAAC,GAAGkgB,OAAJ;AACAngB,cAAAA,CAAC,GAAGogB,OAAJ;AACA;AACD;;AACDI,YAAAA,MAAM,GAAGA,MAAM,CAACF,OAAhB;AACD;;AACD,cAAI,CAACC,YAAL,EAAmB;AAEjBC,YAAAA,MAAM,GAAGJ,OAAO,CAACC,KAAjB;;AACA,mBAAOG,MAAP,EAAe;AACb,kBAAIA,MAAM,KAAKxgB,CAAf,EAAkB;AAChBugB,gBAAAA,YAAY,GAAG,IAAf;AACAvgB,gBAAAA,CAAC,GAAGogB,OAAJ;AACAngB,gBAAAA,CAAC,GAAGkgB,OAAJ;AACA;AACD;;AACD,kBAAIK,MAAM,KAAKvgB,CAAf,EAAkB;AAChBsgB,gBAAAA,YAAY,GAAG,IAAf;AACAtgB,gBAAAA,CAAC,GAAGmgB,OAAJ;AACApgB,gBAAAA,CAAC,GAAGmgB,OAAJ;AACA;AACD;;AACDK,cAAAA,MAAM,GAAGA,MAAM,CAACF,OAAhB;AACD;;AACDxgB,YAAAA,SAAS,CACPygB,YADO,EAEP,oEACE,+DAHK,CAAT;AAKD;AACF;;AAEDzgB,QAAAA,SAAS,CACPE,CAAC,CAACqM,SAAF,KAAgBpM,CADT,EAEP,6DACE,sEAHK,CAAT;AAKD;;AAGDH,MAAAA,SAAS,CACPE,CAAC,CAACyJ,GAAF,KAAUsB,QADH,EAEP,gDAFO,CAAT;;AAIA,UAAI/K,CAAC,CAAC+J,SAAF,CAAYtB,OAAZ,KAAwBzI,CAA5B,EAA+B;AAE7B,eAAOuf,KAAP;AACD;;AAED,aAAOlT,SAAP;AACD;;AAED,aAASoU,oBAAT,CAA8BC,MAA9B,EAAsC;AACpC,UAAIC,aAAa,GAAGV,6BAA6B,CAACS,MAAD,CAAjD;;AACA,UAAI,CAACC,aAAL,EAAoB;AAClB,eAAO,IAAP;AACD;;AAGD,UAAInB,IAAI,GAAGmB,aAAX;;AACA,aAAO,IAAP,EAAa;AACX,YAAInB,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAA/C,EAAyD;AACvD,iBAAOsU,IAAP;AACD,SAFD,MAEO,IAAIA,IAAI,CAACa,KAAT,EAAgB;AACrBb,UAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,UAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;;AACD,YAAIb,IAAI,KAAKmB,aAAb,EAA4B;AAC1B,iBAAO,IAAP;AACD;;AACD,eAAO,CAACnB,IAAI,CAACc,OAAb,EAAsB;AACpB,cAAI,CAACd,IAAI,CAAC5T,MAAN,IAAgB4T,IAAI,CAAC5T,MAAL,KAAgB+U,aAApC,EAAmD;AACjD,mBAAO,IAAP;AACD;;AACDnB,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;;AAGD,aAAO,IAAP;AACD;;AAGD,QAAIM,WAAW,GAAG,EAAlB;AAYA,QAAIC,WAAW,GAAG,IAAlB;AACA,QAAIC,eAAe,GAAG,CAAtB;;AAEA,aAASC,aAAT,CAAuBC,QAAvB,EAAiCC,QAAjC,EAA2C;AACzC,UAAI,OAAOA,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AAErD,eAAO,IAAP;AACD,OAHD,MAGO;AAEL,eAAO7hB,UAAU,CAAC4hB,QAAD,EAAWC,QAAX,CAAjB;AACD;AACF;;AAED,aAASC,iCAAT,CACEC,aADF,EAEE3B,IAFF,EAGE4B,eAHF,EAIE;AACA,UAAIpgB,KAAK,CAACmG,OAAN,CAAcqY,IAAd,CAAJ,EAAyB;AACvB,YAAI1X,CAAC,GAAG0X,IAAI,CAAC7Z,MAAb;;AACA,eAAOmC,CAAC,MAAMgZ,eAAe,GAAG,CAAhC,EAAmC;AACjCI,UAAAA,iCAAiC,CAC/BC,aAD+B,EAE/B3B,IAAI,CAAC1X,CAAD,CAF2B,EAG/BsZ,eAH+B,CAAjC;AAKD;AACF,OATD,MASO,IAAI5B,IAAI,IAAIsB,eAAe,GAAG,CAA9B,EAAiC;AACtC,YAAIO,GAAG,GAAG7B,IAAV;;AACA,aAAK,IAAI8B,OAAT,IAAoBT,WAApB,EAAiC;AAC/B,cAAI,CAACA,WAAW,CAACS,OAAD,CAAhB,EAA2B;AACzB;AACD;;AACD,cAAIL,QAAQ,GAAGI,GAAG,CAACC,OAAD,CAAlB;;AACA,cAAIL,QAAQ,KAAKrhB,SAAjB,EAA4B;AAC1B;AACD;;AAED,cAAI2hB,eAAe,GAAGH,eAAe,CAACE,OAAD,CAArC;;AACA,cAAI,CAACC,eAAL,EAAsB;AACpB;AACD;;AAED,cAAI,OAAON,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,YAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,cAAI,OAAOA,QAAP,KAAoB,WAAxB,EAAqC;AACnCA,YAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,cAAI,OAAOM,eAAP,KAA2B,QAA/B,EAAyC;AAEvCJ,YAAAA,aAAa,CAACG,OAAD,CAAb,GAAyBL,QAAzB;AACD,WAHD,MAGO,IACL,OAAOM,eAAe,CAACC,IAAvB,KAAgC,UAAhC,IACA,OAAOD,eAAe,CAACE,OAAvB,KAAmC,UAF9B,EAGL;AAEA,gBAAIC,SAAS,GACX,OAAOH,eAAe,CAACE,OAAvB,KAAmC,UAAnC,GACIF,eAAe,CAACE,OAAhB,CAAwBR,QAAxB,CADJ,GAEIA,QAHN;AAIAE,YAAAA,aAAa,CAACG,OAAD,CAAb,GAAyBI,SAAzB;AACD;;AACDb,UAAAA,WAAW,CAACS,OAAD,CAAX,GAAuB,KAAvB;AACAR,UAAAA,eAAe;AAChB;AACF;AACF;;AAED,aAASa,uBAAT,CACER,aADF,EAEES,SAFF,EAGEC,SAHF,EAIET,eAJF,EAKE;AACA,UAAIU,SAAS,GACXF,SAAS,CAACjc,MAAV,GAAmBkc,SAAS,CAAClc,MAA7B,GAAsCic,SAAS,CAACjc,MAAhD,GAAyDkc,SAAS,CAAClc,MADrE;AAEA,UAAImC,CAAC,GAAG,KAAK,CAAb;;AACA,WAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGga,SAAhB,EAA2Bha,CAAC,EAA5B,EAAgC;AAG9BqZ,QAAAA,aAAa,GAAGY,kBAAkB,CAChCZ,aADgC,EAEhCS,SAAS,CAAC9Z,CAAD,CAFuB,EAGhC+Z,SAAS,CAAC/Z,CAAD,CAHuB,EAIhCsZ,eAJgC,CAAlC;AAMD;;AACD,aAAOtZ,CAAC,GAAG8Z,SAAS,CAACjc,MAArB,EAA6BmC,CAAC,EAA9B,EAAkC;AAEhCqZ,QAAAA,aAAa,GAAGa,mBAAmB,CACjCb,aADiC,EAEjCS,SAAS,CAAC9Z,CAAD,CAFwB,EAGjCsZ,eAHiC,CAAnC;AAKD;;AACD,aAAOtZ,CAAC,GAAG+Z,SAAS,CAAClc,MAArB,EAA6BmC,CAAC,EAA9B,EAAkC;AAEhCqZ,QAAAA,aAAa,GAAGc,iBAAiB,CAC/Bd,aAD+B,EAE/BU,SAAS,CAAC/Z,CAAD,CAFsB,EAG/BsZ,eAH+B,CAAjC;AAKD;;AACD,aAAOD,aAAP;AACD;;AAED,aAASY,kBAAT,CACEZ,aADF,EAEEH,QAFF,EAGEC,QAHF,EAIEG,eAJF,EAKE;AACA,UAAI,CAACD,aAAD,IAAkBH,QAAQ,KAAKC,QAAnC,EAA6C;AAG3C,eAAOE,aAAP;AACD;;AAED,UAAI,CAACH,QAAD,IAAa,CAACC,QAAlB,EAA4B;AAC1B,YAAIA,QAAJ,EAAc;AACZ,iBAAOgB,iBAAiB,CAACd,aAAD,EAAgBF,QAAhB,EAA0BG,eAA1B,CAAxB;AACD;;AACD,YAAIJ,QAAJ,EAAc;AACZ,iBAAOgB,mBAAmB,CAACb,aAAD,EAAgBH,QAAhB,EAA0BI,eAA1B,CAA1B;AACD;;AACD,eAAOD,aAAP;AACD;;AAED,UAAI,CAACngB,KAAK,CAACmG,OAAN,CAAc6Z,QAAd,CAAD,IAA4B,CAAChgB,KAAK,CAACmG,OAAN,CAAc8Z,QAAd,CAAjC,EAA0D;AAExD,eAAOiB,cAAc,CAACf,aAAD,EAAgBH,QAAhB,EAA0BC,QAA1B,EAAoCG,eAApC,CAArB;AACD;;AAED,UAAIpgB,KAAK,CAACmG,OAAN,CAAc6Z,QAAd,KAA2BhgB,KAAK,CAACmG,OAAN,CAAc8Z,QAAd,CAA/B,EAAwD;AAEtD,eAAOU,uBAAuB,CAC5BR,aAD4B,EAE5BH,QAF4B,EAG5BC,QAH4B,EAI5BG,eAJ4B,CAA9B;AAMD;;AAED,UAAIpgB,KAAK,CAACmG,OAAN,CAAc6Z,QAAd,CAAJ,EAA6B;AAC3B,eAAOkB,cAAc,CACnBf,aADmB,EAGnB9hB,YAAY,CAAC2hB,QAAD,CAHO,EAKnBC,QALmB,EAMnBG,eANmB,CAArB;AAQD;;AAED,aAAOc,cAAc,CACnBf,aADmB,EAEnBH,QAFmB,EAInB3hB,YAAY,CAAC4hB,QAAD,CAJO,EAKnBG,eALmB,CAArB;AAOD;;AAOD,aAASa,iBAAT,CAA2Bd,aAA3B,EAA0CF,QAA1C,EAAoDG,eAApD,EAAqE;AACnE,UAAI,CAACH,QAAL,EAAe;AACb,eAAOE,aAAP;AACD;;AAED,UAAI,CAACngB,KAAK,CAACmG,OAAN,CAAc8Z,QAAd,CAAL,EAA8B;AAE5B,eAAOkB,aAAa,CAAChB,aAAD,EAAgBF,QAAhB,EAA0BG,eAA1B,CAApB;AACD;;AAED,WAAK,IAAItZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmZ,QAAQ,CAACtb,MAA7B,EAAqCmC,CAAC,EAAtC,EAA0C;AAExCqZ,QAAAA,aAAa,GAAGc,iBAAiB,CAC/Bd,aAD+B,EAE/BF,QAAQ,CAACnZ,CAAD,CAFuB,EAG/BsZ,eAH+B,CAAjC;AAKD;;AAED,aAAOD,aAAP;AACD;;AAMD,aAASa,mBAAT,CAA6Bb,aAA7B,EAA4CH,QAA5C,EAAsDI,eAAtD,EAAuE;AACrE,UAAI,CAACJ,QAAL,EAAe;AACb,eAAOG,aAAP;AACD;;AAED,UAAI,CAACngB,KAAK,CAACmG,OAAN,CAAc6Z,QAAd,CAAL,EAA8B;AAE5B,eAAOoB,eAAe,CAACjB,aAAD,EAAgBH,QAAhB,EAA0BI,eAA1B,CAAtB;AACD;;AAED,WAAK,IAAItZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkZ,QAAQ,CAACrb,MAA7B,EAAqCmC,CAAC,EAAtC,EAA0C;AAExCqZ,QAAAA,aAAa,GAAGa,mBAAmB,CACjCb,aADiC,EAEjCH,QAAQ,CAAClZ,CAAD,CAFyB,EAGjCsZ,eAHiC,CAAnC;AAKD;;AACD,aAAOD,aAAP;AACD;;AAQD,aAASe,cAAT,CAAwBf,aAAxB,EAAuCkB,SAAvC,EAAkDC,SAAlD,EAA6DlB,eAA7D,EAA8E;AAC5E,UAAIG,eAAe,GAAG,KAAK,CAA3B;AACA,UAAIN,QAAQ,GAAG,KAAK,CAApB;AACA,UAAID,QAAQ,GAAG,KAAK,CAApB;;AAEA,WAAK,IAAIM,OAAT,IAAoBgB,SAApB,EAA+B;AAC7Bf,QAAAA,eAAe,GAAGH,eAAe,CAACE,OAAD,CAAjC;;AACA,YAAI,CAACC,eAAL,EAAsB;AACpB;AACD;;AAEDP,QAAAA,QAAQ,GAAGqB,SAAS,CAACf,OAAD,CAApB;AACAL,QAAAA,QAAQ,GAAGqB,SAAS,CAAChB,OAAD,CAApB;;AAIA,YAAI,OAAOL,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,UAAAA,QAAQ,GAAG,IAAX;;AAGA,cAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,YAAAA,QAAQ,GAAG,IAAX;AACD;AACF;;AAID,YAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;AACnCA,UAAAA,QAAQ,GAAG,IAAX;;AACA,cAAI,OAAOD,QAAP,KAAoB,WAAxB,EAAqC;AACnCA,YAAAA,QAAQ,GAAG,IAAX;AACD;AACF;;AAED,YAAIH,WAAJ,EAAiB;AACfA,UAAAA,WAAW,CAACS,OAAD,CAAX,GAAuB,KAAvB;AACD;;AAED,YAAIH,aAAa,IAAIA,aAAa,CAACG,OAAD,CAAb,KAA2B1hB,SAAhD,EAA2D;AAOzD,cAAI,OAAO2hB,eAAP,KAA2B,QAA/B,EAAyC;AAEvCJ,YAAAA,aAAa,CAACG,OAAD,CAAb,GAAyBL,QAAzB;AACD,WAHD,MAGO,IACL,OAAOM,eAAe,CAACC,IAAvB,KAAgC,UAAhC,IACA,OAAOD,eAAe,CAACE,OAAvB,KAAmC,UAF9B,EAGL;AAEA,gBAAIC,SAAS,GACX,OAAOH,eAAe,CAACE,OAAvB,KAAmC,UAAnC,GACIF,eAAe,CAACE,OAAhB,CAAwBR,QAAxB,CADJ,GAEIA,QAHN;AAIAE,YAAAA,aAAa,CAACG,OAAD,CAAb,GAAyBI,SAAzB;AACD;;AACD;AACD;;AAED,YAAIV,QAAQ,KAAKC,QAAjB,EAA2B;AACzB;AACD;;AAGD,YAAI,OAAOM,eAAP,KAA2B,QAA/B,EAAyC;AAEvC,cAAIR,aAAa,CAACC,QAAD,EAAWC,QAAX,CAAjB,EAAuC;AAErC,aAACE,aAAa,KAAKA,aAAa,GAAG,EAArB,CAAd,EAAwCG,OAAxC,IAAmDL,QAAnD;AACD;AACF,SAND,MAMO,IACL,OAAOM,eAAe,CAACC,IAAvB,KAAgC,UAAhC,IACA,OAAOD,eAAe,CAACE,OAAvB,KAAmC,UAF9B,EAGL;AAEA,cAAIc,YAAY,GACdvB,QAAQ,KAAKphB,SAAb,KACC,OAAO2hB,eAAe,CAACC,IAAvB,KAAgC,UAAhC,GACGD,eAAe,CAACC,IAAhB,CAAqBR,QAArB,EAA+BC,QAA/B,CADH,GAEGF,aAAa,CAACC,QAAD,EAAWC,QAAX,CAHjB,CADF;;AAKA,cAAIsB,YAAJ,EAAkB;AAChB,gBAAIC,UAAU,GACZ,OAAOjB,eAAe,CAACE,OAAvB,KAAmC,UAAnC,GACIF,eAAe,CAACE,OAAhB,CAAwBR,QAAxB,CADJ,GAEIA,QAHN;;AAIA,aAACE,aAAa,KAAKA,aAAa,GAAG,EAArB,CAAd,EAAwCG,OAAxC,IAAmDkB,UAAnD;AACD;AACF,SAjBM,MAiBA;AAEL3B,UAAAA,WAAW,GAAG,IAAd;AACAC,UAAAA,eAAe,GAAG,CAAlB;AAGAK,UAAAA,aAAa,GAAGY,kBAAkB,CAChCZ,aADgC,EAEhCH,QAFgC,EAGhCC,QAHgC,EAIhCM,eAJgC,CAAlC;;AAMA,cAAIT,eAAe,GAAG,CAAlB,IAAuBK,aAA3B,EAA0C;AACxCD,YAAAA,iCAAiC,CAC/BC,aAD+B,EAE/BF,QAF+B,EAG/BM,eAH+B,CAAjC;AAKAV,YAAAA,WAAW,GAAG,IAAd;AACD;AACF;AACF;;AAKD,WAAK,IAAI4B,QAAT,IAAqBJ,SAArB,EAAgC;AAC9B,YAAIC,SAAS,CAACG,QAAD,CAAT,KAAwB7iB,SAA5B,EAAuC;AACrC;AACD;;AACD2hB,QAAAA,eAAe,GAAGH,eAAe,CAACqB,QAAD,CAAjC;;AACA,YAAI,CAAClB,eAAL,EAAsB;AACpB;AACD;;AAED,YAAIJ,aAAa,IAAIA,aAAa,CAACsB,QAAD,CAAb,KAA4B7iB,SAAjD,EAA4D;AAE1D;AACD;;AAEDohB,QAAAA,QAAQ,GAAGqB,SAAS,CAACI,QAAD,CAApB;;AACA,YAAIzB,QAAQ,KAAKphB,SAAjB,EAA4B;AAC1B;AACD;;AAED,YACE,OAAO2hB,eAAP,KAA2B,QAA3B,IACA,OAAOA,eAAe,CAACC,IAAvB,KAAgC,UADhC,IAEA,OAAOD,eAAe,CAACE,OAAvB,KAAmC,UAHrC,EAIE;AAGA,WAACN,aAAa,KAAKA,aAAa,GAAG,EAArB,CAAd,EAAwCsB,QAAxC,IAAoD,IAApD;;AACA,cAAI,CAAC5B,WAAL,EAAkB;AAChBA,YAAAA,WAAW,GAAG,EAAd;AACD;;AACD,cAAI,CAACA,WAAW,CAAC4B,QAAD,CAAhB,EAA4B;AAC1B5B,YAAAA,WAAW,CAAC4B,QAAD,CAAX,GAAwB,IAAxB;AACA3B,YAAAA,eAAe;AAChB;AACF,SAfD,MAeO;AAILK,UAAAA,aAAa,GAAGa,mBAAmB,CACjCb,aADiC,EAEjCH,QAFiC,EAGjCO,eAHiC,CAAnC;AAKD;AACF;;AACD,aAAOJ,aAAP;AACD;;AAKD,aAASgB,aAAT,CAAuBhB,aAAvB,EAAsCxX,KAAtC,EAA6CyX,eAA7C,EAA8D;AAE5D,aAAOc,cAAc,CAACf,aAAD,EAAgBP,WAAhB,EAA6BjX,KAA7B,EAAoCyX,eAApC,CAArB;AACD;;AAMD,aAASgB,eAAT,CAAyBjB,aAAzB,EAAwCkB,SAAxC,EAAmDjB,eAAnD,EAAoE;AAElE,aAAOc,cAAc,CAACf,aAAD,EAAgBkB,SAAhB,EAA2BzB,WAA3B,EAAwCQ,eAAxC,CAArB;AACD;;AAED,aAASsB,MAAT,CAAgB/Y,KAAhB,EAAuByX,eAAvB,EAAwC;AACtC,aAAOe,aAAa,CAClB,IADkB,EAElBxY,KAFkB,EAGlByX,eAHkB,CAApB;AAKD;;AAED,aAASI,IAAT,CAAca,SAAd,EAAyBC,SAAzB,EAAoClB,eAApC,EAAqD;AACnD,aAAOc,cAAc,CACnB,IADmB,EAEnBG,SAFmB,EAGnBC,SAHmB,EAInBlB,eAJmB,CAArB;AAMD;;AAMD,aAASuB,iCAAT,CAA2C7hB,OAA3C,EAAoD8hB,QAApD,EAA8D;AAC5D,aAAO,YAAW;AAChB,YAAI,CAACA,QAAL,EAAe;AACb,iBAAOhjB,SAAP;AACD;;AAKD,YAAI,OAAOkB,OAAO,CAAC+hB,WAAf,KAA+B,SAAnC,EAA8C;AAC5C,cAAI,CAAC/hB,OAAO,CAAC+hB,WAAb,EAA0B;AACxB,mBAAOjjB,SAAP;AACD;AACF;;AAcD,eAAOgjB,QAAQ,CAACvhB,KAAT,CAAeP,OAAf,EAAwBM,SAAxB,CAAP;AACD,OA3BD;AA4BD;;AAED,aAAS0hB,iBAAT,CAA2BlD,SAA3B,EAAsCjW,KAAtC,EAA6C;AAC3C,UAAIA,KAAK,CAACoZ,MAAN,KAAiBnjB,SAArB,EAAgC;AAC9B,YAAIigB,KAAK,GAAGD,SAAS,CAACoD,MAAV,IAAoB,IAAhC;AACA,YAAItiB,IAAI,GAAGkf,SAAS,CAACxW,WAAV,CAAsBuU,WAAjC;AACA,YAAIsF,GAAG,GACL,8CACAviB,IADA,GAEA,SAFA,GAGA,8BAJF;;AAKA,YAAImf,KAAK,IAAIA,KAAK,CAACzW,WAAf,IAA8ByW,KAAK,CAACzW,WAAN,CAAkBuU,WAApD,EAAiE;AAC/DsF,UAAAA,GAAG,IACD,oBACApD,KAAK,CAACzW,WAAN,CAAkBuU,WADlB,GAEA,WAFA,GAGA,aAJF;AAKD;;AACD,cAAM,IAAI9d,KAAJ,CAAUojB,GAAV,CAAN;AACD;AACF;;AAED,aAASC,iBAAT,CAA2BvZ,KAA3B,EAAkCyX,eAAlC,EAAmD;AACjD,WAAK,IAAI1F,GAAT,IAAgB0F,eAAe,CAAC+B,KAAhC,EAAuC;AACrC,YAAI,EAAE/B,eAAe,CAAC1F,GAAD,CAAf,IAAwB/R,KAAK,CAAC+R,GAAD,CAAL,KAAe9b,SAAzC,CAAJ,EAAyD;AACvDiG,UAAAA,OAAO,CAACvF,KAAR,CACE,kCACEob,GADF,GAEE,0BAFF,GAGE,oCAHF,GAIE,mBAJF,GAKEA,GALF,GAME,YAPJ;AASD;AACF;AACF;;AAED,aAAS0H,eAAT,CAAyB5S,QAAzB,EAAmC6S,WAAnC,EAAgD;AAC9C,UAAI,EAAE7S,QAAQ,YAAY6S,WAAtB,CAAJ,EAAwC;AACtC,cAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;AACF;;AAWD,QAAIC,6BAA6B,GAAI,YAAW;AAC9C,eAASA,6BAAT,CAAuC9Z,GAAvC,EAA4C+Z,UAA5C,EAAwD;AACtDJ,QAAAA,eAAe,CAAC,IAAD,EAAOG,6BAAP,CAAf;;AAEA,aAAKhL,UAAL,GAAkB9O,GAAlB;AACA,aAAKga,SAAL,GAAiB,EAAjB;AACA,aAAKD,UAAL,GAAkBA,UAAlB;AACD;;AAEDD,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwCyiB,IAAxC,GAA+C,SAASA,IAAT,GAAgB;AAC7DpkB,QAAAA,cAAc,CAACqkB,aAAf,CAA6B,KAAKpL,UAAlC;AACD,OAFD;;AAIAgL,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwC2iB,KAAxC,GAAgD,SAASA,KAAT,GAAiB;AAC/DtkB,QAAAA,cAAc,CAACukB,cAAf,CAA8B,KAAKtL,UAAnC;AACD,OAFD;;AAIAgL,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwC6iB,OAAxC,GAAkD,SAASA,OAAT,CAAiBlB,QAAjB,EAA2B;AAC3E5jB,QAAAA,SAAS,CAAC8kB,OAAV,CACE,KAAKvL,UADP,EAEEoK,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,OALD;;AAOAW,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwC8iB,eAAxC,GAA0D,SAASA,eAAT,CACxDnB,QADwD,EAExD;AACA5jB,QAAAA,SAAS,CAAC+kB,eAAV,CACE,KAAKxL,UADP,EAEEoK,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,OAPD;;AASAW,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwC+iB,aAAxC,GAAwD,SAASA,aAAT,CACtDC,oBADsD,EAEtDC,SAFsD,EAGtDC,MAHsD,EAItD;AACAnlB,QAAAA,SAAS,CAACglB,aAAV,CACE,KAAKzL,UADP,EAEE0L,oBAFF,EAGEtB,iCAAiC,CAAC,IAAD,EAAOwB,MAAP,CAHnC,EAIExB,iCAAiC,CAAC,IAAD,EAAOuB,SAAP,CAJnC;AAMD,OAXD;;AAaAX,MAAAA,6BAA6B,CAACtiB,SAA9B,CAAwCmjB,cAAxC,GAAyD,SAASA,cAAT,CACvDC,WADuD,EAEvD;AACA;AACEnB,UAAAA,iBAAiB,CAACmB,WAAD,EAAc,KAAKb,UAAL,CAAgBpC,eAA9B,CAAjB;AACD;AAED,YAAID,aAAa,GAAGuB,MAAM,CAAC2B,WAAD,EAAc,KAAKb,UAAL,CAAgBpC,eAA9B,CAA1B;;AAKA,YAAID,aAAa,IAAI,IAArB,EAA2B;AACzBniB,UAAAA,SAAS,CAACslB,UAAV,CACE,KAAK/L,UADP,EAEE,KAAKiL,UAAL,CAAgBe,eAFlB,EAGEpD,aAHF;AAKD;AACF,OAnBD;;AAqBA,aAAOoC,6BAAP;AACD,KApEmC,EAApC;;AAsEA,QAAIiB,uBAAuB,GACzB,OAAOC,WAAP,KAAuB,QAAvB,IAAmC,OAAOA,WAAW,CAACvW,GAAnB,KAA2B,UADhE;AAGA,QAAIwW,KAAK,GAAGF,uBAAuB,GAC/B,YAAW;AACT,aAAOC,WAAW,CAACvW,GAAZ,EAAP;AACD,KAH8B,GAI/B,YAAW;AACT,aAAOD,IAAI,CAACC,GAAL,EAAP;AACD,KANL;AAQA,QAAIyW,iBAAiB,GAAG,IAAxB;AACA,QAAIC,aAAa,GAAG,CAApB;AAEA,QAAIC,mBAAmB,GAAG;AACxBC,MAAAA,aAAa,EAAE,yBAAW;AACxB,eAAOF,aAAa,GAAGF,KAAK,EAA5B;AACD,OAHuB;AAIxBK,MAAAA,UAAU,EAAE;AAJY,KAA1B;;AAOA,aAASC,kBAAT,GAA8B;AAK5BJ,MAAAA,aAAa,GAAGF,KAAK,KAAK,CAA1B;AAEA,UAAI9B,QAAQ,GAAG+B,iBAAf;AACAA,MAAAA,iBAAiB,GAAG,IAApB;;AACA,UAAI/B,QAAQ,KAAK,IAAjB,EAAuB;AACrBA,QAAAA,QAAQ,CAACiC,mBAAD,CAAR;AACD;AACF;;AAKD,aAASI,0BAAT,CAAoCrC,QAApC,EAA8CsC,OAA9C,EAAuD;AAErDP,MAAAA,iBAAiB,GAAG/B,QAApB;AACA,UAAIuC,SAAS,GAAGC,UAAU,CAACJ,kBAAD,EAAqB,CAArB,CAA1B;AACA,aAAOG,SAAP;AACD;;AAED,aAASE,wBAAT,CAAkCC,UAAlC,EAA8C;AAC5CX,MAAAA,iBAAiB,GAAG,IAApB;AACAY,MAAAA,YAAY,CAACD,UAAD,CAAZ;AACD;;AAKD,aAASE,IAAT,GAAgB;AACd1lB,MAAAA,SAAS,CACP,KADO,EAEP,wDACE,iDADF,GAEE,uBAJK,CAAT;AAMD;;AAGD,QAAI2lB,mBAAmB,GAAG,KAA1B;AACA,QAAIC,aAAa,GAAGF,IAApB;AACA,QAAIG,uBAAuB,GAAGH,IAA9B;AACA,QAAII,8BAA8B,GAAGJ,IAArC;AACA,QAAIK,yBAAyB,GAAGL,IAAhC;AACA,QAAIM,wBAAwB,GAAGN,IAA/B;;AAKA,aAASO,MAAT,GAAkB;AAChBjmB,MAAAA,SAAS,CACP,KADO,EAEP,qDACE,iDADF,GAEE,uBAJK,CAAT;AAMD;;AAGD,QAAIkmB,iBAAiB,GAAG,KAAxB;AACA,QAAIC,kBAAkB,GAAGF,MAAzB;AACA,QAAIG,sBAAsB,GAAGH,MAA7B;AACA,QAAII,wBAAwB,GAAGJ,MAA/B;AACA,QAAIK,uBAAuB,GAAGL,MAA9B;AACA,QAAIM,eAAe,GAAGN,MAAtB;AACA,QAAIO,mBAAmB,GAAGP,MAA1B;AACA,QAAIQ,wCAAwC,GAAGR,MAA/C;AACA,QAAIS,+BAA+B,GAAGT,MAAtC;AACA,QAAIU,8BAA8B,GAAGV,MAArC;AACA,QAAIW,qBAAqB,GAAGX,MAA5B;AACA,QAAIY,qCAAqC,GAAGZ,MAA5C;AACA,QAAIa,yCAAyC,GAAGb,MAAhD;AACA,QAAIc,4BAA4B,GAAGd,MAAnC;AACA,QAAIe,gCAAgC,GAAGf,MAAvC;AAKA,QAAIgB,aAAa,GAAG,EAApB;AACA;AACE9X,MAAAA,MAAM,CAAC+L,MAAP,CAAc+L,aAAd;AACD;AAKD,QAAIC,YAAY,GAAG,CAAnB;;AACA,aAASC,WAAT,GAAuB;AACrB,UAAIxd,GAAG,GAAGud,YAAV;;AACA,UAAIvd,GAAG,GAAG,EAAN,KAAa,CAAjB,EAAoB;AAClBA,QAAAA,GAAG,IAAI,CAAP;AACD;;AACDud,MAAAA,YAAY,GAAGvd,GAAG,GAAG,CAArB;AACA,aAAOA,GAAP;AACD;;AAED,aAASyd,2BAAT,CAAqC1H,IAArC,EAA2C;AACzC,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAE5BpH,QAAAA,gBAAgB,CAACoH,IAAD,CAAhB;AACD,OAHD,MAGO;AACLpH,QAAAA,gBAAgB,CAACoH,IAAI,CAACjH,UAAN,CAAhB;;AAEAiH,QAAAA,IAAI,CAACiE,SAAL,CAAeza,OAAf,CAAuBke,2BAAvB;AACD;AACF;;AAED,aAASC,kBAAT,CAA4BC,cAA5B,EAA4C/G,KAA5C,EAAmD;AACjD+G,MAAAA,cAAc,CAAC3D,SAAf,CAAyB9a,IAAzB,CAA8B0X,KAA9B;AACD;;AAED,aAASgH,cAAT,CACE1f,IADF,EAEEgC,KAFF,EAGE2d,qBAHF,EAIEC,WAJF,EAKEC,sBALF,EAME;AACA,UAAI/d,GAAG,GAAGwd,WAAW,EAArB;AACA,UAAIzD,UAAU,GAAGzkB,6BAA6B,CAAC8Q,GAA9B,CAAkClI,IAAlC,CAAjB;AAEA;AACE,aAAK,IAAI+T,GAAT,IAAgB8H,UAAU,CAACpC,eAA3B,EAA4C;AAC1C,cAAIzX,KAAK,CAACtH,cAAN,CAAqBqZ,GAArB,CAAJ,EAA+B;AAC7Bvc,YAAAA,iCAAiC,CAACwK,KAAK,CAAC+R,GAAD,CAAN,CAAjC;AACD;AACF;AACF;AAED5b,MAAAA,SAAS,CACP6H,IAAI,KAAK,SAAT,IAAsB,CAAC4f,WAAW,CAACE,eAD5B,EAEP,6DAFO,CAAT;AAKA,UAAItG,aAAa,GAAGuB,MAAM,CAAC/Y,KAAD,EAAQ6Z,UAAU,CAACpC,eAAnB,CAA1B;AAEApiB,MAAAA,SAAS,CAAC0oB,UAAV,CACEje,GADF,EAEE+Z,UAAU,CAACe,eAFb,EAGE+C,qBAHF,EAIEnG,aAJF;AAOA,UAAIvB,SAAS,GAAG,IAAI2D,6BAAJ,CAAkC9Z,GAAlC,EAAuC+Z,UAAvC,CAAhB;AAEAtL,MAAAA,iBAAiB,CAACsP,sBAAD,EAAyB/d,GAAzB,CAAjB;AACAiP,MAAAA,gBAAgB,CAACjP,GAAD,EAAME,KAAN,CAAhB;AAIA,aAAOiW,SAAP;AACD;;AAED,aAAS+H,kBAAT,CACEC,IADF,EAEEN,qBAFF,EAGEC,WAHF,EAIEC,sBAJF,EAKE;AACA1nB,MAAAA,SAAS,CACPynB,WAAW,CAACE,eADL,EAEP,0DAFO,CAAT;AAKA,UAAIhe,GAAG,GAAGwd,WAAW,EAArB;AAEAjoB,MAAAA,SAAS,CAAC0oB,UAAV,CACEje,GADF,EAEE,YAFF,EAGE6d,qBAHF,EAIE;AAAEM,QAAAA,IAAI,EAAEA;AAAR,OAJF;AAOA1P,MAAAA,iBAAiB,CAACsP,sBAAD,EAAyB/d,GAAzB,CAAjB;AAEA,aAAOA,GAAP;AACD;;AAED,aAASoe,uBAAT,CACET,cADF,EAEEzf,IAFF,EAGEgC,KAHF,EAIE2d,qBAJF,EAKEC,WALF,EAME;AAEA,UAAIH,cAAc,CAAC3D,SAAf,CAAyB9d,MAAzB,KAAoC,CAAxC,EAA2C;AACzC,eAAO,KAAP;AACD;;AAID,UAAImiB,UAAU,GAAGV,cAAc,CAAC3D,SAAf,CAAyBzd,GAAzB,CAA6B,UAASqa,KAAT,EAAgB;AAC5D,eAAO,OAAOA,KAAP,KAAiB,QAAjB,GACHA,KADG,GAEHA,KAAK,CAAC9H,UAFV;AAGD,OAJgB,CAAjB;;AAMAvZ,MAAAA,SAAS,CAAC+oB,WAAV,CACEX,cAAc,CAAC7O,UADjB,EAEEuP,UAFF;AAKA,aAAO,KAAP;AACD;;AAED,aAASE,kBAAT,CAA4BV,qBAA5B,EAAmD;AACjD,aAAO;AAAEG,QAAAA,eAAe,EAAE;AAAnB,OAAP;AACD;;AAED,aAASQ,mBAAT,CAA6BC,iBAA7B,EAAgDvgB,IAAhD,EAAsD2f,qBAAtD,EAA6E;AAC3E,UAAIa,mBAAmB,GAAGD,iBAAiB,CAACT,eAA5C;AACA,UAAIA,eAAe,GACjB9f,IAAI,KAAK,kBAAT,IACAA,IAAI,KAAK,2BADT,IAEAA,IAAI,KAAK,4BAFT,IAGAA,IAAI,KAAK,SAHT,IAIAA,IAAI,KAAK,gBALX;;AAOA,UAAIwgB,mBAAmB,KAAKV,eAA5B,EAA6C;AAC3C,eAAO;AAAEA,UAAAA,eAAe,EAAEA;AAAnB,SAAP;AACD,OAFD,MAEO;AACL,eAAOS,iBAAP;AACD;AACF;;AAED,aAASE,iBAAT,CAA2B5X,QAA3B,EAAqC;AACnC,aAAOA,QAAP;AACD;;AAED,aAAS6X,gBAAT,CAA0BC,aAA1B,EAAyC,CAExC;;AAED,aAASC,aAAT,CACE/X,QADF,EAEE7I,IAFF,EAGE6gB,QAHF,EAIEC,QAJF,EAKEnB,qBALF,EAMEC,WANF,EAOE;AACA,aAAOR,aAAP;AACD;;AAED,aAAS2B,gBAAT,CAA0BJ,aAA1B,EAAyC,CAExC;;AAED,QAAIpa,GAAG,GAAGwW,KAAV;AACA,QAAIiE,iBAAiB,GAAG,IAAxB;AACA,QAAIC,wBAAwB,GAAG3D,0BAA/B;AACA,QAAI4D,sBAAsB,GAAGxD,wBAA7B;AAEA,QAAIyD,eAAe,GAAG1D,UAAtB;AACA,QAAI2D,aAAa,GAAGxD,YAApB;AACA,QAAIyD,SAAS,GAAG,CAAC,CAAjB;;AAEA,aAASC,yBAAT,CAAmCthB,IAAnC,EAAyCgC,KAAzC,EAAgD;AAC9C,aAAO,KAAP;AACD;;AAED,aAASuf,oBAAT,CAA8BvhB,IAA9B,EAAoCgC,KAApC,EAA2C;AAOzC,aAAO,KAAP;AACD;;AAMD,QAAIwf,gBAAgB,GAAG,IAAvB;;AAEA,aAASC,WAAT,CAAqBhC,cAArB,EAAqC/G,KAArC,EAA4C;AAC1C,UAAIgJ,QAAQ,GAAG,OAAOhJ,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAAC9H,UAAzD;AACA,UAAI+Q,QAAQ,GAAGlC,cAAc,CAAC3D,SAA9B;AACA,UAAItJ,KAAK,GAAGmP,QAAQ,CAACrlB,OAAT,CAAiBoc,KAAjB,CAAZ;;AAEA,UAAIlG,KAAK,IAAI,CAAb,EAAgB;AACdmP,QAAAA,QAAQ,CAACC,MAAT,CAAgBpP,KAAhB,EAAuB,CAAvB;AACAmP,QAAAA,QAAQ,CAAC3gB,IAAT,CAAc0X,KAAd;AAEArhB,QAAAA,SAAS,CAACwqB,cAAV,CACEpC,cAAc,CAAC7O,UADjB,EAEE,CAAC4B,KAAD,CAFF,EAGE,CAACmP,QAAQ,CAAC3jB,MAAT,GAAkB,CAAnB,CAHF,EAIE,EAJF,EAKE,EALF,EAME,EANF;AAQD,OAZD,MAYO;AACL2jB,QAAAA,QAAQ,CAAC3gB,IAAT,CAAc0X,KAAd;AAEArhB,QAAAA,SAAS,CAACwqB,cAAV,CACEpC,cAAc,CAAC7O,UADjB,EAEE,EAFF,EAGE,EAHF,EAIE,CAAC8Q,QAAD,CAJF,EAKE,CAACC,QAAQ,CAAC3jB,MAAT,GAAkB,CAAnB,CALF,EAME,EANF;AAQD;AACF;;AAED,aAAS8jB,sBAAT,CAAgCrC,cAAhC,EAAgD/G,KAAhD,EAAuD;AACrD,UAAIgJ,QAAQ,GAAG,OAAOhJ,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAAC9H,UAAzD;AACAvZ,MAAAA,SAAS,CAAC+oB,WAAV,CACEX,cADF,EAEE,CAACiC,QAAD,CAFF;AAID;;AAED,aAASK,gBAAT,CAA0BC,YAA1B,EAAwCC,OAAxC,EAAiDC,OAAjD,EAA0D;AACxD7qB,MAAAA,SAAS,CAACslB,UAAV,CACEqF,YADF,EAEE,YAFF,EAGE;AAAE/B,QAAAA,IAAI,EAAEiC;AAAR,OAHF;AAKD;;AAED,aAASC,YAAT,CACEtZ,QADF,EAEEuZ,iBAFF,EAGEpiB,IAHF,EAIE6gB,QAJF,EAKEC,QALF,EAMEjB,sBANF,EAOE;AACA,UAAIhE,UAAU,GAAGhT,QAAQ,CAACgT,UAA1B;AAEA9K,MAAAA,gBAAgB,CAAClI,QAAQ,CAAC+H,UAAV,EAAsBkQ,QAAtB,CAAhB;AAEA,UAAItH,aAAa,GAAGK,IAAI,CAACgH,QAAD,EAAWC,QAAX,EAAqBjF,UAAU,CAACpC,eAAhC,CAAxB;;AAKA,UAAID,aAAa,IAAI,IAArB,EAA2B;AACzBniB,QAAAA,SAAS,CAACslB,UAAV,CACE9T,QAAQ,CAAC+H,UADX,EAEEiL,UAAU,CAACe,eAFb,EAGEpD,aAHF;AAKD;AACF;;AAED,aAAS6I,YAAT,CAAsB5C,cAAtB,EAAsC/G,KAAtC,EAA6C4J,WAA7C,EAA0D;AACxD,UAAIX,QAAQ,GAAGlC,cAAc,CAAC3D,SAA9B;AACA,UAAItJ,KAAK,GAAGmP,QAAQ,CAACrlB,OAAT,CAAiBoc,KAAjB,CAAZ;;AAGA,UAAIlG,KAAK,IAAI,CAAb,EAAgB;AACdmP,QAAAA,QAAQ,CAACC,MAAT,CAAgBpP,KAAhB,EAAuB,CAAvB;AACA,YAAI+P,gBAAgB,GAAGZ,QAAQ,CAACrlB,OAAT,CAAiBgmB,WAAjB,CAAvB;AACAX,QAAAA,QAAQ,CAACC,MAAT,CAAgBW,gBAAhB,EAAkC,CAAlC,EAAqC7J,KAArC;AAEArhB,QAAAA,SAAS,CAACwqB,cAAV,CACEpC,cAAc,CAAC7O,UADjB,EAEE,CAAC4B,KAAD,CAFF,EAGE,CAAC+P,gBAAD,CAHF,EAIE,EAJF,EAKE,EALF,EAME,EANF;AAQD,OAbD,MAaO;AACL,YAAIC,iBAAiB,GAAGb,QAAQ,CAACrlB,OAAT,CAAiBgmB,WAAjB,CAAxB;;AACAX,QAAAA,QAAQ,CAACC,MAAT,CAAgBY,iBAAhB,EAAmC,CAAnC,EAAsC9J,KAAtC;AAEA,YAAIgJ,QAAQ,GAAG,OAAOhJ,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAAC9H,UAAzD;AAEAvZ,QAAAA,SAAS,CAACwqB,cAAV,CACEpC,cAAc,CAAC7O,UADjB,EAEE,EAFF,EAGE,EAHF,EAIE,CAAC8Q,QAAD,CAJF,EAKE,CAACc,iBAAD,CALF,EAME,EANF;AAQD;AACF;;AAED,aAASC,uBAAT,CAAiChD,cAAjC,EAAiD/G,KAAjD,EAAwD4J,WAAxD,EAAqE;AAKnEnqB,MAAAA,SAAS,CACP,OAAOsnB,cAAP,KAA0B,QADnB,EAEP,mDAFO,CAAT;AAID;;AAED,aAASiD,WAAT,CAAqBjD,cAArB,EAAqC/G,KAArC,EAA4C;AAC1C6G,MAAAA,2BAA2B,CAAC7G,KAAD,CAA3B;AACA,UAAIiJ,QAAQ,GAAGlC,cAAc,CAAC3D,SAA9B;AACA,UAAItJ,KAAK,GAAGmP,QAAQ,CAACrlB,OAAT,CAAiBoc,KAAjB,CAAZ;AAEAiJ,MAAAA,QAAQ,CAACC,MAAT,CAAgBpP,KAAhB,EAAuB,CAAvB;AAEAnb,MAAAA,SAAS,CAACwqB,cAAV,CACEpC,cAAc,CAAC7O,UADjB,EAEE,EAFF,EAGE,EAHF,EAIE,EAJF,EAKE,EALF,EAME,CAAC4B,KAAD,CANF;AAQD;;AAED,aAASmQ,wBAAT,CAAkClD,cAAlC,EAAkD/G,KAAlD,EAAyD;AACvD6G,MAAAA,2BAA2B,CAAC7G,KAAD,CAA3B;AACArhB,MAAAA,SAAS,CAACwqB,cAAV,CACEpC,cADF,EAEE,EAFF,EAGE,EAHF,EAIE,EAJF,EAKE,EALF,EAME,CAAC,CAAD,CANF;AAQD;;AAED,aAASmD,gBAAT,CAA0B/Z,QAA1B,EAAoC,CAEnC;;AAED,QAAIga,eAAe,GAAG,aAAtB;;AAEA,QAAIC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAS/pB,IAAT,EAAegqB,MAAf,EAAuBC,SAAvB,EAAkC;AAC7D,UAAIC,UAAU,GAAG,EAAjB;;AACA,UAAIF,MAAJ,EAAY;AACV,YAAI/d,IAAI,GAAG+d,MAAM,CAACG,QAAlB;AACA,YAAIA,QAAQ,GAAGle,IAAI,CAAClM,OAAL,CAAa+pB,eAAb,EAA8B,EAA9B,CAAf;AACA;AAGE,cAAI,WAAWM,IAAX,CAAgBD,QAAhB,CAAJ,EAA+B;AAC7B,gBAAIE,KAAK,GAAGpe,IAAI,CAACoe,KAAL,CAAWP,eAAX,CAAZ;;AACA,gBAAIO,KAAJ,EAAW;AACT,kBAAIC,eAAe,GAAGD,KAAK,CAAC,CAAD,CAA3B;;AACA,kBAAIC,eAAJ,EAAqB;AACnB,oBAAIC,UAAU,GAAGD,eAAe,CAACvqB,OAAhB,CAAwB+pB,eAAxB,EAAyC,EAAzC,CAAjB;AACAK,gBAAAA,QAAQ,GAAGI,UAAU,GAAG,GAAb,GAAmBJ,QAA9B;AACD;AACF;AACF;AACF;AACDD,QAAAA,UAAU,GAAG,UAAUC,QAAV,GAAqB,GAArB,GAA2BH,MAAM,CAACQ,UAAlC,GAA+C,GAA5D;AACD,OAlBD,MAkBO,IAAIP,SAAJ,EAAe;AACpBC,QAAAA,UAAU,GAAG,kBAAkBD,SAAlB,GAA8B,GAA3C;AACD;;AACD,aAAO,eAAejqB,IAAI,IAAI,SAAvB,IAAoCkqB,UAA3C;AACD,KAxBD;;AA0BA,QAAIO,sBAAsB,GAAGtP,oBAAoB,CAACsP,sBAAlD;;AAEA,aAASC,aAAT,CAAuB7L,KAAvB,EAA8B;AAC5B,cAAQA,KAAK,CAAC9V,GAAd;AACE,aAAKqB,sBAAL;AACA,aAAKJ,mBAAL;AACA,aAAKC,uBAAL;AACA,aAAKC,cAAL;AACA,aAAKC,kBAAL;AACA,aAAKI,aAAL;AACA,aAAKG,IAAL;AACE,cAAIyU,KAAK,GAAGN,KAAK,CAAC8L,WAAlB;AACA,cAAIX,MAAM,GAAGnL,KAAK,CAAC+L,YAAnB;AACA,cAAI5qB,IAAI,GAAGgd,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAA3B;AACA,cAAIgjB,SAAS,GAAG,IAAhB;;AACA,cAAI9K,KAAJ,EAAW;AACT8K,YAAAA,SAAS,GAAGjN,gBAAgB,CAACmC,KAAK,CAAClY,IAAP,CAA5B;AACD;;AACD,iBAAO8iB,sBAAsB,CAAC/pB,IAAD,EAAOgqB,MAAP,EAAeC,SAAf,CAA7B;;AACF;AACE,iBAAO,EAAP;AAjBJ;AAmBD;;AAED,aAASY,2BAAT,CAAqCC,cAArC,EAAqD;AACnD,UAAIC,IAAI,GAAG,EAAX;AACA,UAAIjM,IAAI,GAAGgM,cAAX;;AACA,SAAG;AACDC,QAAAA,IAAI,IAAIL,aAAa,CAAC5L,IAAD,CAArB;AACAA,QAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD,OAHD,QAGS4T,IAHT;;AAIA,aAAOiM,IAAP;AACD;;AAED,QAAIhjB,OAAO,GAAG,IAAd;AACA,QAAIsE,KAAK,GAAG,IAAZ;;AAEA,aAAS2e,mCAAT,GAA+C;AAC7C;AACE,YAAIjjB,OAAO,KAAK,IAAhB,EAAsB;AACpB,iBAAO,IAAP;AACD;;AACD,YAAIoX,KAAK,GAAGpX,OAAO,CAAC4iB,WAApB;;AACA,YAAIxL,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,WAAvC,EAAoD;AAClD,iBAAOnC,gBAAgB,CAACmC,KAAK,CAAClY,IAAP,CAAvB;AACD;AACF;AACD,aAAO,IAAP;AACD;;AAED,aAASgkB,yBAAT,GAAqC;AACnC;AACE,YAAIljB,OAAO,KAAK,IAAhB,EAAsB;AACpB,iBAAO,EAAP;AACD;;AAGD,eAAO8iB,2BAA2B,CAAC9iB,OAAD,CAAlC;AACD;AACD,aAAO,EAAP;AACD;;AAED,aAASmjB,iBAAT,GAA6B;AAC3B;AACET,QAAAA,sBAAsB,CAACU,eAAvB,GAAyC,IAAzC;AACApjB,QAAAA,OAAO,GAAG,IAAV;AACAsE,QAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AAED,aAAS+e,eAAT,CAAyBvM,KAAzB,EAAgC;AAC9B;AACE4L,QAAAA,sBAAsB,CAACU,eAAvB,GAAyCF,yBAAzC;AACAljB,QAAAA,OAAO,GAAG8W,KAAV;AACAxS,QAAAA,KAAK,GAAG,IAAR;AACD;AACF;;AAED,aAASgf,eAAT,CAAyBC,cAAzB,EAAyC;AACvC;AACEjf,QAAAA,KAAK,GAAGif,cAAR;AACD;AACF;;AAED,QAAIC,2BAA2B,GAAG,KAAlC;AACA,QAAIC,wCAAwC,GAAG,KAA/C;AACA,QAAIC,8BAA8B,GAAG,KAArC;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,mBAAmB,GAAG,IAA1B;AACA,QAAIC,+CAA+C,GAAG,IAAtD;AACA,QAAIC,6BAA6B,GAAG,KAApC;AACA,QAAIC,yBAAyB,GAAG,KAAhC;AACA,QAAIC,mBAAmB,GAAG,IAA1B;AACA,QAAIC,uBAAuB,GAAG,IAA9B;AAMA,QAAIC,UAAU,GAAG,QAAjB;AACA,QAAIC,YAAY,GAAG,QAAnB;AACA,QAAIC,kBAAkB,GACpB,OAAOpI,WAAP,KAAuB,WAAvB,IACA,OAAOA,WAAW,CAACqI,IAAnB,KAA4B,UAD5B,IAEA,OAAOrI,WAAW,CAACsI,UAAnB,KAAkC,UAFlC,IAGA,OAAOtI,WAAW,CAACX,OAAnB,KAA+B,UAH/B,IAIA,OAAOW,WAAW,CAACuI,aAAnB,KAAqC,UALvC;AASA,QAAIC,YAAY,GAAG,IAAnB;AAKA,QAAIC,YAAY,GAAG,IAAnB;AACA,QAAIC,iBAAiB,GAAG,IAAxB;AAIA,QAAIC,YAAY,GAAG,KAAnB;AACA,QAAIC,iCAAiC,GAAG,KAAxC;AACA,QAAIC,gCAAgC,GAAG,KAAvC;AACA,QAAIC,4BAA4B,GAAG,CAAnC;AACA,QAAIC,0BAA0B,GAAG,CAAjC;AACA,QAAIC,oBAAoB,GAAG,KAA3B;AAGA,QAAIC,qBAAqB,GAAG,IAAIC,GAAJ,EAA5B;;AAEA,QAAIC,cAAc,GAAG,SAAjBA,cAAiB,CAASC,QAAT,EAAmB;AACtC,aAAOlB,UAAU,GAAG,GAAb,GAAmBkB,QAA1B;AACD,KAFD;;AAIA,QAAIC,WAAW,GAAG,SAAdA,WAAc,CAASC,KAAT,EAAgBC,OAAhB,EAAyB;AACzC,UAAIC,MAAM,GAAGD,OAAO,GAAGpB,YAAY,GAAG,GAAlB,GAAwBD,UAAU,GAAG,GAAzD;AACA,UAAIuB,MAAM,GAAGF,OAAO,GAAG,eAAeA,OAAlB,GAA4B,EAAhD;AACA,aAAO,KAAKC,MAAL,GAAcF,KAAd,GAAsBG,MAA7B;AACD,KAJD;;AAMA,QAAIC,SAAS,GAAG,SAAZA,SAAY,CAASN,QAAT,EAAmB;AACjCpJ,MAAAA,WAAW,CAACqI,IAAZ,CAAiBc,cAAc,CAACC,QAAD,CAA/B;AACD,KAFD;;AAIA,QAAIO,SAAS,GAAG,SAAZA,SAAY,CAASP,QAAT,EAAmB;AACjCpJ,MAAAA,WAAW,CAACsI,UAAZ,CAAuBa,cAAc,CAACC,QAAD,CAArC;AACD,KAFD;;AAIA,QAAIQ,OAAO,GAAG,SAAVA,OAAU,CAASN,KAAT,EAAgBF,QAAhB,EAA0BG,OAA1B,EAAmC;AAC/C,UAAIM,iBAAiB,GAAGV,cAAc,CAACC,QAAD,CAAtC;AACA,UAAIU,cAAc,GAAGT,WAAW,CAACC,KAAD,EAAQC,OAAR,CAAhC;;AACA,UAAI;AACFvJ,QAAAA,WAAW,CAACX,OAAZ,CAAoByK,cAApB,EAAoCD,iBAApC;AACD,OAFD,CAEE,OAAOE,GAAP,EAAY,CAAE;;AAMhB/J,MAAAA,WAAW,CAACsI,UAAZ,CAAuBuB,iBAAvB;AACA7J,MAAAA,WAAW,CAACuI,aAAZ,CAA0BuB,cAA1B;AACD,KAbD;;AAeA,QAAIE,gBAAgB,GAAG,SAAnBA,gBAAmB,CAASV,KAAT,EAAgBW,OAAhB,EAAyB;AAC9C,aAAOX,KAAK,GAAG,KAAR,GAAgBW,OAAhB,GAA0B,GAAjC;AACD,KAFD;;AAIA,QAAIC,aAAa,GAAG,SAAhBA,aAAgB,CAASC,aAAT,EAAwBjP,SAAxB,EAAmC5S,KAAnC,EAA0C;AAC5D,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAElB,eAAO6hB,aAAa,GAAG,IAAhB,IAAwBjP,SAAS,GAAG,QAAH,GAAc,OAA/C,IAA0D,GAAjE;AACD,OAHD,MAGO;AAEL,eAAOiP,aAAa,GAAG,GAAhB,GAAsB7hB,KAA7B;AACD;AACF,KARD;;AAUA,QAAI8hB,cAAc,GAAG,SAAjBA,cAAiB,CAAStP,KAAT,EAAgBxS,KAAhB,EAAuB;AAC1C,UAAI6hB,aAAa,GAAGlR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,SAApD;AACA,UAAI+mB,OAAO,GAAGnP,KAAK,CAACuP,QAApB;AACA,UAAInP,SAAS,GAAGJ,KAAK,CAAClT,SAAN,KAAoB,IAApC;AACA,UAAI0hB,KAAK,GAAGY,aAAa,CAACC,aAAD,EAAgBjP,SAAhB,EAA2B5S,KAA3B,CAAzB;;AAEA,UAAIqgB,YAAY,IAAIM,qBAAqB,CAACqB,GAAtB,CAA0BhB,KAA1B,CAApB,EAAsD;AAIpD,eAAO,KAAP;AACD;;AACDL,MAAAA,qBAAqB,CAACsB,GAAtB,CAA0BjB,KAA1B;AAEA,UAAIF,QAAQ,GAAGY,gBAAgB,CAACV,KAAD,EAAQW,OAAR,CAA/B;AACAP,MAAAA,SAAS,CAACN,QAAD,CAAT;AACA,aAAO,IAAP;AACD,KAjBD;;AAmBA,QAAIoB,cAAc,GAAG,SAAjBA,cAAiB,CAAS1P,KAAT,EAAgBxS,KAAhB,EAAuB;AAC1C,UAAI6hB,aAAa,GAAGlR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,SAApD;AACA,UAAI+mB,OAAO,GAAGnP,KAAK,CAACuP,QAApB;AACA,UAAInP,SAAS,GAAGJ,KAAK,CAAClT,SAAN,KAAoB,IAApC;AACA,UAAI0hB,KAAK,GAAGY,aAAa,CAACC,aAAD,EAAgBjP,SAAhB,EAA2B5S,KAA3B,CAAzB;AACA,UAAI8gB,QAAQ,GAAGY,gBAAgB,CAACV,KAAD,EAAQW,OAAR,CAA/B;AACAN,MAAAA,SAAS,CAACP,QAAD,CAAT;AACD,KAPD;;AASA,QAAIqB,YAAY,GAAG,SAAfA,YAAe,CAAS3P,KAAT,EAAgBxS,KAAhB,EAAuBihB,OAAvB,EAAgC;AACjD,UAAIY,aAAa,GAAGlR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,SAApD;AACA,UAAI+mB,OAAO,GAAGnP,KAAK,CAACuP,QAApB;AACA,UAAInP,SAAS,GAAGJ,KAAK,CAAClT,SAAN,KAAoB,IAApC;AACA,UAAI0hB,KAAK,GAAGY,aAAa,CAACC,aAAD,EAAgBjP,SAAhB,EAA2B5S,KAA3B,CAAzB;AACA,UAAI8gB,QAAQ,GAAGY,gBAAgB,CAACV,KAAD,EAAQW,OAAR,CAA/B;AACAL,MAAAA,OAAO,CAACN,KAAD,EAAQF,QAAR,EAAkBG,OAAlB,CAAP;AACD,KAPD;;AASA,QAAImB,iBAAiB,GAAG,SAApBA,iBAAoB,CAAS5P,KAAT,EAAgB;AAGtC,cAAQA,KAAK,CAAC9V,GAAd;AACE,aAAKsB,QAAL;AACA,aAAKE,aAAL;AACA,aAAKC,QAAL;AACA,aAAKF,UAAL;AACA,aAAKG,QAAL;AACA,aAAKG,eAAL;AACA,aAAKD,eAAL;AACA,aAAKD,IAAL;AACE,iBAAO,IAAP;;AACF;AACE,iBAAO,KAAP;AAXJ;AAaD,KAhBD;;AAkBA,QAAIgkB,4BAA4B,GAAG,SAA/BA,4BAA+B,GAAW;AAC5C,UAAIlC,YAAY,KAAK,IAAjB,IAAyBC,iBAAiB,KAAK,IAAnD,EAAyD;AACvD8B,QAAAA,cAAc,CAAC9B,iBAAD,EAAoBD,YAApB,CAAd;AACD;;AACDC,MAAAA,iBAAiB,GAAG,IAApB;AACAD,MAAAA,YAAY,GAAG,IAAf;AACAI,MAAAA,gCAAgC,GAAG,KAAnC;AACD,KAPD;;AASA,QAAI+B,WAAW,GAAG,SAAdA,WAAc,GAAW;AAG3B,UAAI9P,KAAK,GAAG0N,YAAZ;;AACA,aAAO1N,KAAP,EAAc;AACZ,YAAIA,KAAK,CAAC+P,uBAAV,EAAmC;AACjCJ,UAAAA,YAAY,CAAC3P,KAAD,EAAQ,IAAR,EAAc,IAAd,CAAZ;AACD;;AACDA,QAAAA,KAAK,GAAGA,KAAK,CAAC3T,MAAd;AACD;AACF,KAVD;;AAYA,QAAI2jB,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAShQ,KAAT,EAAgB;AAC5C,UAAIA,KAAK,CAAC3T,MAAN,KAAiB,IAArB,EAA2B;AACzB2jB,QAAAA,uBAAuB,CAAChQ,KAAK,CAAC3T,MAAP,CAAvB;AACD;;AACD,UAAI2T,KAAK,CAAC+P,uBAAV,EAAmC;AACjCT,QAAAA,cAAc,CAACtP,KAAD,EAAQ,IAAR,CAAd;AACD;AACF,KAPD;;AASA,QAAIiQ,YAAY,GAAG,SAAfA,YAAe,GAAW;AAE5B,UAAIvC,YAAY,KAAK,IAArB,EAA2B;AACzBsC,QAAAA,uBAAuB,CAACtC,YAAD,CAAvB;AACD;AACF,KALD;;AAOA,aAASwC,YAAT,GAAwB;AACtB,UAAIpD,mBAAJ,EAAyB;AACvBmB,QAAAA,0BAA0B;AAC3B;AACF;;AAED,aAASkC,oBAAT,GAAgC;AAC9B,UAAIrD,mBAAJ,EAAyB;AACvB,YAAIe,YAAJ,EAAkB;AAChBC,UAAAA,iCAAiC,GAAG,IAApC;AACD;;AACD,YACEH,YAAY,KAAK,IAAjB,IACAA,YAAY,KAAK,oBADjB,IAEAA,YAAY,KAAK,2BAHnB,EAIE;AACAI,UAAAA,gCAAgC,GAAG,IAAnC;AACD;AACF;AACF;;AAED,aAASqC,yBAAT,GAAqC;AACnC,UAAItD,mBAAJ,EAAyB;AACvB,YAAIQ,kBAAkB,IAAI,CAACY,oBAA3B,EAAiD;AAC/CA,UAAAA,oBAAoB,GAAG,IAAvB;AACAU,UAAAA,SAAS,CAAC,iCAAD,CAAT;AACD;AACF;AACF;;AAED,aAASyB,wBAAT,CAAkCC,SAAlC,EAA6CC,cAA7C,EAA6D;AAC3D,UAAIzD,mBAAJ,EAAyB;AACvB,YAAIQ,kBAAJ,EAAwB;AACtBY,UAAAA,oBAAoB,GAAG,KAAvB;AACA,cAAIO,OAAO,GAAG6B,SAAS,GAAG,kCAAH,GAAwC,IAA/D;AACAxB,UAAAA,OAAO,CACL,wDACEyB,cADF,GAEE,MAHG,EAIL,iCAJK,EAKL9B,OALK,CAAP;AAOD;AACF;AACF;;AAED,aAAS+B,cAAT,CAAwBxQ,KAAxB,EAA+B;AAC7B,UAAI8M,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAD,IAAuBsC,iBAAiB,CAAC5P,KAAD,CAA5C,EAAqD;AACnD;AACD;;AAED0N,QAAAA,YAAY,GAAG1N,KAAf;;AACA,YAAI,CAACsP,cAAc,CAACtP,KAAD,EAAQ,IAAR,CAAnB,EAAkC;AAChC;AACD;;AACDA,QAAAA,KAAK,CAAC+P,uBAAN,GAAgC,IAAhC;AACD;AACF;;AAED,aAASU,eAAT,CAAyBzQ,KAAzB,EAAgC;AAC9B,UAAI8M,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAD,IAAuBsC,iBAAiB,CAAC5P,KAAD,CAA5C,EAAqD;AACnD;AACD;;AAGDA,QAAAA,KAAK,CAAC+P,uBAAN,GAAgC,KAAhC;AACAL,QAAAA,cAAc,CAAC1P,KAAD,EAAQ,IAAR,CAAd;AACD;AACF;;AAED,aAAS0Q,aAAT,CAAuB1Q,KAAvB,EAA8B;AAC5B,UAAI8M,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAD,IAAuBsC,iBAAiB,CAAC5P,KAAD,CAA5C,EAAqD;AACnD;AACD;;AAED0N,QAAAA,YAAY,GAAG1N,KAAK,CAAC3T,MAArB;;AACA,YAAI,CAAC2T,KAAK,CAAC+P,uBAAX,EAAoC;AAClC;AACD;;AACD/P,QAAAA,KAAK,CAAC+P,uBAAN,GAAgC,KAAhC;AACAJ,QAAAA,YAAY,CAAC3P,KAAD,EAAQ,IAAR,EAAc,IAAd,CAAZ;AACD;AACF;;AAED,aAAS2Q,mBAAT,CAA6B3Q,KAA7B,EAAoC;AAClC,UAAI8M,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAD,IAAuBsC,iBAAiB,CAAC5P,KAAD,CAA5C,EAAqD;AACnD;AACD;;AAED0N,QAAAA,YAAY,GAAG1N,KAAK,CAAC3T,MAArB;;AACA,YAAI,CAAC2T,KAAK,CAAC+P,uBAAX,EAAoC;AAClC;AACD;;AACD/P,QAAAA,KAAK,CAAC+P,uBAAN,GAAgC,KAAhC;AACA,YAAItB,OAAO,GAAG,gDAAd;AACAkB,QAAAA,YAAY,CAAC3P,KAAD,EAAQ,IAAR,EAAcyO,OAAd,CAAZ;AACD;AACF;;AAED,aAASmC,eAAT,CAAyB5Q,KAAzB,EAAgCxS,KAAhC,EAAuC;AACrC,UAAIsf,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACDuC,QAAAA,4BAA4B;;AAC5B,YAAI,CAACP,cAAc,CAACtP,KAAD,EAAQxS,KAAR,CAAnB,EAAmC;AACjC;AACD;;AACDogB,QAAAA,iBAAiB,GAAG5N,KAApB;AACA2N,QAAAA,YAAY,GAAGngB,KAAf;AACD;AACF;;AAED,aAASqjB,cAAT,GAA0B;AACxB,UAAI/D,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACD,YAAIK,YAAY,KAAK,IAAjB,IAAyBC,iBAAiB,KAAK,IAAnD,EAAyD;AACvD,cAAIa,OAAO,GAAGV,gCAAgC,GAC1C,8BAD0C,GAE1C,IAFJ;AAGA4B,UAAAA,YAAY,CAAC/B,iBAAD,EAAoBD,YAApB,EAAkCc,OAAlC,CAAZ;AACD;;AACDd,QAAAA,YAAY,GAAG,IAAf;AACAC,QAAAA,iBAAiB,GAAG,IAApB;AACD;AACF;;AAED,aAASkD,kBAAT,CAA4BC,cAA5B,EAA4C;AAC1C,UAAIjE,mBAAJ,EAAyB;AACvBY,QAAAA,YAAY,GAAGqD,cAAf;;AACA,YAAI,CAACzD,kBAAL,EAAyB;AACvB;AACD;;AACDU,QAAAA,4BAA4B,GAAG,CAA/B;AAGAY,QAAAA,SAAS,CAAC,6BAAD,CAAT;AAEAqB,QAAAA,YAAY;AACb;AACF;;AAED,aAASe,iBAAT,CAA2BC,aAA3B,EAA0CC,eAA1C,EAA2D;AACzD,UAAIpE,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACD,YAAImB,OAAO,GAAG,IAAd;;AACA,YAAIwC,aAAa,KAAK,IAAtB,EAA4B;AAC1B,cAAIA,aAAa,CAAC/mB,GAAd,KAAsBsB,QAA1B,EAAoC;AAClCijB,YAAAA,OAAO,GAAG,oDAAV;AACD,WAFD,MAEO;AACL,gBAAIY,aAAa,GAAGlR,gBAAgB,CAAC8S,aAAa,CAAC7oB,IAAf,CAAhB,IAAwC,SAA5D;AACAqmB,YAAAA,OAAO,GACL,kBAAkBY,aAAlB,GAAkC,kCADpC;AAED;AACF,SARD,MAQO,IAAIrB,4BAA4B,GAAG,CAAnC,EAAsC;AAC3CS,UAAAA,OAAO,GAAG,8BAAV;AACD;;AACDT,QAAAA,4BAA4B,GAAG,CAA/B;AACA,YAAIQ,KAAK,GAAG0C,eAAe,GACvB,6CADuB,GAEvB,sCAFJ;AAIApB,QAAAA,WAAW;AACXhB,QAAAA,OAAO,CAACN,KAAD,EAAQ,6BAAR,EAAuCC,OAAvC,CAAP;AACD;AACF;;AAED,aAAS0C,gBAAT,GAA4B;AAC1B,UAAIrE,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACDO,QAAAA,YAAY,GAAG,IAAf;AACAC,QAAAA,iCAAiC,GAAG,KAApC;AACAK,QAAAA,qBAAqB,CAACiD,KAAtB;AACAxC,QAAAA,SAAS,CAAC,sBAAD,CAAT;AACD;AACF;;AAED,aAASyC,eAAT,GAA2B;AACzB,UAAIvE,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AAED,YAAImB,OAAO,GAAG,IAAd;;AACA,YAAIX,iCAAJ,EAAuC;AACrCW,UAAAA,OAAO,GAAG,6CAAV;AACD,SAFD,MAEO,IAAIT,4BAA4B,GAAG,CAAnC,EAAsC;AAC3CS,UAAAA,OAAO,GAAG,gDAAV;AACD;;AACDX,QAAAA,iCAAiC,GAAG,KAApC;AACAE,QAAAA,4BAA4B;AAC5BH,QAAAA,YAAY,GAAG,KAAf;AACAM,QAAAA,qBAAqB,CAACiD,KAAtB;AAEAtC,QAAAA,OAAO,CAAC,sBAAD,EAAyB,sBAAzB,EAAiDL,OAAjD,CAAP;AACD;AACF;;AAED,aAAS6C,+BAAT,GAA2C;AACzC,UAAIxE,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACDW,QAAAA,0BAA0B,GAAG,CAA7B;AACAW,QAAAA,SAAS,CAAC,+BAAD,CAAT;AACD;AACF;;AAED,aAAS2C,8BAAT,GAA0C;AACxC,UAAIzE,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACD,YAAIkE,KAAK,GAAGvD,0BAAZ;AACAA,QAAAA,0BAA0B,GAAG,CAA7B;AACAa,QAAAA,OAAO,CACL,mCAAmC0C,KAAnC,GAA2C,SADtC,EAEL,+BAFK,EAGL,IAHK,CAAP;AAKD;AACF;;AAED,aAASC,2BAAT,GAAuC;AACrC,UAAI3E,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACDW,QAAAA,0BAA0B,GAAG,CAA7B;AACAW,QAAAA,SAAS,CAAC,2BAAD,CAAT;AACD;AACF;;AAED,aAAS8C,0BAAT,GAAsC;AACpC,UAAI5E,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACD,YAAIkE,KAAK,GAAGvD,0BAAZ;AACAA,QAAAA,0BAA0B,GAAG,CAA7B;AACAa,QAAAA,OAAO,CACL,+BAA+B0C,KAA/B,GAAuC,SADlC,EAEL,2BAFK,EAGL,IAHK,CAAP;AAKD;AACF;;AAED,aAASG,0BAAT,GAAsC;AACpC,UAAI7E,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACDW,QAAAA,0BAA0B,GAAG,CAA7B;AACAW,QAAAA,SAAS,CAAC,6BAAD,CAAT;AACD;AACF;;AAED,aAASgD,yBAAT,GAAqC;AACnC,UAAI9E,mBAAJ,EAAyB;AACvB,YAAI,CAACQ,kBAAL,EAAyB;AACvB;AACD;;AACD,YAAIkE,KAAK,GAAGvD,0BAAZ;AACAA,QAAAA,0BAA0B,GAAG,CAA7B;AACAa,QAAAA,OAAO,CACL,iCAAiC0C,KAAjC,GAAyC,SADpC,EAEL,6BAFK,EAGL,IAHK,CAAP;AAKD;AACF;;AAED,QAAIK,UAAU,GAAG,EAAjB;AAEA,QAAIC,UAAU,GAAG,KAAK,CAAtB;AAEA;AACEA,MAAAA,UAAU,GAAG,EAAb;AACD;AAED,QAAIlX,KAAK,GAAG,CAAC,CAAb;;AAEA,aAASmX,YAAT,CAAsBC,YAAtB,EAAoC;AAClC,aAAO;AACL9oB,QAAAA,OAAO,EAAE8oB;AADJ,OAAP;AAGD;;AAED,aAAS9gB,GAAT,CAAa+gB,MAAb,EAAqBjS,KAArB,EAA4B;AAC1B,UAAIpF,KAAK,GAAG,CAAZ,EAAe;AACb;AACE9T,UAAAA,qBAAqB,CAAC,KAAD,EAAQ,iBAAR,CAArB;AACD;AACD;AACD;;AAED;AACE,YAAIkZ,KAAK,KAAK8R,UAAU,CAAClX,KAAD,CAAxB,EAAiC;AAC/B9T,UAAAA,qBAAqB,CAAC,KAAD,EAAQ,0BAAR,CAArB;AACD;AACF;AAEDmrB,MAAAA,MAAM,CAAC/oB,OAAP,GAAiB2oB,UAAU,CAACjX,KAAD,CAA3B;AAEAiX,MAAAA,UAAU,CAACjX,KAAD,CAAV,GAAoB,IAApB;AAEA;AACEkX,QAAAA,UAAU,CAAClX,KAAD,CAAV,GAAoB,IAApB;AACD;AAEDA,MAAAA,KAAK;AACN;;AAED,aAASxR,IAAT,CAAc6oB,MAAd,EAAsB5V,KAAtB,EAA6B2D,KAA7B,EAAoC;AAClCpF,MAAAA,KAAK;AAELiX,MAAAA,UAAU,CAACjX,KAAD,CAAV,GAAoBqX,MAAM,CAAC/oB,OAA3B;AAEA;AACE4oB,QAAAA,UAAU,CAAClX,KAAD,CAAV,GAAoBoF,KAApB;AACD;AAEDiS,MAAAA,MAAM,CAAC/oB,OAAP,GAAiBmT,KAAjB;AACD;;AAED,aAAS6V,qBAAT,GAAiC;AAC/B;AACE,YAAItX,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB9T,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,4DAFmB,CAArB;AAID;AACF;AACF;;AAED,aAASqrB,8BAAT,GAA0C;AACxC;AACEvX,QAAAA,KAAK,GAAG,CAAC,CAAT;AACAiX,QAAAA,UAAU,CAACzrB,MAAX,GAAoB,CAApB;AACA0rB,QAAAA,UAAU,CAAC1rB,MAAX,GAAoB,CAApB;AACD;AACF;;AAED,QAAIgsB,iCAAiC,GAAG,KAAK,CAA7C;AAEA;AACEA,MAAAA,iCAAiC,GAAG,EAApC;AACD;AAED,QAAIC,kBAAkB,GAAG,EAAzB;AACA;AACE3iB,MAAAA,MAAM,CAAC+L,MAAP,CAAc4W,kBAAd;AACD;AAGD,QAAIC,kBAAkB,GAAGP,YAAY,CAACM,kBAAD,CAArC;AAEA,QAAIE,yBAAyB,GAAGR,YAAY,CAAC,KAAD,CAA5C;AAIA,QAAIS,eAAe,GAAGH,kBAAtB;;AAEA,aAASI,kBAAT,CACExG,cADF,EAEEyG,SAFF,EAGEC,2BAHF,EAIE;AACA,UAAIA,2BAA2B,IAAIC,iBAAiB,CAACF,SAAD,CAApD,EAAiE;AAK/D,eAAOF,eAAP;AACD;;AACD,aAAOF,kBAAkB,CAACppB,OAA1B;AACD;;AAED,aAAS2pB,YAAT,CAAsB5G,cAAtB,EAAsC6G,eAAtC,EAAuDC,aAAvD,EAAsE;AACpE,UAAI9hB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AACAyG,MAAAA,QAAQ,CAAC+hB,2CAAT,GAAuDF,eAAvD;AACA7hB,MAAAA,QAAQ,CAACgiB,yCAAT,GAAqDF,aAArD;AACD;;AAED,aAASG,gBAAT,CAA0BjH,cAA1B,EAA0C6G,eAA1C,EAA2D;AACzD,UAAI1qB,IAAI,GAAG6jB,cAAc,CAAC7jB,IAA1B;AACA,UAAI+qB,YAAY,GAAG/qB,IAAI,CAAC+qB,YAAxB;;AACA,UAAI,CAACA,YAAL,EAAmB;AACjB,eAAOd,kBAAP;AACD;;AAKD,UAAIphB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;;AACA,UACEyG,QAAQ,IACRA,QAAQ,CAAC+hB,2CAAT,KAAyDF,eAF3D,EAGE;AACA,eAAO7hB,QAAQ,CAACgiB,yCAAhB;AACD;;AAED,UAAI1xB,OAAO,GAAG,EAAd;;AACA,WAAK,IAAI4a,GAAT,IAAgBgX,YAAhB,EAA8B;AAC5B5xB,QAAAA,OAAO,CAAC4a,GAAD,CAAP,GAAe2W,eAAe,CAAC3W,GAAD,CAA9B;AACD;;AAED;AACE,YAAIhb,IAAI,GAAGgd,gBAAgB,CAAC/V,IAAD,CAAhB,IAA0B,SAArC;AACApI,QAAAA,cAAc,CACZmzB,YADY,EAEZ5xB,OAFY,EAGZ,SAHY,EAIZJ,IAJY,EAKZirB,yBALY,CAAd;AAOD;;AAID,UAAInb,QAAJ,EAAc;AACZ4hB,QAAAA,YAAY,CAAC5G,cAAD,EAAiB6G,eAAjB,EAAkCvxB,OAAlC,CAAZ;AACD;;AAED,aAAOA,OAAP;AACD;;AAED,aAAS6xB,iBAAT,GAA6B;AAC3B,aAAOb,yBAAyB,CAACrpB,OAAjC;AACD;;AAED,aAAS0pB,iBAAT,CAA2BxqB,IAA3B,EAAiC;AAC/B,UAAIirB,iBAAiB,GAAGjrB,IAAI,CAACirB,iBAA7B;AACA,aAAOA,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAKhzB,SAA3D;AACD;;AAED,aAASizB,UAAT,CAAoBtT,KAApB,EAA2B;AACzB9O,MAAAA,GAAG,CAACqhB,yBAAD,EAA4BvS,KAA5B,CAAH;AACA9O,MAAAA,GAAG,CAACohB,kBAAD,EAAqBtS,KAArB,CAAH;AACD;;AAED,aAASuT,wBAAT,CAAkCvT,KAAlC,EAAyC;AACvC9O,MAAAA,GAAG,CAACqhB,yBAAD,EAA4BvS,KAA5B,CAAH;AACA9O,MAAAA,GAAG,CAACohB,kBAAD,EAAqBtS,KAArB,CAAH;AACD;;AAED,aAASwT,yBAAT,CAAmCxT,KAAnC,EAA0Cze,OAA1C,EAAmDkyB,SAAnD,EAA8D;AAC5DlzB,MAAAA,SAAS,CACP+xB,kBAAkB,CAACppB,OAAnB,KAA+BmpB,kBADxB,EAEP,wCACE,sEAHK,CAAT;AAMAjpB,MAAAA,IAAI,CAACkpB,kBAAD,EAAqB/wB,OAArB,EAA8Bye,KAA9B,CAAJ;AACA5W,MAAAA,IAAI,CAACmpB,yBAAD,EAA4BkB,SAA5B,EAAuCzT,KAAvC,CAAJ;AACD;;AAED,aAAS0T,mBAAT,CAA6B1T,KAA7B,EAAoC5X,IAApC,EAA0CurB,aAA1C,EAAyD;AACvD,UAAI1iB,QAAQ,GAAG+O,KAAK,CAACxV,SAArB;AACA,UAAI6oB,iBAAiB,GAAGjrB,IAAI,CAACirB,iBAA7B;;AAIA,UAAI,OAAOpiB,QAAQ,CAAC2iB,eAAhB,KAAoC,UAAxC,EAAoD;AAClD;AACE,cAAIvE,aAAa,GAAGlR,gBAAgB,CAAC/V,IAAD,CAAhB,IAA0B,SAA9C;;AAEA,cAAI,CAACgqB,iCAAiC,CAAC/C,aAAD,CAAtC,EAAuD;AACrD+C,YAAAA,iCAAiC,CAAC/C,aAAD,CAAjC,GAAmD,IAAnD;AACAvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,gFACE,2EADF,GAEE,4BAJiB,EAKnBuoB,aALmB,EAMnBA,aANmB,CAArB;AAQD;AACF;AACD,eAAOsE,aAAP;AACD;;AAED,UAAIE,YAAY,GAAG,KAAK,CAAxB;AACA;AACErH,QAAAA,eAAe,CAAC,iBAAD,CAAf;AACD;AACDoE,MAAAA,eAAe,CAAC5Q,KAAD,EAAQ,iBAAR,CAAf;AACA6T,MAAAA,YAAY,GAAG5iB,QAAQ,CAAC2iB,eAAT,EAAf;AACA/C,MAAAA,cAAc;AACd;AACErE,QAAAA,eAAe,CAAC,IAAD,CAAf;AACD;;AACD,WAAK,IAAIsH,UAAT,IAAuBD,YAAvB,EAAqC;AACnCtzB,QAAAA,SAAS,CACPuzB,UAAU,IAAIT,iBADP,EAEP,qEAFO,EAGPlV,gBAAgB,CAAC/V,IAAD,CAAhB,IAA0B,SAHnB,EAIP0rB,UAJO,CAAT;AAMD;;AACD;AACE,YAAI3yB,IAAI,GAAGgd,gBAAgB,CAAC/V,IAAD,CAAhB,IAA0B,SAArC;AACApI,QAAAA,cAAc,CACZqzB,iBADY,EAEZQ,YAFY,EAGZ,eAHY,EAIZ1yB,IAJY,EAUZirB,yBAVY,CAAd;AAYD;AAED,aAAO,SAAc,EAAd,EAAkBuH,aAAlB,EAAiCE,YAAjC,CAAP;AACD;;AAED,aAASE,mBAAT,CAA6B9H,cAA7B,EAA6C;AAC3C,UAAIhb,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AAIA,UAAIwpB,0BAA0B,GAC3B/iB,QAAQ,IAAIA,QAAQ,CAACgjB,yCAAtB,IACA5B,kBAFF;AAMAG,MAAAA,eAAe,GAAGF,kBAAkB,CAACppB,OAArC;AACAE,MAAAA,IAAI,CAACkpB,kBAAD,EAAqB0B,0BAArB,EAAiD/H,cAAjD,CAAJ;AACA7iB,MAAAA,IAAI,CACFmpB,yBADE,EAEFA,yBAAyB,CAACrpB,OAFxB,EAGF+iB,cAHE,CAAJ;AAMA,aAAO,IAAP;AACD;;AAED,aAASiI,yBAAT,CAAmCjI,cAAnC,EAAmD7jB,IAAnD,EAAyDqrB,SAAzD,EAAoE;AAClE,UAAIxiB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AACAjK,MAAAA,SAAS,CACP0Q,QADO,EAEP,iDACE,sEAHK,CAAT;;AAMA,UAAIwiB,SAAJ,EAAe;AAIb,YAAIU,aAAa,GAAGT,mBAAmB,CACrCzH,cADqC,EAErC7jB,IAFqC,EAGrCoqB,eAHqC,CAAvC;AAKAvhB,QAAAA,QAAQ,CAACgjB,yCAAT,GAAqDE,aAArD;AAIAjjB,QAAAA,GAAG,CAACqhB,yBAAD,EAA4BtG,cAA5B,CAAH;AACA/a,QAAAA,GAAG,CAACohB,kBAAD,EAAqBrG,cAArB,CAAH;AAEA7iB,QAAAA,IAAI,CAACkpB,kBAAD,EAAqB6B,aAArB,EAAoClI,cAApC,CAAJ;AACA7iB,QAAAA,IAAI,CAACmpB,yBAAD,EAA4BkB,SAA5B,EAAuCxH,cAAvC,CAAJ;AACD,OAlBD,MAkBO;AACL/a,QAAAA,GAAG,CAACqhB,yBAAD,EAA4BtG,cAA5B,CAAH;AACA7iB,QAAAA,IAAI,CAACmpB,yBAAD,EAA4BkB,SAA5B,EAAuCxH,cAAvC,CAAJ;AACD;AACF;;AAED,aAASmI,0BAAT,CAAoCpU,KAApC,EAA2C;AAGzCzf,MAAAA,SAAS,CACP4f,cAAc,CAACH,KAAD,CAAd,KACGA,KAAK,CAAC9V,GAAN,KAAcmB,cAAd,IAAgC2U,KAAK,CAAC9V,GAAN,KAAcoB,kBADjD,CADO,EAGP,8DACE,sEAJK,CAAT;AAOA,UAAI2U,IAAI,GAAGD,KAAX;;AACA,SAAG;AACD,gBAAQC,IAAI,CAAC/V,GAAb;AACE,eAAKsB,QAAL;AACE,mBAAOyU,IAAI,CAACzV,SAAL,CAAejJ,OAAtB;;AACF,eAAK8J,cAAL;AAAqB;AACnB,kBAAIqnB,SAAS,GAAGzS,IAAI,CAAC7X,IAArB;;AACA,kBAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChC,uBAAOzS,IAAI,CAACzV,SAAL,CAAeypB,yCAAtB;AACD;;AACD;AACD;;AACD,eAAK3oB,kBAAL;AAAyB;AACvB,kBAAI+oB,UAAU,GAAGvW,6BAA6B,CAACmC,IAAI,CAAC7X,IAAN,CAA9C;;AACA,kBAAIwqB,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjC,uBAAOpU,IAAI,CAACzV,SAAL,CAAeypB,yCAAtB;AACD;;AACD;AACD;AAhBH;;AAkBAhU,QAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD,OApBD,QAoBS4T,IAAI,KAAK,IApBlB;;AAqBA1f,MAAAA,SAAS,CACP,KADO,EAEP,+CACE,sEAHK,CAAT;AAKD;;AAED,QAAI+zB,iBAAiB,GAAG,IAAxB;AACA,QAAIC,oBAAoB,GAAG,IAA3B;AACA,QAAIC,cAAc,GAAG,KAArB;;AAEA,aAASC,WAAT,CAAqBvnB,EAArB,EAAyB;AACvB,aAAO,UAASC,GAAT,EAAc;AACnB,YAAI;AACF,iBAAOD,EAAE,CAACC,GAAD,CAAT;AACD,SAFD,CAEE,OAAO8hB,GAAP,EAAY;AACZ,cAAI,QAAQ,CAACuF,cAAb,EAA6B;AAC3BA,YAAAA,cAAc,GAAG,IAAjB;AACA1tB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,yCAFmB,EAGnBmoB,GAHmB,CAArB;AAKD;AACF;AACF,OAbD;AAcD;;AAED,QAAIyF,iBAAiB,GAAG,OAAOC,8BAAP,KAA0C,WAAlE;;AAEA,aAASC,eAAT,CAAyBC,SAAzB,EAAoC;AAClC,UAAI,OAAOF,8BAAP,KAA0C,WAA9C,EAA2D;AAEzD,eAAO,KAAP;AACD;;AACD,UAAIG,IAAI,GAAGH,8BAAX;;AACA,UAAIG,IAAI,CAACC,UAAT,EAAqB;AAInB,eAAO,IAAP;AACD;;AACD,UAAI,CAACD,IAAI,CAACE,aAAV,EAAyB;AACvB;AACEluB,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,0EACE,mEADF,GAEE,8BAJiB,CAArB;AAMD;AAED,eAAO,IAAP;AACD;;AACD,UAAI;AACF,YAAImuB,UAAU,GAAGH,IAAI,CAACI,MAAL,CAAYL,SAAZ,CAAjB;AAEAP,QAAAA,iBAAiB,GAAGG,WAAW,CAAC,UAASU,IAAT,EAAe;AAC7C,iBAAOL,IAAI,CAACR,iBAAL,CAAuBW,UAAvB,EAAmCE,IAAnC,CAAP;AACD,SAF8B,CAA/B;AAGAZ,QAAAA,oBAAoB,GAAGE,WAAW,CAAC,UAASzU,KAAT,EAAgB;AACjD,iBAAO8U,IAAI,CAACP,oBAAL,CAA0BU,UAA1B,EAAsCjV,KAAtC,CAAP;AACD,SAFiC,CAAlC;AAGD,OATD,CASE,OAAOiP,GAAP,EAAY;AAEZ;AACEnoB,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,0CAFmB,EAGnBmoB,GAHmB,CAArB;AAKD;AACF;;AAED,aAAO,IAAP;AACD;;AAED,aAASmG,YAAT,CAAsBD,IAAtB,EAA4B;AAC1B,UAAI,OAAOb,iBAAP,KAA6B,UAAjC,EAA6C;AAC3CA,QAAAA,iBAAiB,CAACa,IAAD,CAAjB;AACD;AACF;;AAED,aAASE,eAAT,CAAyBrV,KAAzB,EAAgC;AAC9B,UAAI,OAAOuU,oBAAP,KAAgC,UAApC,EAAgD;AAC9CA,QAAAA,oBAAoB,CAACvU,KAAD,CAApB;AACD;AACF;;AAKD,QAAIsV,iBAAiB,GAAG,UAAxB;AAEA,QAAIC,MAAM,GAAG,CAAb;AACA,QAAIC,IAAI,GAAG,CAAX;AACA,QAAIC,KAAK,GAAGH,iBAAZ;AAEA,QAAII,SAAS,GAAG,EAAhB;AACA,QAAIC,mBAAmB,GAAG,CAA1B;;AAGA,aAASC,kBAAT,CAA4BC,EAA5B,EAAgC;AAE9B,aAAO,CAAEA,EAAE,GAAGH,SAAN,GAAmB,CAApB,IAAyBC,mBAAhC;AACD;;AAED,aAASG,kBAAT,CAA4BvF,cAA5B,EAA4C;AAC1C,aAAO,CAACA,cAAc,GAAGoF,mBAAlB,IAAyCD,SAAhD;AACD;;AAED,aAASK,OAAT,CAAiBC,GAAjB,EAAsBC,SAAtB,EAAiC;AAC/B,aAAO,CAAC,CAAED,GAAG,GAAGC,SAAP,GAAoB,CAArB,IAA0B,CAA3B,IAAgCA,SAAvC;AACD;;AAED,aAASC,uBAAT,CAAiCC,WAAjC,EAA8CC,cAA9C,EAA8DC,YAA9D,EAA4E;AAC1E,aACEV,mBAAmB,GACnBI,OAAO,CACLI,WAAW,GAAGR,mBAAd,GAAoCS,cAAc,GAAGV,SADhD,EAELW,YAAY,GAAGX,SAFV,CAFT;AAOD;;AAED,QAAIY,uBAAuB,GAAG,IAA9B;AACA,QAAIC,uBAAuB,GAAG,GAA9B;;AAEA,aAASC,sBAAT,CAAgCL,WAAhC,EAA6C;AAC3C,aAAOD,uBAAuB,CAC5BC,WAD4B,EAE5BG,uBAF4B,EAG5BC,uBAH4B,CAA9B;AAKD;;AAaD,QAAIE,wBAAwB,GAAG,GAA/B;AACA,QAAIC,wBAAwB,GAAG,GAA/B;;AAEA,aAASC,4BAAT,CAAsCR,WAAtC,EAAmD;AACjD,aAAOD,uBAAuB,CAC5BC,WAD4B,EAE5BM,wBAF4B,EAG5BC,wBAH4B,CAA9B;AAKD;;AAED,QAAIE,SAAS,GAAG,CAAhB;AACA,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,WAAW,GAAG,CAAlB;AAEA,QAAIC,iBAAiB,GAAG,KAAK,CAA7B;AAEA;AACEA,MAAAA,iBAAiB,GAAG,KAApB;;AACA,UAAI;AACF,YAAIC,mBAAmB,GAAGvnB,MAAM,CAACwnB,iBAAP,CAAyB,EAAzB,CAA1B;AACA,YAAIC,OAAO,GAAG,IAAIC,GAAJ,CAAQ,CAAC,CAACH,mBAAD,EAAsB,IAAtB,CAAD,CAAR,CAAd;AACA,YAAII,OAAO,GAAG,IAAIjJ,GAAJ,CAAQ,CAAC6I,mBAAD,CAAR,CAAd;AAIAE,QAAAA,OAAO,CAAC9mB,GAAR,CAAY,CAAZ,EAAe,CAAf;AACAgnB,QAAAA,OAAO,CAAC5H,GAAR,CAAY,CAAZ;AACD,OATD,CASE,OAAO5uB,CAAP,EAAU;AAEVm2B,QAAAA,iBAAiB,GAAG,IAApB;AACD;AACF;AAKD,QAAIM,YAAY,GAAG,KAAK,CAAxB;AAEA;AACEA,MAAAA,YAAY,GAAG,CAAf;AACD;;AAED,aAASC,SAAT,CAAmBrtB,GAAnB,EAAwBstB,YAAxB,EAAsCrb,GAAtC,EAA2Csb,IAA3C,EAAiD;AAE/C,WAAKvtB,GAAL,GAAWA,GAAX;AACA,WAAKiS,GAAL,GAAWA,GAAX;AACA,WAAK/T,IAAL,GAAY,IAAZ;AACA,WAAKoC,SAAL,GAAiB,IAAjB;AAGA,WAAK6B,MAAL,GAAc,IAAd;AACA,WAAKyU,KAAL,GAAa,IAAb;AACA,WAAKC,OAAL,GAAe,IAAf;AACA,WAAKnG,KAAL,GAAa,CAAb;AAEA,WAAK8c,GAAL,GAAW,IAAX;AAEA,WAAKF,YAAL,GAAoBA,YAApB;AACA,WAAKG,aAAL,GAAqB,IAArB;AACA,WAAKC,WAAL,GAAmB,IAAnB;AACA,WAAKC,aAAL,GAAqB,IAArB;AACA,WAAKC,sBAAL,GAA8B,IAA9B;AAEA,WAAKL,IAAL,GAAYA,IAAZ;AAGA,WAAKvX,SAAL,GAAiBvB,QAAjB;AACA,WAAKoZ,UAAL,GAAkB,IAAlB;AAEA,WAAKC,WAAL,GAAmB,IAAnB;AACA,WAAKC,UAAL,GAAkB,IAAlB;AAEA,WAAK1H,cAAL,GAAsBgF,MAAtB;AACA,WAAK2C,mBAAL,GAA2B3C,MAA3B;AAEA,WAAKzoB,SAAL,GAAiB,IAAjB;;AAEA,UAAIogB,mBAAJ,EAAyB;AACvB,aAAKiL,cAAL,GAAsB,CAAtB;AACA,aAAKC,eAAL,GAAuB,CAAC,CAAxB;AACA,aAAKC,gBAAL,GAAwB,CAAxB;AACA,aAAKC,gBAAL,GAAwB,CAAxB;AACD;;AAED;AACE,aAAK/I,QAAL,GAAgB+H,YAAY,EAA5B;AACA,aAAKvL,YAAL,GAAoB,IAApB;AACA,aAAKD,WAAL,GAAmB,IAAnB;AACA,aAAKiE,uBAAL,GAA+B,KAA/B;;AACA,YAAI,CAACiH,iBAAD,IAAsB,OAAOtnB,MAAM,CAACwnB,iBAAd,KAAoC,UAA9D,EAA0E;AACxExnB,UAAAA,MAAM,CAACwnB,iBAAP,CAAyB,IAAzB;AACD;AACF;AACF;;AAeD,QAAIqB,WAAW,GAAG,SAAdA,WAAc,CAASruB,GAAT,EAAcstB,YAAd,EAA4Brb,GAA5B,EAAiCsb,IAAjC,EAAuC;AAEvD,aAAO,IAAIF,SAAJ,CAAcrtB,GAAd,EAAmBstB,YAAnB,EAAiCrb,GAAjC,EAAsCsb,IAAtC,CAAP;AACD,KAHD;;AAKA,aAASe,eAAT,CAAyB9F,SAAzB,EAAoC;AAClC,UAAIhxB,SAAS,GAAGgxB,SAAS,CAAChxB,SAA1B;AACA,aAAO,CAAC,EAAEA,SAAS,IAAIA,SAAS,CAAC+2B,gBAAzB,CAAR;AACD;;AAED,aAASC,uBAAT,CAAiC1Y,KAAjC,EAAwC0S,SAAxC,EAAmD;AACjD,UAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACnC,eAAO8F,eAAe,CAAC9F,SAAD,CAAf,GACHpnB,kBADG,GAEHF,uBAFJ;AAGD,OAJD,MAIO,IACLsnB,SAAS,KAAKryB,SAAd,IACAqyB,SAAS,KAAK,IADd,IAEAA,SAAS,CAACrU,QAHL,EAIL;AACA,eAAOpS,cAAP;AACD;;AACD,aAAOV,sBAAP;AACD;;AAGD,aAASotB,oBAAT,CAA8BzvB,OAA9B,EAAuCsuB,YAAvC,EAAqDjH,cAArD,EAAqE;AACnE,UAAItE,cAAc,GAAG/iB,OAAO,CAAC4D,SAA7B;;AACA,UAAImf,cAAc,KAAK,IAAvB,EAA6B;AAM3BA,QAAAA,cAAc,GAAGsM,WAAW,CAC1BrvB,OAAO,CAACgB,GADkB,EAE1BstB,YAF0B,EAG1BtuB,OAAO,CAACiT,GAHkB,EAI1BjT,OAAO,CAACuuB,IAJkB,CAA5B;AAMAxL,QAAAA,cAAc,CAAC7jB,IAAf,GAAsBc,OAAO,CAACd,IAA9B;AACA6jB,QAAAA,cAAc,CAACzhB,SAAf,GAA2BtB,OAAO,CAACsB,SAAnC;AAEA;AAEEyhB,UAAAA,cAAc,CAACsD,QAAf,GAA0BrmB,OAAO,CAACqmB,QAAlC;AACAtD,UAAAA,cAAc,CAACF,YAAf,GAA8B7iB,OAAO,CAAC6iB,YAAtC;AACAE,UAAAA,cAAc,CAACH,WAAf,GAA6B5iB,OAAO,CAAC4iB,WAArC;AACD;AAEDG,QAAAA,cAAc,CAACnf,SAAf,GAA2B5D,OAA3B;AACAA,QAAAA,OAAO,CAAC4D,SAAR,GAAoBmf,cAApB;AACD,OAxBD,MAwBO;AACLA,QAAAA,cAAc,CAACuL,YAAf,GAA8BA,YAA9B;AAIAvL,QAAAA,cAAc,CAAC/L,SAAf,GAA2BvB,QAA3B;AAGAsN,QAAAA,cAAc,CAAC8L,UAAf,GAA4B,IAA5B;AACA9L,QAAAA,cAAc,CAAC+L,WAAf,GAA6B,IAA7B;AACA/L,QAAAA,cAAc,CAACgM,UAAf,GAA4B,IAA5B;;AAEA,YAAI/K,mBAAJ,EAAyB;AAKvBjB,UAAAA,cAAc,CAACkM,cAAf,GAAgC,CAAhC;AACAlM,UAAAA,cAAc,CAACmM,eAAf,GAAiC,CAAC,CAAlC;AACD;AACF;;AAGDnM,MAAAA,cAAc,CAACiM,mBAAf,GAAqChvB,OAAO,CAACgvB,mBAA7C;;AACA,UAAIV,YAAY,KAAKtuB,OAAO,CAACsuB,YAA7B,EAA2C;AAEzCvL,QAAAA,cAAc,CAACsE,cAAf,GAAgCA,cAAhC;AACD,OAHD,MAGO;AAELtE,QAAAA,cAAc,CAACsE,cAAf,GAAgCrnB,OAAO,CAACqnB,cAAxC;AACD;;AAEDtE,MAAAA,cAAc,CAACnL,KAAf,GAAuB5X,OAAO,CAAC4X,KAA/B;AACAmL,MAAAA,cAAc,CAAC0L,aAAf,GAA+BzuB,OAAO,CAACyuB,aAAvC;AACA1L,MAAAA,cAAc,CAAC4L,aAAf,GAA+B3uB,OAAO,CAAC2uB,aAAvC;AACA5L,MAAAA,cAAc,CAAC2L,WAAf,GAA6B1uB,OAAO,CAAC0uB,WAArC;AACA3L,MAAAA,cAAc,CAAC6L,sBAAf,GAAwC5uB,OAAO,CAAC4uB,sBAAhD;AAGA7L,MAAAA,cAAc,CAAClL,OAAf,GAAyB7X,OAAO,CAAC6X,OAAjC;AACAkL,MAAAA,cAAc,CAACrR,KAAf,GAAuB1R,OAAO,CAAC0R,KAA/B;AACAqR,MAAAA,cAAc,CAACyL,GAAf,GAAqBxuB,OAAO,CAACwuB,GAA7B;;AAEA,UAAIxK,mBAAJ,EAAyB;AACvBjB,QAAAA,cAAc,CAACoM,gBAAf,GAAkCnvB,OAAO,CAACmvB,gBAA1C;AACApM,QAAAA,cAAc,CAACqM,gBAAf,GAAkCpvB,OAAO,CAACovB,gBAA1C;AACD;;AAED,aAAOrM,cAAP;AACD;;AAED,aAAS2M,mBAAT,CAA6BC,OAA7B,EAAsC;AACpC,UAAIpB,IAAI,GAAGoB,OAAO,GAAGhC,SAAS,GAAGC,UAAf,GAA4BF,SAA9C;;AAEA,UAAI1J,mBAAmB,IAAIwH,iBAA3B,EAA8C;AAI5C+C,QAAAA,IAAI,IAAIV,WAAR;AACD;;AAED,aAAOwB,WAAW,CAAC/sB,QAAD,EAAW,IAAX,EAAiB,IAAjB,EAAuBisB,IAAvB,CAAlB;AACD;;AAED,aAASqB,sBAAT,CAAgCC,OAAhC,EAAyCtB,IAAzC,EAA+ClH,cAA/C,EAA+D;AAC7D,UAAIjQ,KAAK,GAAG,IAAZ;AACA;AACEA,QAAAA,KAAK,GAAGyY,OAAO,CAACtV,MAAhB;AACD;AAED,UAAIzD,KAAK,GAAG,KAAK,CAAjB;AACA,UAAI5X,IAAI,GAAG2wB,OAAO,CAAC3wB,IAAnB;AACA,UAAI+T,GAAG,GAAG4c,OAAO,CAAC5c,GAAlB;AACA,UAAIqb,YAAY,GAAGuB,OAAO,CAAC3uB,KAA3B;AAEA,UAAI4uB,QAAQ,GAAG,KAAK,CAApB;;AACA,UAAI,OAAO5wB,IAAP,KAAgB,UAApB,EAAgC;AAC9B4wB,QAAAA,QAAQ,GAAGR,eAAe,CAACpwB,IAAD,CAAf,GAAwBiD,cAAxB,GAAyCE,sBAApD;AACD,OAFD,MAEO,IAAI,OAAOnD,IAAP,KAAgB,QAApB,EAA8B;AACnC4wB,QAAAA,QAAQ,GAAGttB,aAAX;AACD,OAFM,MAEA;AACLutB,QAAAA,MAAM,EAAE,QAAQ7wB,IAAR;AACN,eAAKyU,mBAAL;AACE,mBAAOqc,uBAAuB,CAC5B1B,YAAY,CAACzN,QADe,EAE5B0N,IAF4B,EAG5BlH,cAH4B,EAI5BpU,GAJ4B,CAA9B;;AAMF,eAAKe,qBAAL;AACE8b,YAAAA,QAAQ,GAAGntB,IAAX;AACA4rB,YAAAA,IAAI,IAAIZ,SAAS,GAAGC,UAApB;AACA;;AACF,eAAKha,sBAAL;AACEkc,YAAAA,QAAQ,GAAGntB,IAAX;AACA4rB,YAAAA,IAAI,IAAIX,UAAR;AACA;;AACF,eAAK/Z,mBAAL;AACE,mBAAOoc,uBAAuB,CAAC3B,YAAD,EAAeC,IAAf,EAAqBlH,cAArB,EAAqCpU,GAArC,CAA9B;;AACF,eAAKiB,sBAAL;AACE4b,YAAAA,QAAQ,GAAG7sB,oBAAX;AACA;;AACF;AAAS;AACP,kBAAI,OAAO/D,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,KAAK,IAAzC,EAA+C;AAC7C,wBAAQA,IAAI,CAACiW,QAAb;AACE,uBAAKrB,mBAAL;AACEgc,oBAAAA,QAAQ,GAAGjtB,eAAX;AACA,0BAAMktB,MAAN;;AACF,uBAAKhc,kBAAL;AAEE+b,oBAAAA,QAAQ,GAAGltB,eAAX;AACA,0BAAMmtB,MAAN;;AACF,uBAAK9b,sBAAL;AACE6b,oBAAAA,QAAQ,GAAGhtB,UAAX;AACA,0BAAMitB,MAAN;;AACF;AAAS;AACP,0BAAI,OAAO7wB,IAAI,CAACqW,IAAZ,KAAqB,UAAzB,EAAqC;AACnCua,wBAAAA,QAAQ,GAAGztB,sBAAX;AACA,8BAAM0tB,MAAN;AACD;AACF;AAhBH;AAkBD;;AACD,kBAAI/M,IAAI,GAAG,EAAX;AACA;AACE,oBACE9jB,IAAI,KAAK/H,SAAT,IACC,OAAO+H,IAAP,KAAgB,QAAhB,IACCA,IAAI,KAAK,IADV,IAECsH,MAAM,CAAC0pB,IAAP,CAAYhxB,IAAZ,EAAkBhC,MAAlB,KAA6B,CAJjC,EAKE;AACA8lB,kBAAAA,IAAI,IACF,+DACA,0DADA,GAEA,gBAHF;AAID;;AACD,oBAAId,SAAS,GAAG9K,KAAK,GAAGnC,gBAAgB,CAACmC,KAAK,CAAClY,IAAP,CAAnB,GAAkC,IAAvD;;AACA,oBAAIgjB,SAAJ,EAAe;AACbc,kBAAAA,IAAI,IAAI,qCAAqCd,SAArC,GAAiD,IAAzD;AACD;AACF;AACD7qB,cAAAA,SAAS,CACP,KADO,EAEP,8DACE,6DADF,GAEE,gBAJK,EAKP6H,IAAI,IAAI,IAAR,GAAeA,IAAf,GAAsB,OAAOA,IALtB,EAMP8jB,IANO,CAAT;AAQD;AApEK;AAsET;;AAEDlM,MAAAA,KAAK,GAAGuY,WAAW,CAACS,QAAD,EAAWxB,YAAX,EAAyBrb,GAAzB,EAA8Bsb,IAA9B,CAAnB;AACAzX,MAAAA,KAAK,CAAC5X,IAAN,GAAaA,IAAb;AACA4X,MAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AAEA;AACEvQ,QAAAA,KAAK,CAAC+L,YAAN,GAAqBgN,OAAO,CAACM,OAA7B;AACArZ,QAAAA,KAAK,CAAC8L,WAAN,GAAoBiN,OAAO,CAACtV,MAA5B;AACD;AAED,aAAOzD,KAAP;AACD;;AAED,aAASkZ,uBAAT,CAAiCI,QAAjC,EAA2C7B,IAA3C,EAAiDlH,cAAjD,EAAiEpU,GAAjE,EAAsE;AACpE,UAAI6D,KAAK,GAAGuY,WAAW,CAAC3sB,QAAD,EAAW0tB,QAAX,EAAqBnd,GAArB,EAA0Bsb,IAA1B,CAAvB;AACAzX,MAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AACA,aAAOvQ,KAAP;AACD;;AAED,aAASmZ,uBAAT,CAAiC3B,YAAjC,EAA+CC,IAA/C,EAAqDlH,cAArD,EAAqEpU,GAArE,EAA0E;AACxE;AACE,YACE,OAAOqb,YAAY,CAAC+B,EAApB,KAA2B,QAA3B,IACA,OAAO/B,YAAY,CAACgC,QAApB,KAAiC,UAFnC,EAGE;AACA1yB,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,uEAFmB,CAArB;AAID;AACF;AAED,UAAIkZ,KAAK,GAAGuY,WAAW,CAACrsB,QAAD,EAAWsrB,YAAX,EAAyBrb,GAAzB,EAA8Bsb,IAAI,GAAGV,WAArC,CAAvB;AACA/W,MAAAA,KAAK,CAAC5X,IAAN,GAAa2U,mBAAb;AACAiD,MAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AAEA,aAAOvQ,KAAP;AACD;;AAED,aAASyZ,mBAAT,CAA6BC,OAA7B,EAAsCjC,IAAtC,EAA4ClH,cAA5C,EAA4D;AAC1D,UAAIvQ,KAAK,GAAGuY,WAAW,CAAC5sB,QAAD,EAAW+tB,OAAX,EAAoB,IAApB,EAA0BjC,IAA1B,CAAvB;AACAzX,MAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AACA,aAAOvQ,KAAP;AACD;;AAED,aAAS2Z,sCAAT,GAAkD;AAChD,UAAI3Z,KAAK,GAAGuY,WAAW,CAAC7sB,aAAD,EAAgB,IAAhB,EAAsB,IAAtB,EAA4BkrB,SAA5B,CAAvB;AACA5W,MAAAA,KAAK,CAAC5X,IAAN,GAAa,SAAb;AACA,aAAO4X,KAAP;AACD;;AAED,aAAS4Z,qBAAT,CAA+BC,MAA/B,EAAuCpC,IAAvC,EAA6ClH,cAA7C,EAA6D;AAC3D,UAAIiH,YAAY,GAAGqC,MAAM,CAAC9P,QAAP,KAAoB,IAApB,GAA2B8P,MAAM,CAAC9P,QAAlC,GAA6C,EAAhE;AACA,UAAI/J,KAAK,GAAGuY,WAAW,CAAC9sB,UAAD,EAAa+rB,YAAb,EAA2BqC,MAAM,CAAC1d,GAAlC,EAAuCsb,IAAvC,CAAvB;AACAzX,MAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AACAvQ,MAAAA,KAAK,CAACxV,SAAN,GAAkB;AAChBue,QAAAA,aAAa,EAAE8Q,MAAM,CAAC9Q,aADN;AAEhB+Q,QAAAA,eAAe,EAAE,IAFD;AAGhBC,QAAAA,cAAc,EAAEF,MAAM,CAACE;AAHP,OAAlB;AAKA,aAAO/Z,KAAP;AACD;;AAGD,aAASga,0BAAT,CAAoC3rB,MAApC,EAA4C8c,MAA5C,EAAoD;AAClD,UAAI9c,MAAM,KAAK,IAAf,EAAqB;AAGnBA,QAAAA,MAAM,GAAGkqB,WAAW,CAAChtB,sBAAD,EAAyB,IAAzB,EAA+B,IAA/B,EAAqCqrB,SAArC,CAApB;AACD;;AAQDvoB,MAAAA,MAAM,CAACnE,GAAP,GAAaihB,MAAM,CAACjhB,GAApB;AACAmE,MAAAA,MAAM,CAAC8N,GAAP,GAAagP,MAAM,CAAChP,GAApB;AACA9N,MAAAA,MAAM,CAACjG,IAAP,GAAc+iB,MAAM,CAAC/iB,IAArB;AACAiG,MAAAA,MAAM,CAAC7D,SAAP,GAAmB2gB,MAAM,CAAC3gB,SAA1B;AACA6D,MAAAA,MAAM,CAAChC,MAAP,GAAgB8e,MAAM,CAAC9e,MAAvB;AACAgC,MAAAA,MAAM,CAACyS,KAAP,GAAeqK,MAAM,CAACrK,KAAtB;AACAzS,MAAAA,MAAM,CAAC0S,OAAP,GAAiBoK,MAAM,CAACpK,OAAxB;AACA1S,MAAAA,MAAM,CAACuM,KAAP,GAAeuQ,MAAM,CAACvQ,KAAtB;AACAvM,MAAAA,MAAM,CAACqpB,GAAP,GAAavM,MAAM,CAACuM,GAApB;AACArpB,MAAAA,MAAM,CAACmpB,YAAP,GAAsBrM,MAAM,CAACqM,YAA7B;AACAnpB,MAAAA,MAAM,CAACspB,aAAP,GAAuBxM,MAAM,CAACwM,aAA9B;AACAtpB,MAAAA,MAAM,CAACupB,WAAP,GAAqBzM,MAAM,CAACyM,WAA5B;AACAvpB,MAAAA,MAAM,CAACwpB,aAAP,GAAuB1M,MAAM,CAAC0M,aAA9B;AACAxpB,MAAAA,MAAM,CAACypB,sBAAP,GAAgC3M,MAAM,CAAC2M,sBAAvC;AACAzpB,MAAAA,MAAM,CAACopB,IAAP,GAActM,MAAM,CAACsM,IAArB;AACAppB,MAAAA,MAAM,CAAC6R,SAAP,GAAmBiL,MAAM,CAACjL,SAA1B;AACA7R,MAAAA,MAAM,CAAC0pB,UAAP,GAAoB5M,MAAM,CAAC4M,UAA3B;AACA1pB,MAAAA,MAAM,CAAC2pB,WAAP,GAAqB7M,MAAM,CAAC6M,WAA5B;AACA3pB,MAAAA,MAAM,CAAC4pB,UAAP,GAAoB9M,MAAM,CAAC8M,UAA3B;AACA5pB,MAAAA,MAAM,CAACkiB,cAAP,GAAwBpF,MAAM,CAACoF,cAA/B;AACAliB,MAAAA,MAAM,CAAC6pB,mBAAP,GAA6B/M,MAAM,CAAC+M,mBAApC;AACA7pB,MAAAA,MAAM,CAACvB,SAAP,GAAmBqe,MAAM,CAACre,SAA1B;;AACA,UAAIogB,mBAAJ,EAAyB;AACvB7e,QAAAA,MAAM,CAAC8pB,cAAP,GAAwBhN,MAAM,CAACgN,cAA/B;AACA9pB,QAAAA,MAAM,CAAC+pB,eAAP,GAAyBjN,MAAM,CAACiN,eAAhC;AACA/pB,QAAAA,MAAM,CAACgqB,gBAAP,GAA0BlN,MAAM,CAACkN,gBAAjC;AACAhqB,QAAAA,MAAM,CAACiqB,gBAAP,GAA0BnN,MAAM,CAACmN,gBAAjC;AACD;;AACDjqB,MAAAA,MAAM,CAACkhB,QAAP,GAAkBpE,MAAM,CAACoE,QAAzB;AACAlhB,MAAAA,MAAM,CAAC0d,YAAP,GAAsBZ,MAAM,CAACY,YAA7B;AACA1d,MAAAA,MAAM,CAACyd,WAAP,GAAqBX,MAAM,CAACW,WAA5B;AACAzd,MAAAA,MAAM,CAAC0hB,uBAAP,GAAiC5E,MAAM,CAAC4E,uBAAxC;AACA,aAAO1hB,MAAP;AACD;;AAkBD,aAAS4rB,eAAT,CAAyBlR,aAAzB,EAAwC8P,OAAxC,EAAiDqB,OAAjD,EAA0D;AAGxD,UAAIC,kBAAkB,GAAGvB,mBAAmB,CAACC,OAAD,CAA5C;AAEA,UAAI1D,IAAI,GAAG,KAAK,CAAhB;;AACA,UAAIhI,uBAAJ,EAA6B;AAC3BgI,QAAAA,IAAI,GAAG;AACLjsB,UAAAA,OAAO,EAAEixB,kBADJ;AAELpR,UAAAA,aAAa,EAAEA,aAFV;AAGL+Q,UAAAA,eAAe,EAAE,IAHZ;AAKLM,UAAAA,mBAAmB,EAAE7E,MALhB;AAML8E,UAAAA,iBAAiB,EAAE9E,MANd;AAOL+E,UAAAA,qBAAqB,EAAE/E,MAPlB;AAQLgF,UAAAA,mBAAmB,EAAEhF,MARhB;AASLiF,UAAAA,gBAAgB,EAAEjF,MATb;AAWL/yB,UAAAA,QAAQ,EAAE,KAXL;AAaLi4B,UAAAA,2BAA2B,EAAElF,MAbxB;AAcLmF,UAAAA,YAAY,EAAE,IAdT;AAeLC,UAAAA,aAAa,EAAElR,SAfV;AAgBLloB,UAAAA,OAAO,EAAE,IAhBJ;AAiBLq5B,UAAAA,cAAc,EAAE,IAjBX;AAkBLV,UAAAA,OAAO,EAAEA,OAlBJ;AAmBLW,UAAAA,0BAA0B,EAAEtF,MAnBvB;AAoBLhF,UAAAA,cAAc,EAAEgF,MApBX;AAqBLuF,UAAAA,UAAU,EAAE,IArBP;AAsBLC,UAAAA,iBAAiB,EAAE,IAtBd;AAwBLC,UAAAA,mBAAmB,EAAE/6B,QAAQ,CAACg7B,oBAAT,EAxBhB;AAyBLC,UAAAA,oBAAoB,EAAE,IAAI9M,GAAJ,EAzBjB;AA0BL+M,UAAAA,qBAAqB,EAAE,IAAI/D,GAAJ;AA1BlB,SAAP;AA4BD,OA7BD,MA6BO;AACLjC,QAAAA,IAAI,GAAG;AACLjsB,UAAAA,OAAO,EAAEixB,kBADJ;AAELpR,UAAAA,aAAa,EAAEA,aAFV;AAGL+Q,UAAAA,eAAe,EAAE,IAHZ;AAKLM,UAAAA,mBAAmB,EAAE7E,MALhB;AAML8E,UAAAA,iBAAiB,EAAE9E,MANd;AAOL+E,UAAAA,qBAAqB,EAAE/E,MAPlB;AAQLgF,UAAAA,mBAAmB,EAAEhF,MARhB;AASLiF,UAAAA,gBAAgB,EAAEjF,MATb;AAWL/yB,UAAAA,QAAQ,EAAE,KAXL;AAaLi4B,UAAAA,2BAA2B,EAAElF,MAbxB;AAcLmF,UAAAA,YAAY,EAAE,IAdT;AAeLC,UAAAA,aAAa,EAAElR,SAfV;AAgBLloB,UAAAA,OAAO,EAAE,IAhBJ;AAiBLq5B,UAAAA,cAAc,EAAE,IAjBX;AAkBLV,UAAAA,OAAO,EAAEA,OAlBJ;AAmBLW,UAAAA,0BAA0B,EAAEtF,MAnBvB;AAoBLhF,UAAAA,cAAc,EAAEgF,MApBX;AAqBLuF,UAAAA,UAAU,EAAE,IArBP;AAsBLC,UAAAA,iBAAiB,EAAE;AAtBd,SAAP;AAwBD;;AAEDZ,MAAAA,kBAAkB,CAAC3vB,SAAnB,GAA+B2qB,IAA/B;AAMA,aAAOA,IAAP;AACD;;AAgBD,QAAIiG,kBAAkB,GAAG,8BAAW,CAAE,CAAtC;;AAEA;AACE,UAAIC,YAAY,GAAG,SAAfA,YAAe,CAASj7B,MAAT,EAAiB;AAClC,aACE,IAAI+F,IAAI,GAAGtE,SAAS,CAACuE,MAArB,EACEpF,IAAI,GAAGS,KAAK,CAAC0E,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAvB,CADd,EAEEE,IAAI,GAAG,CAHX,EAIEA,IAAI,GAAGF,IAJT,EAKEE,IAAI,EALN,EAME;AACArF,UAAAA,IAAI,CAACqF,IAAI,GAAG,CAAR,CAAJ,GAAiBxE,SAAS,CAACwE,IAAD,CAA1B;AACD;;AAED,YAAIpF,QAAQ,GAAG,CAAf;AACA,YAAI2F,OAAO,GACT,cACAxG,MAAM,CAACc,OAAP,CAAe,KAAf,EAAsB,YAAW;AAC/B,iBAAOF,IAAI,CAACC,QAAQ,EAAT,CAAX;AACD,SAFD,CAFF;;AAKA,YAAI,OAAOqF,OAAP,KAAmB,WAAvB,EAAoC;AAClCA,UAAAA,OAAO,CAACoK,IAAR,CAAa9J,OAAb;AACD;;AACD,YAAI;AAIF,gBAAM,IAAItG,KAAJ,CAAUsG,OAAV,CAAN;AACD,SALD,CAKE,OAAOC,CAAP,EAAU,CAAE;AACf,OA1BD;;AA4BAu0B,MAAAA,kBAAkB,GAAG,4BAAS56B,SAAT,EAAoBJ,MAApB,EAA4B;AAC/C,YAAIA,MAAM,KAAKC,SAAf,EAA0B;AACxB,gBAAM,IAAIC,KAAJ,CACJ,yEACE,kBAFE,CAAN;AAID;;AACD,YAAI,CAACE,SAAL,EAAgB;AACd,eACE,IAAI86B,KAAK,GAAGz5B,SAAS,CAACuE,MAAtB,EACEpF,IAAI,GAAGS,KAAK,CAAC65B,KAAK,GAAG,CAAR,GAAYA,KAAK,GAAG,CAApB,GAAwB,CAAzB,CADd,EAEEC,KAAK,GAAG,CAHZ,EAIEA,KAAK,GAAGD,KAJV,EAKEC,KAAK,EALP,EAME;AACAv6B,YAAAA,IAAI,CAACu6B,KAAK,GAAG,CAAT,CAAJ,GAAkB15B,SAAS,CAAC05B,KAAD,CAA3B;AACD;;AAEDF,UAAAA,YAAY,CAACv5B,KAAb,CAAmBzB,SAAnB,EAA8B,CAACD,MAAD,EAASuG,MAAT,CAAgB3F,IAAhB,CAA9B;AACD;AACF,OApBD;AAqBD;AAED,QAAIw6B,oBAAoB,GAAGJ,kBAA3B;AAEA,QAAIK,uBAAuB,GAAG;AAC5BC,MAAAA,sBAAsB,EAAE,kCAAW,CAAE,CADT;AAE5BC,MAAAA,+BAA+B,EAAE,2CAAW,CAAE,CAFlB;AAG5BC,MAAAA,mCAAmC,EAAE,+CAAW,CAAE,CAHtB;AAI5BC,MAAAA,yBAAyB,EAAE,mCAAS7b,KAAT,EAAgB/O,QAAhB,EAA0B,CAAE,CAJ3B;AAK5B6qB,MAAAA,6BAA6B,EAAE,uCAAS9b,KAAT,EAAgB/O,QAAhB,EAA0B,CAAE,CAL/B;AAM5B8qB,MAAAA,0BAA0B,EAAE,oCAAS/b,KAAT,EAAgB/O,QAAhB,EAA0B,CAAE,CAN5B;AAO5B+qB,MAAAA,yBAAyB,EAAE,qCAAW,CAAE;AAPZ,KAA9B;AAUA;AACE,UAAIC,qBAAqB,GAAG;AAC1BC,QAAAA,yBAAyB,EAAE,mBADD;AAE1BC,QAAAA,gCAAgC,EAAE,iCAFR;AAG1BC,QAAAA,0BAA0B,EAAE;AAHF,OAA5B;AAMA,UAAIC,iCAAiC,GAAG,EAAxC;AACA,UAAIC,wCAAwC,GAAG,EAA/C;AACA,UAAIC,kCAAkC,GAAG,EAAzC;AACA,UAAIC,8BAA8B,GAAG,IAAIpF,GAAJ,EAArC;AACA,UAAIqF,2BAA2B,GAAG,IAAIrF,GAAJ,EAAlC;AAGA,UAAIsF,gCAAgC,GAAG,IAAItO,GAAJ,EAAvC;AACA,UAAIuO,4BAA4B,GAAG,IAAIvO,GAAJ,EAAnC;AACA,UAAIwO,yBAAyB,GAAG,IAAIxO,GAAJ,EAAhC;;AAEA,UAAIyO,iBAAiB,GAAG,SAApBA,iBAAoB,CAASxsB,GAAT,EAAc;AACpC,YAAIysB,KAAK,GAAG,EAAZ;AACAzsB,QAAAA,GAAG,CAAC5G,OAAJ,CAAY,UAAS4S,KAAT,EAAgB;AAC1BygB,UAAAA,KAAK,CAAC1zB,IAAN,CAAWiT,KAAX;AACD,SAFD;AAGA,eAAOygB,KAAK,CAACC,IAAN,GAAaC,IAAb,CAAkB,IAAlB,CAAP;AACD,OAND;;AAQAvB,MAAAA,uBAAuB,CAACC,sBAAxB,GAAiD,YAAW;AAC1DW,QAAAA,iCAAiC,GAAG,EAApC;AACAC,QAAAA,wCAAwC,GAAG,EAA3C;AACAC,QAAAA,kCAAkC,GAAG,EAArC;AACAC,QAAAA,8BAA8B,GAAG,IAAIpF,GAAJ,EAAjC;AACAqF,QAAAA,2BAA2B,GAAG,IAAIrF,GAAJ,EAA9B;AACD,OAND;;AAQAqE,MAAAA,uBAAuB,CAACG,mCAAxB,GAA8D,YAAW;AACvEY,QAAAA,8BAA8B,CAAC/yB,OAA/B,CAAuC,UACrCwzB,oBADqC,EAErCC,UAFqC,EAGrC;AACA,cAAIC,wBAAwB,GAAG,EAA/B;AAEAztB,UAAAA,MAAM,CAAC0pB,IAAP,CAAY6D,oBAAZ,EAAkCxzB,OAAlC,CAA0C,UAAS2zB,SAAT,EAAoB;AAC5D,gBAAIC,iBAAiB,GAAGJ,oBAAoB,CAACG,SAAD,CAA5C;;AACA,gBAAIC,iBAAiB,CAACj3B,MAAlB,GAA2B,CAA/B,EAAkC;AAChC,kBAAIk3B,cAAc,GAAG,IAAIlP,GAAJ,EAArB;AACAiP,cAAAA,iBAAiB,CAAC5zB,OAAlB,CAA0B,UAASuW,KAAT,EAAgB;AACxCsd,gBAAAA,cAAc,CAAC7N,GAAf,CAAmBtR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,WAAnD;AACAu0B,gBAAAA,4BAA4B,CAAClN,GAA7B,CAAiCzP,KAAK,CAAC5X,IAAvC;AACD,eAHD;AAKA,kBAAIm1B,SAAS,GAAGH,SAAS,CAACl8B,OAAV,CAAkB,SAAlB,EAA6B,EAA7B,CAAhB;AACA,kBAAIs8B,UAAU,GAAGvB,qBAAqB,CAACmB,SAAD,CAAtC;AACA,kBAAIK,oBAAoB,GAAGZ,iBAAiB,CAACS,cAAD,CAA5C;AAEAH,cAAAA,wBAAwB,CAAC/zB,IAAzB,CACEm0B,SAAS,GACP,kDADF,IAEGC,UAAU,GAAG,YAAb,GAA4BC,oBAF/B,CADF;AAKD;AACF,WAnBD;;AAqBA,cAAIN,wBAAwB,CAAC/2B,MAAzB,GAAkC,CAAtC,EAAyC;AACvC,gBAAIs3B,wBAAwB,GAAG1R,2BAA2B,CAACkR,UAAD,CAA1D;AAEAp2B,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,qEACE,QADF,GAEE,yCAFF,GAGE,4CALiB,EAMnB42B,wBANmB,EAOnBP,wBAAwB,CAACH,IAAzB,CAA8B,MAA9B,CAPmB,CAArB;AASD;AACF,SAxCD;AA0CAR,QAAAA,8BAA8B,GAAG,IAAIpF,GAAJ,EAAjC;AACD,OA5CD;;AA8CA,UAAIuG,cAAc,GAAG,SAAjBA,cAAiB,CAAS3d,KAAT,EAAgB;AACnC,YAAI4d,eAAe,GAAG,IAAtB;AAEA,YAAI3d,IAAI,GAAGD,KAAX;;AACA,eAAOC,IAAI,KAAK,IAAhB,EAAsB;AACpB,cAAIA,IAAI,CAACwX,IAAL,GAAYX,UAAhB,EAA4B;AAC1B8G,YAAAA,eAAe,GAAG3d,IAAlB;AACD;;AACDA,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AAED,eAAOuxB,eAAP;AACD,OAZD;;AAcAnC,MAAAA,uBAAuB,CAACE,+BAAxB,GAA0D,YAAW;AACnE,YAAIU,iCAAiC,CAACj2B,MAAlC,GAA2C,CAA/C,EAAkD;AAChD,cAAIy3B,WAAW,GAAG,IAAIzP,GAAJ,EAAlB;AACAiO,UAAAA,iCAAiC,CAAC5yB,OAAlC,CAA0C,UAASuW,KAAT,EAAgB;AACxD6d,YAAAA,WAAW,CAACpO,GAAZ,CAAgBtR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,WAAhD;AACAs0B,YAAAA,gCAAgC,CAACjN,GAAjC,CAAqCzP,KAAK,CAAC5X,IAA3C;AACD,WAHD;AAKA,cAAI01B,WAAW,GAAGjB,iBAAiB,CAACgB,WAAD,CAAnC;AAEArC,UAAAA,oBAAoB,CAClB,KADkB,EAElB,qFACE,4DADF,GAEE,8CAFF,GAGE,gDAHF,GAIE,yCAJF,GAKE,uDAPgB,EAQlBsC,WARkB,CAApB;AAWAzB,UAAAA,iCAAiC,GAAG,EAApC;AACD;;AAED,YAAIC,wCAAwC,CAACl2B,MAAzC,GAAkD,CAAtD,EAAyD;AACvD,cAAI23B,YAAY,GAAG,IAAI3P,GAAJ,EAAnB;;AACAkO,UAAAA,wCAAwC,CAAC7yB,OAAzC,CAAiD,UAASuW,KAAT,EAAgB;AAC/D+d,YAAAA,YAAY,CAACtO,GAAb,CAAiBtR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,WAAjD;;AACAs0B,YAAAA,gCAAgC,CAACjN,GAAjC,CAAqCzP,KAAK,CAAC5X,IAA3C;AACD,WAHD;;AAKA,cAAI41B,YAAY,GAAGnB,iBAAiB,CAACkB,YAAD,CAApC;;AAEAvC,UAAAA,oBAAoB,CAClB,KADkB,EAElB,4FACE,8CADF,GAEE,gDAFF,GAGE,yCAHF,GAIE,uDANgB,EAOlBwC,YAPkB,CAApB;AAUA1B,UAAAA,wCAAwC,GAAG,EAA3C;AACD;;AAED,YAAIC,kCAAkC,CAACn2B,MAAnC,GAA4C,CAAhD,EAAmD;AACjD,cAAI63B,aAAa,GAAG,IAAI7P,GAAJ,EAApB;;AACAmO,UAAAA,kCAAkC,CAAC9yB,OAAnC,CAA2C,UAASuW,KAAT,EAAgB;AACzDie,YAAAA,aAAa,CAACxO,GAAd,CAAkBtR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,WAAlD;;AACAs0B,YAAAA,gCAAgC,CAACjN,GAAjC,CAAqCzP,KAAK,CAAC5X,IAA3C;AACD,WAHD;;AAKA,cAAI81B,aAAa,GAAGrB,iBAAiB,CAACoB,aAAD,CAArC;;AAEAzC,UAAAA,oBAAoB,CAClB,KADkB,EAElB,sFACE,6DADF,GAEE,+CAFF,GAGE,gDAHF,GAIE,yCAJF,GAKE,uDAPgB,EAQlB0C,aARkB,CAApB;AAWA3B,UAAAA,kCAAkC,GAAG,EAArC;AACD;AACF,OApED;;AAsEAd,MAAAA,uBAAuB,CAACI,yBAAxB,GAAoD,UAClD7b,KADkD,EAElD/O,QAFkD,EAGlD;AAEA,YAAIyrB,gCAAgC,CAAClN,GAAjC,CAAqCxP,KAAK,CAAC5X,IAA3C,CAAJ,EAAsD;AACpD;AACD;;AAGD,YACE,OAAO6I,QAAQ,CAACktB,kBAAhB,KAAuC,UAAvC,IACAltB,QAAQ,CAACktB,kBAAT,CAA4BC,4BAA5B,KAA6D,IAF/D,EAGE;AACA/B,UAAAA,iCAAiC,CAACjzB,IAAlC,CAAuC4W,KAAvC;AACD;;AACD,YACE,OAAO/O,QAAQ,CAACotB,yBAAhB,KAA8C,UAA9C,IACAptB,QAAQ,CAACotB,yBAAT,CAAmCD,4BAAnC,KAAoE,IAFtE,EAGE;AACA9B,UAAAA,wCAAwC,CAAClzB,IAAzC,CAA8C4W,KAA9C;AACD;;AACD,YACE,OAAO/O,QAAQ,CAACqtB,mBAAhB,KAAwC,UAAxC,IACArtB,QAAQ,CAACqtB,mBAAT,CAA6BF,4BAA7B,KAA8D,IAFhE,EAGE;AACA7B,UAAAA,kCAAkC,CAACnzB,IAAnC,CAAwC4W,KAAxC;AACD;AACF,OA5BD;;AA8BAyb,MAAAA,uBAAuB,CAACK,6BAAxB,GAAwD,UACtD9b,KADsD,EAEtD/O,QAFsD,EAGtD;AACA,YAAIisB,UAAU,GAAGS,cAAc,CAAC3d,KAAD,CAA/B;;AACA,YAAIkd,UAAU,KAAK,IAAnB,EAAyB;AACvBp2B,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,oEACE,sEAHiB,CAArB;AAKA;AACD;;AAOD,YAAI61B,4BAA4B,CAACnN,GAA7B,CAAiCxP,KAAK,CAAC5X,IAAvC,CAAJ,EAAkD;AAChD;AACD;;AAED,YAAIm2B,eAAe,GAAG,KAAK,CAA3B;;AACA,YAAI,CAAC/B,8BAA8B,CAAChN,GAA/B,CAAmC0N,UAAnC,CAAL,EAAqD;AACnDqB,UAAAA,eAAe,GAAG;AAChBrC,YAAAA,yBAAyB,EAAE,EADX;AAEhBC,YAAAA,gCAAgC,EAAE,EAFlB;AAGhBC,YAAAA,0BAA0B,EAAE;AAHZ,WAAlB;AAMAI,UAAAA,8BAA8B,CAACnsB,GAA/B,CAAmC6sB,UAAnC,EAA+CqB,eAA/C;AACD,SARD,MAQO;AACLA,UAAAA,eAAe,GAAG/B,8BAA8B,CAAClsB,GAA/B,CAAmC4sB,UAAnC,CAAlB;AACD;;AAED,YAAIsB,gBAAgB,GAAG,EAAvB;;AACA,YACG,OAAOvtB,QAAQ,CAACktB,kBAAhB,KAAuC,UAAvC,IACCltB,QAAQ,CAACktB,kBAAT,CAA4BC,4BAA5B,KAA6D,IAD/D,IAEA,OAAOntB,QAAQ,CAACirB,yBAAhB,KAA8C,UAHhD,EAIE;AACAsC,UAAAA,gBAAgB,CAACp1B,IAAjB,CAAsB,2BAAtB;AACD;;AACD,YACG,OAAO6H,QAAQ,CAACotB,yBAAhB,KAA8C,UAA9C,IACCptB,QAAQ,CAACotB,yBAAT,CAAmCD,4BAAnC,KACE,IAFJ,IAGA,OAAOntB,QAAQ,CAACkrB,gCAAhB,KAAqD,UAJvD,EAKE;AACAqC,UAAAA,gBAAgB,CAACp1B,IAAjB,CAAsB,kCAAtB;AACD;;AACD,YACG,OAAO6H,QAAQ,CAACqtB,mBAAhB,KAAwC,UAAxC,IACCrtB,QAAQ,CAACqtB,mBAAT,CAA6BF,4BAA7B,KAA8D,IADhE,IAEA,OAAOntB,QAAQ,CAACmrB,0BAAhB,KAA+C,UAHjD,EAIE;AACAoC,UAAAA,gBAAgB,CAACp1B,IAAjB,CAAsB,4BAAtB;AACD;;AAED,YAAIo1B,gBAAgB,CAACp4B,MAAjB,GAA0B,CAA9B,EAAiC;AAC/Bo4B,UAAAA,gBAAgB,CAAC/0B,OAAjB,CAAyB,UAAS2zB,SAAT,EAAoB;AAC3CmB,YAAAA,eAAe,CAACnB,SAAD,CAAf,CAA2Bh0B,IAA3B,CAAgC4W,KAAhC;AACD,WAFD;AAGD;AACF,OAjED;;AAmEAyb,MAAAA,uBAAuB,CAACM,0BAAxB,GAAqD,UACnD/b,KADmD,EAEnD/O,QAFmD,EAGnD;AACA,YAAIisB,UAAU,GAAGS,cAAc,CAAC3d,KAAD,CAA/B;;AACA,YAAIkd,UAAU,KAAK,IAAnB,EAAyB;AACvBp2B,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,oEACE,sEAHiB,CAArB;AAKA;AACD;;AAGD,YAAI81B,yBAAyB,CAACpN,GAA1B,CAA8BxP,KAAK,CAAC5X,IAApC,CAAJ,EAA+C;AAC7C;AACD;;AAED,YAAIm2B,eAAe,GAAG9B,2BAA2B,CAACnsB,GAA5B,CAAgC4sB,UAAhC,CAAtB;;AAEA,YACEld,KAAK,CAAC5X,IAAN,CAAW+qB,YAAX,IAA2B,IAA3B,IACAnT,KAAK,CAAC5X,IAAN,CAAWirB,iBAAX,IAAgC,IADhC,IAECpiB,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAQ,CAAC2iB,eAAhB,KAAoC,UAH5D,EAIE;AACA,cAAI2K,eAAe,KAAKl+B,SAAxB,EAAmC;AACjCk+B,YAAAA,eAAe,GAAG,EAAlB;AACA9B,YAAAA,2BAA2B,CAACpsB,GAA5B,CAAgC6sB,UAAhC,EAA4CqB,eAA5C;AACD;;AACDA,UAAAA,eAAe,CAACn1B,IAAhB,CAAqB4W,KAArB;AACD;AACF,OAhCD;;AAkCAyb,MAAAA,uBAAuB,CAACO,yBAAxB,GAAoD,YAAW;AAC7DS,QAAAA,2BAA2B,CAAChzB,OAA5B,CAAoC,UAASg1B,UAAT,EAAqBvB,UAArB,EAAiC;AACnE,cAAIW,WAAW,GAAG,IAAIzP,GAAJ,EAAlB;AACAqQ,UAAAA,UAAU,CAACh1B,OAAX,CAAmB,UAASuW,KAAT,EAAgB;AACjC6d,YAAAA,WAAW,CAACpO,GAAZ,CAAgBtR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,WAAhD;AACAw0B,YAAAA,yBAAyB,CAACnN,GAA1B,CAA8BzP,KAAK,CAAC5X,IAApC;AACD,WAHD;AAKA,cAAI01B,WAAW,GAAGjB,iBAAiB,CAACgB,WAAD,CAAnC;AACA,cAAIH,wBAAwB,GAAG1R,2BAA2B,CAACkR,UAAD,CAA1D;AAEAp2B,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,uEACE,gDADF,GAEE,yCAFF,GAGE,4CALiB,EAMnB42B,wBANmB,EAOnBI,WAPmB,CAArB;AASD,SAnBD;AAoBD,OArBD;AAsBD;AAMD,QAAIY,yBAAyB,GAAG;AAC9BC,MAAAA,SAAS,EAAE;AADmB,KAAhC;AAIA,QAAIC,2BAA2B,GAAGF,yBAAlC;;AAMA,aAASG,wBAAT,CAAkC1J,IAAlC,EAAwC5E,cAAxC,EAAwD;AAItD4E,MAAAA,IAAI,CAAC3yB,QAAL,GAAgB,KAAhB;AAGA,UAAI43B,mBAAmB,GAAGjF,IAAI,CAACiF,mBAA/B;;AACA,UAAIA,mBAAmB,KAAK7E,MAA5B,EAAoC;AAElCJ,QAAAA,IAAI,CAACiF,mBAAL,GAA2BjF,IAAI,CAACkF,iBAAL,GAAyB9J,cAApD;AACD,OAHD,MAGO;AACL,YAAI6J,mBAAmB,GAAG7J,cAA1B,EAA0C;AAExC4E,UAAAA,IAAI,CAACiF,mBAAL,GAA2B7J,cAA3B;AACD,SAHD,MAGO;AACL,cAAI8J,iBAAiB,GAAGlF,IAAI,CAACkF,iBAA7B;;AACA,cAAIA,iBAAiB,GAAG9J,cAAxB,EAAwC;AAEtC4E,YAAAA,IAAI,CAACkF,iBAAL,GAAyB9J,cAAzB;AACD;AACF;AACF;;AACDuO,MAAAA,8BAA8B,CAACvO,cAAD,EAAiB4E,IAAjB,CAA9B;AACD;;AAED,aAAS4J,2BAAT,CAAqC5J,IAArC,EAA2C6J,qBAA3C,EAAkE;AAChE7J,MAAAA,IAAI,CAAC3yB,QAAL,GAAgB,KAAhB;;AAEA,UAAIw8B,qBAAqB,KAAKzJ,MAA9B,EAAsC;AAEpCJ,QAAAA,IAAI,CAACiF,mBAAL,GAA2B7E,MAA3B;AACAJ,QAAAA,IAAI,CAACkF,iBAAL,GAAyB9E,MAAzB;AACAJ,QAAAA,IAAI,CAACmF,qBAAL,GAA6B/E,MAA7B;AACAJ,QAAAA,IAAI,CAACoF,mBAAL,GAA2BhF,MAA3B;AACAJ,QAAAA,IAAI,CAACqF,gBAAL,GAAwBjF,MAAxB;AACAuJ,QAAAA,8BAA8B,CAACvJ,MAAD,EAASJ,IAAT,CAA9B;AACA;AACD;;AAGD,UAAIkF,iBAAiB,GAAGlF,IAAI,CAACkF,iBAA7B;;AACA,UAAIA,iBAAiB,KAAK9E,MAA1B,EAAkC;AAChC,YAAI8E,iBAAiB,GAAG2E,qBAAxB,EAA+C;AAE7C7J,UAAAA,IAAI,CAACiF,mBAAL,GAA2BjF,IAAI,CAACkF,iBAAL,GAAyB9E,MAApD;AACD,SAHD,MAGO;AACL,cAAI6E,mBAAmB,GAAGjF,IAAI,CAACiF,mBAA/B;;AACA,cAAIA,mBAAmB,GAAG4E,qBAA1B,EAAiD;AAG/C7J,YAAAA,IAAI,CAACiF,mBAAL,GAA2BjF,IAAI,CAACkF,iBAAhC;AACD;AACF;AACF;;AAMD,UAAIC,qBAAqB,GAAGnF,IAAI,CAACmF,qBAAjC;;AACA,UAAIA,qBAAqB,KAAK/E,MAA9B,EAAsC;AAGpCsJ,QAAAA,wBAAwB,CAAC1J,IAAD,EAAO6J,qBAAP,CAAxB;AACAF,QAAAA,8BAA8B,CAACvJ,MAAD,EAASJ,IAAT,CAA9B;AACA;AACD;;AAED,UAAIoF,mBAAmB,GAAGpF,IAAI,CAACoF,mBAA/B;;AACA,UAAIyE,qBAAqB,GAAGzE,mBAA5B,EAAiD;AAG/CpF,QAAAA,IAAI,CAACmF,qBAAL,GAA6B/E,MAA7B;AACAJ,QAAAA,IAAI,CAACoF,mBAAL,GAA2BhF,MAA3B;AACAJ,QAAAA,IAAI,CAACqF,gBAAL,GAAwBjF,MAAxB;AAIAsJ,QAAAA,wBAAwB,CAAC1J,IAAD,EAAO6J,qBAAP,CAAxB;AACAF,QAAAA,8BAA8B,CAACvJ,MAAD,EAASJ,IAAT,CAA9B;AACA;AACD;;AAED,UAAI6J,qBAAqB,GAAG1E,qBAA5B,EAAmD;AAGjDuE,QAAAA,wBAAwB,CAAC1J,IAAD,EAAO6J,qBAAP,CAAxB;AACAF,QAAAA,8BAA8B,CAACvJ,MAAD,EAASJ,IAAT,CAA9B;AACA;AACD;;AAID2J,MAAAA,8BAA8B,CAACvJ,MAAD,EAASJ,IAAT,CAA9B;AACD;;AAED,aAAS8J,oBAAT,CAA8B9J,IAA9B,EAAoC+J,qBAApC,EAA2D;AACzD,UAAI7E,iBAAiB,GAAGlF,IAAI,CAACkF,iBAA7B;AACA,UAAIE,mBAAmB,GAAGpF,IAAI,CAACoF,mBAA/B;AACA,UAAIC,gBAAgB,GAAGrF,IAAI,CAACqF,gBAA5B;AACA,aACGH,iBAAiB,KAAK9E,MAAtB,IACC8E,iBAAiB,GAAG6E,qBADtB,IAEC3E,mBAAmB,KAAKhF,MAAxB,IACCgF,mBAAmB,GAAG2E,qBAHxB,IAIC1E,gBAAgB,KAAKjF,MAArB,IAA+BiF,gBAAgB,GAAG0E,qBALrD;AAOD;;AAED,aAASC,wBAAT,CAAkChK,IAAlC,EAAwC5E,cAAxC,EAAwD;AACtD,UAAI+J,qBAAqB,GAAGnF,IAAI,CAACmF,qBAAjC;AACA,UAAIC,mBAAmB,GAAGpF,IAAI,CAACoF,mBAA/B;AACA,aACED,qBAAqB,KAAK/E,MAA1B,IACAhF,cAAc,IAAI+J,qBADlB,IAEA/J,cAAc,IAAIgK,mBAHpB;AAKD;;AAED,aAAS6E,0BAAT,CAAoCjK,IAApC,EAA0CkK,aAA1C,EAAyD;AACvDlK,MAAAA,IAAI,CAAC3yB,QAAL,GAAgB,KAAhB;AACA88B,MAAAA,SAAS,CAACnK,IAAD,EAAOkK,aAAP,CAAT;AAGA,UAAIjF,mBAAmB,GAAGjF,IAAI,CAACiF,mBAA/B;AACA,UAAIC,iBAAiB,GAAGlF,IAAI,CAACkF,iBAA7B;;AACA,UAAID,mBAAmB,KAAKiF,aAA5B,EAA2C;AACzC,YAAIhF,iBAAiB,KAAKgF,aAA1B,EAAyC;AAEvClK,UAAAA,IAAI,CAACiF,mBAAL,GAA2BjF,IAAI,CAACkF,iBAAL,GAAyB9E,MAApD;AACD,SAHD,MAGO;AAGLJ,UAAAA,IAAI,CAACiF,mBAAL,GAA2BC,iBAA3B;AACD;AACF,OATD,MASO,IAAIA,iBAAiB,KAAKgF,aAA1B,EAAyC;AAG9ClK,QAAAA,IAAI,CAACkF,iBAAL,GAAyBD,mBAAzB;AACD;;AAGD,UAAIE,qBAAqB,GAAGnF,IAAI,CAACmF,qBAAjC;AACA,UAAIC,mBAAmB,GAAGpF,IAAI,CAACoF,mBAA/B;;AACA,UAAID,qBAAqB,KAAK/E,MAA9B,EAAsC;AAEpCJ,QAAAA,IAAI,CAACmF,qBAAL,GAA6BnF,IAAI,CAACoF,mBAAL,GAA2B8E,aAAxD;AACD,OAHD,MAGO;AACL,YAAI/E,qBAAqB,GAAG+E,aAA5B,EAA2C;AAEzClK,UAAAA,IAAI,CAACmF,qBAAL,GAA6B+E,aAA7B;AACD,SAHD,MAGO,IAAI9E,mBAAmB,GAAG8E,aAA1B,EAAyC;AAE9ClK,UAAAA,IAAI,CAACoF,mBAAL,GAA2B8E,aAA3B;AACD;AACF;;AAEDP,MAAAA,8BAA8B,CAACO,aAAD,EAAgBlK,IAAhB,CAA9B;AACD;;AAED,aAASoK,uBAAT,CAAiCpK,IAAjC,EAAuCqK,UAAvC,EAAmD;AACjDrK,MAAAA,IAAI,CAAC3yB,QAAL,GAAgB,KAAhB;AAKA,UAAIg4B,gBAAgB,GAAGrF,IAAI,CAACqF,gBAA5B;;AACA,UAAIA,gBAAgB,KAAKjF,MAArB,IAA+BiF,gBAAgB,GAAGgF,UAAtD,EAAkE;AAChErK,QAAAA,IAAI,CAACqF,gBAAL,GAAwBgF,UAAxB;AACD;;AACDV,MAAAA,8BAA8B,CAACU,UAAD,EAAarK,IAAb,CAA9B;AACD;;AAED,aAASmK,SAAT,CAAmBnK,IAAnB,EAAyBsK,aAAzB,EAAwC;AAGtC,UAAIjF,gBAAgB,GAAGrF,IAAI,CAACqF,gBAA5B;;AACA,UAAIA,gBAAgB,KAAKjF,MAArB,IAA+BiF,gBAAgB,IAAIiF,aAAvD,EAAsE;AACpEtK,QAAAA,IAAI,CAACqF,gBAAL,GAAwBjF,MAAxB;AACD;AACF;;AAED,aAASmK,oCAAT,CAA8CvK,IAA9C,EAAoDwK,oBAApD,EAA0E;AACxE,UAAIC,sBAAsB,GAAGD,oBAA7B;AAEA,UAAIvF,mBAAmB,GAAGjF,IAAI,CAACiF,mBAA/B;AACA,UAAIE,qBAAqB,GAAGnF,IAAI,CAACmF,qBAAjC;;AACA,UACEsF,sBAAsB,KAAKrK,MAA3B,IACC6E,mBAAmB,KAAK7E,MAAxB,IACC6E,mBAAmB,GAAGwF,sBAH1B,EAIE;AACAA,QAAAA,sBAAsB,GAAGxF,mBAAzB;AACD;;AACD,UACEwF,sBAAsB,KAAKrK,MAA3B,IACC+E,qBAAqB,KAAK/E,MAA1B,IACC+E,qBAAqB,GAAGsF,sBAH5B,EAIE;AACAA,QAAAA,sBAAsB,GAAGtF,qBAAzB;AACD;;AACD,aAAOsF,sBAAP;AACD;;AAED,aAASC,yBAAT,CAAmC1K,IAAnC,EAAyCgB,WAAzC,EAAsD;AACpD,UAAI5F,cAAc,GAAG4E,IAAI,CAAC5E,cAA1B;;AACA,UAAIA,cAAc,KAAKgF,MAAnB,IAA6BY,WAAW,IAAI5F,cAAhD,EAAgE;AAE9D4E,QAAAA,IAAI,CAAC0F,0BAAL,GAAkC1E,WAAlC;AACD;AACF;;AAED,aAAS2I,8BAAT,CAAwCgB,uBAAxC,EAAiE3K,IAAjE,EAAuE;AACrE,UAAImF,qBAAqB,GAAGnF,IAAI,CAACmF,qBAAjC;AACA,UAAIC,mBAAmB,GAAGpF,IAAI,CAACoF,mBAA/B;AACA,UAAIH,mBAAmB,GAAGjF,IAAI,CAACiF,mBAA/B;AACA,UAAII,gBAAgB,GAAGrF,IAAI,CAACqF,gBAA5B;AAIA,UAAIK,0BAA0B,GAC5BT,mBAAmB,KAAK7E,MAAxB,GAAiC6E,mBAAjC,GAAuDI,gBADzD;;AAKA,UACEK,0BAA0B,KAAKtF,MAA/B,KACCuK,uBAAuB,KAAKvK,MAA5B,IACCgF,mBAAmB,GAAGuF,uBAFxB,CADF,EAIE;AAIAjF,QAAAA,0BAA0B,GAAGN,mBAA7B;AACD;;AAED,UAAIhK,cAAc,GAAGsK,0BAArB;;AACA,UACEtK,cAAc,KAAKgF,MAAnB,IACA+E,qBAAqB,KAAK/E,MAD1B,IAEA+E,qBAAqB,GAAG/J,cAH1B,EAIE;AAEAA,QAAAA,cAAc,GAAG+J,qBAAjB;AACD;;AAEDnF,MAAAA,IAAI,CAAC0F,0BAAL,GAAkCA,0BAAlC;AACA1F,MAAAA,IAAI,CAAC5E,cAAL,GAAsBA,cAAtB;AACD;;AA+ED,QAAIwP,WAAW,GAAG,CAAlB;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,aAAa,GAAG,CAApB;AAKA,QAAIC,cAAc,GAAG,KAArB;AAEA,QAAIC,yBAAyB,GAAG,KAAK,CAArC;AACA,QAAIC,wBAAwB,GAAG,KAAK,CAApC;AACA,QAAIC,6BAA6B,GAAG,KAAK,CAAzC;AACA;AACEF,MAAAA,yBAAyB,GAAG,KAA5B;AACAC,MAAAA,wBAAwB,GAAG,IAA3B;;AACAC,MAAAA,6BAA6B,GAAG,yCAAW;AACzCD,QAAAA,wBAAwB,GAAG,IAA3B;AACD,OAFD;AAGD;;AAED,aAASE,iBAAT,CAA2BC,SAA3B,EAAsC;AACpC,UAAIC,KAAK,GAAG;AACVD,QAAAA,SAAS,EAAEA,SADD;AAEVE,QAAAA,WAAW,EAAE,IAFH;AAGVC,QAAAA,UAAU,EAAE,IAHF;AAIVC,QAAAA,mBAAmB,EAAE,IAJX;AAKVC,QAAAA,kBAAkB,EAAE,IALV;AAMV7I,QAAAA,WAAW,EAAE,IANH;AAOVC,QAAAA,UAAU,EAAE,IAPF;AAQV6I,QAAAA,mBAAmB,EAAE,IARX;AASVC,QAAAA,kBAAkB,EAAE;AATV,OAAZ;AAWA,aAAON,KAAP;AACD;;AAED,aAASO,gBAAT,CAA0BC,YAA1B,EAAwC;AACtC,UAAIR,KAAK,GAAG;AACVD,QAAAA,SAAS,EAAES,YAAY,CAACT,SADd;AAEVE,QAAAA,WAAW,EAAEO,YAAY,CAACP,WAFhB;AAGVC,QAAAA,UAAU,EAAEM,YAAY,CAACN,UAHf;AAOVC,QAAAA,mBAAmB,EAAE,IAPX;AAQVC,QAAAA,kBAAkB,EAAE,IARV;AAUV7I,QAAAA,WAAW,EAAE,IAVH;AAWVC,QAAAA,UAAU,EAAE,IAXF;AAaV6I,QAAAA,mBAAmB,EAAE,IAbX;AAcVC,QAAAA,kBAAkB,EAAE;AAdV,OAAZ;AAgBA,aAAON,KAAP;AACD;;AAED,aAASS,YAAT,CAAsB3Q,cAAtB,EAAsC;AACpC,aAAO;AACLA,QAAAA,cAAc,EAAEA,cADX;AAGLrmB,QAAAA,GAAG,EAAE61B,WAHA;AAILoB,QAAAA,OAAO,EAAE,IAJJ;AAKL9d,QAAAA,QAAQ,EAAE,IALL;AAOLla,QAAAA,IAAI,EAAE,IAPD;AAQL4uB,QAAAA,UAAU,EAAE;AARP,OAAP;AAUD;;AAED,aAASqJ,mBAAT,CAA6BX,KAA7B,EAAoCY,MAApC,EAA4C;AAE1C,UAAIZ,KAAK,CAACE,UAAN,KAAqB,IAAzB,EAA+B;AAE7BF,QAAAA,KAAK,CAACC,WAAN,GAAoBD,KAAK,CAACE,UAAN,GAAmBU,MAAvC;AACD,OAHD,MAGO;AACLZ,QAAAA,KAAK,CAACE,UAAN,CAAiBx3B,IAAjB,GAAwBk4B,MAAxB;AACAZ,QAAAA,KAAK,CAACE,UAAN,GAAmBU,MAAnB;AACD;AACF;;AAED,aAASC,aAAT,CAAuBthB,KAAvB,EAA8BqhB,MAA9B,EAAsC;AAEpC,UAAIv0B,SAAS,GAAGkT,KAAK,CAAClT,SAAtB;AACA,UAAIy0B,MAAM,GAAG,KAAK,CAAlB;AACA,UAAIC,MAAM,GAAG,KAAK,CAAlB;;AACA,UAAI10B,SAAS,KAAK,IAAlB,EAAwB;AAEtBy0B,QAAAA,MAAM,GAAGvhB,KAAK,CAAC4X,WAAf;AACA4J,QAAAA,MAAM,GAAG,IAAT;;AACA,YAAID,MAAM,KAAK,IAAf,EAAqB;AACnBA,UAAAA,MAAM,GAAGvhB,KAAK,CAAC4X,WAAN,GAAoB2I,iBAAiB,CAACvgB,KAAK,CAAC6X,aAAP,CAA9C;AACD;AACF,OAPD,MAOO;AAEL0J,QAAAA,MAAM,GAAGvhB,KAAK,CAAC4X,WAAf;AACA4J,QAAAA,MAAM,GAAG10B,SAAS,CAAC8qB,WAAnB;;AACA,YAAI2J,MAAM,KAAK,IAAf,EAAqB;AACnB,cAAIC,MAAM,KAAK,IAAf,EAAqB;AAEnBD,YAAAA,MAAM,GAAGvhB,KAAK,CAAC4X,WAAN,GAAoB2I,iBAAiB,CAACvgB,KAAK,CAAC6X,aAAP,CAA9C;AACA2J,YAAAA,MAAM,GAAG10B,SAAS,CAAC8qB,WAAV,GAAwB2I,iBAAiB,CAChDzzB,SAAS,CAAC+qB,aADsC,CAAlD;AAGD,WAND,MAMO;AAEL0J,YAAAA,MAAM,GAAGvhB,KAAK,CAAC4X,WAAN,GAAoBoJ,gBAAgB,CAACQ,MAAD,CAA7C;AACD;AACF,SAXD,MAWO;AACL,cAAIA,MAAM,KAAK,IAAf,EAAqB;AAEnBA,YAAAA,MAAM,GAAG10B,SAAS,CAAC8qB,WAAV,GAAwBoJ,gBAAgB,CAACO,MAAD,CAAjD;AACD,WAHD,MAGO,CAEN;AACF;AACF;;AACD,UAAIC,MAAM,KAAK,IAAX,IAAmBD,MAAM,KAAKC,MAAlC,EAA0C;AAExCJ,QAAAA,mBAAmB,CAACG,MAAD,EAASF,MAAT,CAAnB;AACD,OAHD,MAGO;AAIL,YAAIE,MAAM,CAACZ,UAAP,KAAsB,IAAtB,IAA8Ba,MAAM,CAACb,UAAP,KAAsB,IAAxD,EAA8D;AAE5DS,UAAAA,mBAAmB,CAACG,MAAD,EAASF,MAAT,CAAnB;AACAD,UAAAA,mBAAmB,CAACI,MAAD,EAASH,MAAT,CAAnB;AACD,SAJD,MAIO;AAGLD,UAAAA,mBAAmB,CAACG,MAAD,EAASF,MAAT,CAAnB;AAEAG,UAAAA,MAAM,CAACb,UAAP,GAAoBU,MAApB;AACD;AACF;;AAED;AACE,YACE,CAACrhB,KAAK,CAAC9V,GAAN,KAAcmB,cAAd,IAAgC2U,KAAK,CAAC9V,GAAN,KAAcoB,kBAA/C,MACC+0B,wBAAwB,KAAKkB,MAA7B,IACEC,MAAM,KAAK,IAAX,IAAmBnB,wBAAwB,KAAKmB,MAFnD,KAGA,CAACpB,yBAJH,EAKE;AACAt5B,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,sEACE,mEADF,GAEE,iEAFF,GAGE,WALiB,CAArB;AAOAs5B,UAAAA,yBAAyB,GAAG,IAA5B;AACD;AACF;AACF;;AAED,aAASqB,qBAAT,CAA+BxV,cAA/B,EAA+CoV,MAA/C,EAAuD;AAGrD,UAAIK,mBAAmB,GAAGzV,cAAc,CAAC2L,WAAzC;;AACA,UAAI8J,mBAAmB,KAAK,IAA5B,EAAkC;AAChCA,QAAAA,mBAAmB,GAAGzV,cAAc,CAAC2L,WAAf,GAA6B2I,iBAAiB,CAClEtU,cAAc,CAAC4L,aADmD,CAApE;AAGD,OAJD,MAIO;AAIL6J,QAAAA,mBAAmB,GAAGC,iCAAiC,CACrD1V,cADqD,EAErDyV,mBAFqD,CAAvD;AAID;;AAGD,UAAIA,mBAAmB,CAACb,kBAApB,KAA2C,IAA/C,EAAqD;AAEnDa,QAAAA,mBAAmB,CAACd,mBAApB,GAA0Cc,mBAAmB,CAACb,kBAApB,GAAyCQ,MAAnF;AACD,OAHD,MAGO;AACLK,QAAAA,mBAAmB,CAACb,kBAApB,CAAuC13B,IAAvC,GAA8Ck4B,MAA9C;AACAK,QAAAA,mBAAmB,CAACb,kBAApB,GAAyCQ,MAAzC;AACD;AACF;;AAED,aAASM,iCAAT,CAA2C1V,cAA3C,EAA2DwU,KAA3D,EAAkE;AAChE,UAAIv3B,OAAO,GAAG+iB,cAAc,CAACnf,SAA7B;;AACA,UAAI5D,OAAO,KAAK,IAAhB,EAAsB;AAGpB,YAAIu3B,KAAK,KAAKv3B,OAAO,CAAC0uB,WAAtB,EAAmC;AACjC6I,UAAAA,KAAK,GAAGxU,cAAc,CAAC2L,WAAf,GAA6BoJ,gBAAgB,CAACP,KAAD,CAArD;AACD;AACF;;AACD,aAAOA,KAAP;AACD;;AAED,aAASmB,kBAAT,CACE3V,cADF,EAEEwU,KAFF,EAGEY,MAHF,EAIEQ,SAJF,EAKE9e,SALF,EAME9R,QANF,EAOE;AACA,cAAQowB,MAAM,CAACn3B,GAAf;AACE,aAAK81B,YAAL;AAAmB;AACjB,gBAAI8B,QAAQ,GAAGT,MAAM,CAACF,OAAtB;;AACA,gBAAI,OAAOW,QAAP,KAAoB,UAAxB,EAAoC;AAElC;AACE,oBACEpV,2BAA2B,IAC1BC,wCAAwC,IACvCV,cAAc,CAACwL,IAAf,GAAsBX,UAH1B,EAIE;AACAgL,kBAAAA,QAAQ,CAAClgC,IAAT,CAAcqP,QAAd,EAAwB4wB,SAAxB,EAAmC9e,SAAnC;AACD;AACF;AACD,qBAAO+e,QAAQ,CAAClgC,IAAT,CAAcqP,QAAd,EAAwB4wB,SAAxB,EAAmC9e,SAAnC,CAAP;AACD;;AAED,mBAAO+e,QAAP;AACD;;AACD,aAAK5B,aAAL;AAAoB;AAClBjU,YAAAA,cAAc,CAAC/L,SAAf,GACG+L,cAAc,CAAC/L,SAAf,GAA2B,CAACT,aAA7B,GAA8CN,UADhD;AAED;;AAED,aAAK4gB,WAAL;AAAkB;AAChB,gBAAIgC,SAAS,GAAGV,MAAM,CAACF,OAAvB;AACA,gBAAIa,YAAY,GAAG,KAAK,CAAxB;;AACA,gBAAI,OAAOD,SAAP,KAAqB,UAAzB,EAAqC;AAEnC;AACE,oBACErV,2BAA2B,IAC1BC,wCAAwC,IACvCV,cAAc,CAACwL,IAAf,GAAsBX,UAH1B,EAIE;AACAiL,kBAAAA,SAAS,CAACngC,IAAV,CAAeqP,QAAf,EAAyB4wB,SAAzB,EAAoC9e,SAApC;AACD;AACF;AACDif,cAAAA,YAAY,GAAGD,SAAS,CAACngC,IAAV,CAAeqP,QAAf,EAAyB4wB,SAAzB,EAAoC9e,SAApC,CAAf;AACD,aAZD,MAYO;AAELif,cAAAA,YAAY,GAAGD,SAAf;AACD;;AACD,gBAAIC,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK3hC,SAA9C,EAAyD;AAEvD,qBAAOwhC,SAAP;AACD;;AAED,mBAAO,SAAc,EAAd,EAAkBA,SAAlB,EAA6BG,YAA7B,CAAP;AACD;;AACD,aAAK/B,WAAL;AAAkB;AAChBE,YAAAA,cAAc,GAAG,IAAjB;AACA,mBAAO0B,SAAP;AACD;AArDH;;AAuDA,aAAOA,SAAP;AACD;;AAED,aAASI,kBAAT,CACEhW,cADF,EAEEwU,KAFF,EAGEr2B,KAHF,EAIE6G,QAJF,EAKE0uB,oBALF,EAME;AACAQ,MAAAA,cAAc,GAAG,KAAjB;AAEAM,MAAAA,KAAK,GAAGkB,iCAAiC,CAAC1V,cAAD,EAAiBwU,KAAjB,CAAzC;AAEA;AACEJ,QAAAA,wBAAwB,GAAGI,KAA3B;AACD;AAGD,UAAIyB,YAAY,GAAGzB,KAAK,CAACD,SAAzB;AACA,UAAI2B,cAAc,GAAG,IAArB;AACA,UAAIC,iBAAiB,GAAG7M,MAAxB;AAGA,UAAI8L,MAAM,GAAGZ,KAAK,CAACC,WAAnB;AACA,UAAI2B,WAAW,GAAGH,YAAlB;;AACA,aAAOb,MAAM,KAAK,IAAlB,EAAwB;AACtB,YAAIiB,oBAAoB,GAAGjB,MAAM,CAAC9Q,cAAlC;;AACA,YAAI+R,oBAAoB,GAAG3C,oBAA3B,EAAiD;AAE/C,cAAIwC,cAAc,KAAK,IAAvB,EAA6B;AAG3BA,YAAAA,cAAc,GAAGd,MAAjB;AAGAa,YAAAA,YAAY,GAAGG,WAAf;AACD;;AAGD,cACED,iBAAiB,KAAK7M,MAAtB,IACA6M,iBAAiB,GAAGE,oBAFtB,EAGE;AACAF,YAAAA,iBAAiB,GAAGE,oBAApB;AACD;AACF,SAlBD,MAkBO;AAGLD,UAAAA,WAAW,GAAGT,kBAAkB,CAC9B3V,cAD8B,EAE9BwU,KAF8B,EAG9BY,MAH8B,EAI9BgB,WAJ8B,EAK9Bj4B,KAL8B,EAM9B6G,QAN8B,CAAhC;AAQA,cAAIsxB,SAAS,GAAGlB,MAAM,CAAChe,QAAvB;;AACA,cAAIkf,SAAS,KAAK,IAAlB,EAAwB;AACtBtW,YAAAA,cAAc,CAAC/L,SAAf,IAA4BhB,QAA5B;AAEAmiB,YAAAA,MAAM,CAACtJ,UAAP,GAAoB,IAApB;;AACA,gBAAI0I,KAAK,CAACxI,UAAN,KAAqB,IAAzB,EAA+B;AAC7BwI,cAAAA,KAAK,CAACzI,WAAN,GAAoByI,KAAK,CAACxI,UAAN,GAAmBoJ,MAAvC;AACD,aAFD,MAEO;AACLZ,cAAAA,KAAK,CAACxI,UAAN,CAAiBF,UAAjB,GAA8BsJ,MAA9B;AACAZ,cAAAA,KAAK,CAACxI,UAAN,GAAmBoJ,MAAnB;AACD;AACF;AACF;;AAEDA,QAAAA,MAAM,GAAGA,MAAM,CAACl4B,IAAhB;AACD;;AAGD,UAAIq5B,sBAAsB,GAAG,IAA7B;AACAnB,MAAAA,MAAM,GAAGZ,KAAK,CAACG,mBAAf;;AACA,aAAOS,MAAM,KAAK,IAAlB,EAAwB;AACtB,YAAIoB,qBAAqB,GAAGpB,MAAM,CAAC9Q,cAAnC;;AACA,YAAIkS,qBAAqB,GAAG9C,oBAA5B,EAAkD;AAEhD,cAAI6C,sBAAsB,KAAK,IAA/B,EAAqC;AAGnCA,YAAAA,sBAAsB,GAAGnB,MAAzB;;AAGA,gBAAIc,cAAc,KAAK,IAAvB,EAA6B;AAC3BD,cAAAA,YAAY,GAAGG,WAAf;AACD;AACF;;AAGD,cACED,iBAAiB,KAAK7M,MAAtB,IACA6M,iBAAiB,GAAGK,qBAFtB,EAGE;AACAL,YAAAA,iBAAiB,GAAGK,qBAApB;AACD;AACF,SApBD,MAoBO;AAGLJ,UAAAA,WAAW,GAAGT,kBAAkB,CAC9B3V,cAD8B,EAE9BwU,KAF8B,EAG9BY,MAH8B,EAI9BgB,WAJ8B,EAK9Bj4B,KAL8B,EAM9B6G,QAN8B,CAAhC;AAQA,cAAIyxB,UAAU,GAAGrB,MAAM,CAAChe,QAAxB;;AACA,cAAIqf,UAAU,KAAK,IAAnB,EAAyB;AACvBzW,YAAAA,cAAc,CAAC/L,SAAf,IAA4BhB,QAA5B;AAEAmiB,YAAAA,MAAM,CAACtJ,UAAP,GAAoB,IAApB;;AACA,gBAAI0I,KAAK,CAACM,kBAAN,KAA6B,IAAjC,EAAuC;AACrCN,cAAAA,KAAK,CAACK,mBAAN,GAA4BL,KAAK,CAACM,kBAAN,GAA2BM,MAAvD;AACD,aAFD,MAEO;AACLZ,cAAAA,KAAK,CAACM,kBAAN,CAAyBhJ,UAAzB,GAAsCsJ,MAAtC;AACAZ,cAAAA,KAAK,CAACM,kBAAN,GAA2BM,MAA3B;AACD;AACF;AACF;;AACDA,QAAAA,MAAM,GAAGA,MAAM,CAACl4B,IAAhB;AACD;;AAED,UAAIg5B,cAAc,KAAK,IAAvB,EAA6B;AAC3B1B,QAAAA,KAAK,CAACE,UAAN,GAAmB,IAAnB;AACD;;AACD,UAAI6B,sBAAsB,KAAK,IAA/B,EAAqC;AACnC/B,QAAAA,KAAK,CAACI,kBAAN,GAA2B,IAA3B;AACD,OAFD,MAEO;AACL5U,QAAAA,cAAc,CAAC/L,SAAf,IAA4BhB,QAA5B;AACD;;AACD,UAAIijB,cAAc,KAAK,IAAnB,IAA2BK,sBAAsB,KAAK,IAA1D,EAAgE;AAG9DN,QAAAA,YAAY,GAAGG,WAAf;AACD;;AAED5B,MAAAA,KAAK,CAACD,SAAN,GAAkB0B,YAAlB;AACAzB,MAAAA,KAAK,CAACC,WAAN,GAAoByB,cAApB;AACA1B,MAAAA,KAAK,CAACG,mBAAN,GAA4B4B,sBAA5B;AASAvW,MAAAA,cAAc,CAACsE,cAAf,GAAgC6R,iBAAhC;AACAnW,MAAAA,cAAc,CAAC4L,aAAf,GAA+BwK,WAA/B;AAEA;AACEhC,QAAAA,wBAAwB,GAAG,IAA3B;AACD;AACF;;AAED,aAAS19B,YAAT,CAAsB0gB,QAAtB,EAAgC9hB,OAAhC,EAAyC;AACvChB,MAAAA,SAAS,CACP,OAAO8iB,QAAP,KAAoB,UADb,EAEP,uEACE,cAHK,EAIPA,QAJO,CAAT;AAMAA,MAAAA,QAAQ,CAACzhB,IAAT,CAAcL,OAAd;AACD;;AAED,aAASohC,mCAAT,GAA+C;AAC7CxC,MAAAA,cAAc,GAAG,KAAjB;AACD;;AAED,aAASyC,kCAAT,GAA8C;AAC5C,aAAOzC,cAAP;AACD;;AAED,aAAS0C,iBAAT,CACEnI,YADF,EAEEoI,aAFF,EAGE7xB,QAHF,EAIE0uB,oBAJF,EAKE;AAKA,UAAImD,aAAa,CAAClC,mBAAd,KAAsC,IAA1C,EAAgD;AAE9C,YAAIkC,aAAa,CAACnC,UAAd,KAA6B,IAAjC,EAAuC;AACrCmC,UAAAA,aAAa,CAACnC,UAAd,CAAyBx3B,IAAzB,GAAgC25B,aAAa,CAAClC,mBAA9C;AACAkC,UAAAA,aAAa,CAACnC,UAAd,GAA2BmC,aAAa,CAACjC,kBAAzC;AACD;;AAEDiC,QAAAA,aAAa,CAAClC,mBAAd,GAAoCkC,aAAa,CAACjC,kBAAd,GAAmC,IAAvE;AACD;;AAGDkC,MAAAA,mBAAmB,CAACD,aAAa,CAAC9K,WAAf,EAA4B/mB,QAA5B,CAAnB;AACA6xB,MAAAA,aAAa,CAAC9K,WAAd,GAA4B8K,aAAa,CAAC7K,UAAd,GAA2B,IAAvD;AAEA8K,MAAAA,mBAAmB,CAACD,aAAa,CAAChC,mBAAf,EAAoC7vB,QAApC,CAAnB;AACA6xB,MAAAA,aAAa,CAAChC,mBAAd,GAAoCgC,aAAa,CAAC/B,kBAAd,GAAmC,IAAvE;AACD;;AAED,aAASgC,mBAAT,CAA6BC,MAA7B,EAAqC/xB,QAArC,EAA+C;AAC7C,aAAO+xB,MAAM,KAAK,IAAlB,EAAwB;AACtB,YAAIC,UAAU,GAAGD,MAAM,CAAC3f,QAAxB;;AACA,YAAI4f,UAAU,KAAK,IAAnB,EAAyB;AACvBD,UAAAA,MAAM,CAAC3f,QAAP,GAAkB,IAAlB;AACA1gB,UAAAA,YAAY,CAACsgC,UAAD,EAAahyB,QAAb,CAAZ;AACD;;AACD+xB,QAAAA,MAAM,GAAGA,MAAM,CAACjL,UAAhB;AACD;AACF;;AAED,aAASmL,mBAAT,CAA6B7mB,KAA7B,EAAoC8O,MAApC,EAA4C;AAG1C,aAAO;AACL9O,QAAAA,KAAK,EAAEA,KADF;AAEL8O,QAAAA,MAAM,EAAEA,MAFH;AAGLgY,QAAAA,KAAK,EAAEnX,2BAA2B,CAACb,MAAD;AAH7B,OAAP;AAKD;;AASD,QAAIsD,OAAO,GAAG3nB,qBAAd;AAEA;AACE2nB,MAAAA,OAAO,GAAG,iBAASjuB,SAAT,EAAoBJ,MAApB,EAA4B;AACpC,YAAII,SAAJ,EAAe;AACb;AACD;;AACD,YAAIorB,sBAAsB,GAAGtP,oBAAoB,CAACsP,sBAAlD;AACA,YAAIuX,KAAK,GAAGvX,sBAAsB,CAACwX,gBAAvB,EAAZ;;AAGA,aACE,IAAIj9B,IAAI,GAAGtE,SAAS,CAACuE,MAArB,EACEpF,IAAI,GAAGS,KAAK,CAAC0E,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAvB,CADd,EAEEE,IAAI,GAAG,CAHX,EAIEA,IAAI,GAAGF,IAJT,EAKEE,IAAI,EALN,EAME;AACArF,UAAAA,IAAI,CAACqF,IAAI,GAAG,CAAR,CAAJ,GAAiBxE,SAAS,CAACwE,IAAD,CAA1B;AACD;;AAEDS,QAAAA,qBAAqB,CAAChF,KAAtB,CACEzB,SADF,EAEE,CAAC,KAAD,EAAQD,MAAM,GAAG,IAAjB,EAAuBuG,MAAvB,CAA8B3F,IAA9B,EAAoC,CAACmiC,KAAD,CAApC,CAFF;AAID,OAtBD;AAuBD;AAED,QAAIE,SAAS,GAAG5U,OAAhB;AAEA,QAAI6U,WAAW,GAAGvR,YAAY,CAAC,IAAD,CAA9B;AAEA,QAAIwR,aAAa,GAAG,KAAK,CAAzB;AACA;AAEEA,MAAAA,aAAa,GAAG,EAAhB;AACD;AAED,QAAIC,uBAAuB,GAAG,IAA9B;AACA,QAAIC,qBAAqB,GAAG,IAA5B;AACA,QAAIC,8BAA8B,GAAG,IAArC;;AAEA,aAASC,uBAAT,GAAmC;AAGjCH,MAAAA,uBAAuB,GAAG,IAA1B;AACAC,MAAAA,qBAAqB,GAAG,IAAxB;AACAC,MAAAA,8BAA8B,GAAG,IAAjC;AACD;;AAED,aAASE,YAAT,CAAsBC,aAAtB,EAAqC1hB,SAArC,EAAgD;AAC9C,UAAI5gB,OAAO,GAAGsiC,aAAa,CAACz7B,IAAd,CAAmB07B,QAAjC;;AAEA,UAAI1a,iBAAJ,EAAuB;AACrBhgB,QAAAA,IAAI,CAACk6B,WAAD,EAAc/hC,OAAO,CAACwiC,aAAtB,EAAqCF,aAArC,CAAJ;AAEAtiC,QAAAA,OAAO,CAACwiC,aAAR,GAAwB5hB,SAAxB;AACA;AACE,YACE5gB,OAAO,CAACyiC,gBAAR,KAA6B3jC,SAA7B,IACAkB,OAAO,CAACyiC,gBAAR,KAA6B,IAD7B,IAEAziC,OAAO,CAACyiC,gBAAR,KAA6BT,aAH/B,IAKIz8B,qBAAqB,CACnB,KADmB,EAEnB,4DACE,uDAHiB,CALzB,GAUI,KAAK,CAVT;AAWAvF,UAAAA,OAAO,CAACyiC,gBAAR,GAA2BT,aAA3B;AACD;AACF,OAlBD,MAkBO;AACLn6B,QAAAA,IAAI,CAACk6B,WAAD,EAAc/hC,OAAO,CAAC0iC,cAAtB,EAAsCJ,aAAtC,CAAJ;AAEAtiC,QAAAA,OAAO,CAAC0iC,cAAR,GAAyB9hB,SAAzB;AACA;AACE,YACE5gB,OAAO,CAAC2iC,iBAAR,KAA8B7jC,SAA9B,IACAkB,OAAO,CAAC2iC,iBAAR,KAA8B,IAD9B,IAEA3iC,OAAO,CAAC2iC,iBAAR,KAA8BX,aAHhC,IAKIz8B,qBAAqB,CACnB,KADmB,EAEnB,4DACE,uDAHiB,CALzB,GAUI,KAAK,CAVT;AAWAvF,UAAAA,OAAO,CAAC2iC,iBAAR,GAA4BX,aAA5B;AACD;AACF;AACF;;AAED,aAASY,WAAT,CAAqBN,aAArB,EAAoC;AAClC,UAAIO,YAAY,GAAGd,WAAW,CAACp6B,OAA/B;AAEAgI,MAAAA,GAAG,CAACoyB,WAAD,EAAcO,aAAd,CAAH;AAEA,UAAItiC,OAAO,GAAGsiC,aAAa,CAACz7B,IAAd,CAAmB07B,QAAjC;;AACA,UAAI1a,iBAAJ,EAAuB;AACrB7nB,QAAAA,OAAO,CAACwiC,aAAR,GAAwBK,YAAxB;AACD,OAFD,MAEO;AACL7iC,QAAAA,OAAO,CAAC0iC,cAAR,GAAyBG,YAAzB;AACD;AACF;;AAED,aAASC,oBAAT,CAA8B9iC,OAA9B,EAAuC+iC,QAAvC,EAAiDC,QAAjD,EAA2D;AAIzD,UACGA,QAAQ,KAAKD,QAAb,KACEC,QAAQ,KAAK,CAAb,IAAkB,IAAIA,QAAJ,KAAiB,IAAID,QADzC,CAAD,IAECC,QAAQ,KAAKA,QAAb,IAAyBD,QAAQ,KAAKA,QAHzC,EAIE;AAEA,iBAAO,CAAP;AACD,SAPD,MAOO;AACL,YAAIE,WAAW,GACb,OAAOjjC,OAAO,CAACkjC,qBAAf,KAAyC,UAAzC,GACIljC,OAAO,CAACkjC,qBAAR,CAA8BF,QAA9B,EAAwCD,QAAxC,CADJ,GAEIhP,iBAHN;AAKA;AACE,YAAE,CAACkP,WAAW,GAAGlP,iBAAf,MAAsCkP,WAAxC,IACInB,SAAS,CACP,KADO,EAEP,6DACE,sCAHK,EAIPmB,WAJO,CADb,GAOI,KAAK,CAPT;AAQD;AACD,eAAOA,WAAW,GAAG,CAArB;AACD;AACF;;AAED,aAASE,sBAAT,CACEzY,cADF,EAEE1qB,OAFF,EAGEijC,WAHF,EAIE7E,oBAJF,EAKE;AACA,UAAI3f,KAAK,GAAGiM,cAAc,CAACnL,KAA3B;;AACA,UAAId,KAAK,KAAK,IAAd,EAAoB;AAElBA,QAAAA,KAAK,CAAC3T,MAAN,GAAe4f,cAAf;AACD;;AACD,aAAOjM,KAAK,KAAK,IAAjB,EAAuB;AACrB,YAAI2kB,SAAS,GAAG,KAAK,CAArB;AAGA,YAAIC,UAAU,GAAG5kB,KAAK,CAAC8X,sBAAvB;;AACA,YAAI8M,UAAU,KAAK,IAAnB,EAAyB;AACvB,aAAG;AAED,gBACEA,UAAU,CAACrjC,OAAX,KAAuBA,OAAvB,IACA,CAACqjC,UAAU,CAACC,YAAX,GAA0BL,WAA3B,MAA4C,CAF9C,EAGE;AAGA,kBACExkB,KAAK,CAAC9V,GAAN,KAAcmB,cAAd,IACA2U,KAAK,CAAC9V,GAAN,KAAcoB,kBAFhB,EAGE;AAEA,oBAAI+1B,MAAM,GAAGH,YAAY,CAACvB,oBAAD,CAAzB;AACA0B,gBAAAA,MAAM,CAACn3B,GAAP,GAAa+1B,WAAb;AAKAqB,gBAAAA,aAAa,CAACthB,KAAD,EAAQqhB,MAAR,CAAb;AACD;;AAED,kBACErhB,KAAK,CAACuQ,cAAN,KAAyBgF,MAAzB,IACAvV,KAAK,CAACuQ,cAAN,GAAuBoP,oBAFzB,EAGE;AACA3f,gBAAAA,KAAK,CAACuQ,cAAN,GAAuBoP,oBAAvB;AACD;;AACD,kBAAI7yB,SAAS,GAAGkT,KAAK,CAAClT,SAAtB;;AACA,kBACEA,SAAS,KAAK,IAAd,KACCA,SAAS,CAACyjB,cAAV,KAA6BgF,MAA7B,IACCzoB,SAAS,CAACyjB,cAAV,GAA2BoP,oBAF7B,CADF,EAIE;AACA7yB,gBAAAA,SAAS,CAACyjB,cAAV,GAA2BoP,oBAA3B;AACD;;AAGD,kBAAI1f,IAAI,GAAGD,KAAK,CAAC3T,MAAjB;;AACA,qBAAO4T,IAAI,KAAK,IAAhB,EAAsB;AACpBnT,gBAAAA,SAAS,GAAGmT,IAAI,CAACnT,SAAjB;;AACA,oBACEmT,IAAI,CAACiY,mBAAL,KAA6B3C,MAA7B,IACAtV,IAAI,CAACiY,mBAAL,GAA2ByH,oBAF7B,EAGE;AACA1f,kBAAAA,IAAI,CAACiY,mBAAL,GAA2ByH,oBAA3B;;AACA,sBACE7yB,SAAS,KAAK,IAAd,KACCA,SAAS,CAACorB,mBAAV,KAAkC3C,MAAlC,IACCzoB,SAAS,CAACorB,mBAAV,GAAgCyH,oBAFlC,CADF,EAIE;AACA7yB,oBAAAA,SAAS,CAACorB,mBAAV,GAAgCyH,oBAAhC;AACD;AACF,iBAZD,MAYO,IACL7yB,SAAS,KAAK,IAAd,KACCA,SAAS,CAACorB,mBAAV,KAAkC3C,MAAlC,IACCzoB,SAAS,CAACorB,mBAAV,GAAgCyH,oBAFlC,CADK,EAIL;AACA7yB,kBAAAA,SAAS,CAACorB,mBAAV,GAAgCyH,oBAAhC;AACD,iBANM,MAMA;AAGL;AACD;;AACD1f,gBAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;AACF;;AACDs4B,YAAAA,SAAS,GAAG3kB,KAAK,CAACc,KAAlB;AACA8jB,YAAAA,UAAU,GAAGA,UAAU,CAACz7B,IAAxB;AACD,WArED,QAqESy7B,UAAU,KAAK,IArExB;AAsED,SAvED,MAuEO,IAAI5kB,KAAK,CAAC9V,GAAN,KAAc6B,eAAlB,EAAmC;AAExC44B,UAAAA,SAAS,GAAG3kB,KAAK,CAAC5X,IAAN,KAAe6jB,cAAc,CAAC7jB,IAA9B,GAAqC,IAArC,GAA4C4X,KAAK,CAACc,KAA9D;AACD,SAHM,MAGA;AAEL6jB,UAAAA,SAAS,GAAG3kB,KAAK,CAACc,KAAlB;AACD;;AAED,YAAI6jB,SAAS,KAAK,IAAlB,EAAwB;AAEtBA,UAAAA,SAAS,CAACt4B,MAAV,GAAmB2T,KAAnB;AACD,SAHD,MAGO;AAEL2kB,UAAAA,SAAS,GAAG3kB,KAAZ;;AACA,iBAAO2kB,SAAS,KAAK,IAArB,EAA2B;AACzB,gBAAIA,SAAS,KAAK1Y,cAAlB,EAAkC;AAEhC0Y,cAAAA,SAAS,GAAG,IAAZ;AACA;AACD;;AACD,gBAAI5jB,OAAO,GAAG4jB,SAAS,CAAC5jB,OAAxB;;AACA,gBAAIA,OAAO,KAAK,IAAhB,EAAsB;AAEpBA,cAAAA,OAAO,CAAC1U,MAAR,GAAiBs4B,SAAS,CAACt4B,MAA3B;AACAs4B,cAAAA,SAAS,GAAG5jB,OAAZ;AACA;AACD;;AAED4jB,YAAAA,SAAS,GAAGA,SAAS,CAACt4B,MAAtB;AACD;AACF;;AACD2T,QAAAA,KAAK,GAAG2kB,SAAR;AACD;AACF;;AAED,aAASG,oBAAT,CAA8B7Y,cAA9B,EAA8C0T,oBAA9C,EAAoE;AAClE6D,MAAAA,uBAAuB,GAAGvX,cAA1B;AACAwX,MAAAA,qBAAqB,GAAG,IAAxB;AACAC,MAAAA,8BAA8B,GAAG,IAAjC;AAGAzX,MAAAA,cAAc,CAAC6L,sBAAf,GAAwC,IAAxC;AACD;;AAED,aAASiN,WAAT,CAAqBxjC,OAArB,EAA8BsjC,YAA9B,EAA4C;AAC1C,UAAInB,8BAA8B,KAAKniC,OAAvC,EAAgD,CAE/C,CAFD,MAEO,IAAIsjC,YAAY,KAAK,KAAjB,IAA0BA,YAAY,KAAK,CAA/C,EAAkD,CAExD,CAFM,MAEA;AACL,YAAIG,oBAAoB,GAAG,KAAK,CAAhC;;AACA,YACE,OAAOH,YAAP,KAAwB,QAAxB,IACAA,YAAY,KAAKvP,iBAFnB,EAGE;AAEAoO,UAAAA,8BAA8B,GAAGniC,OAAjC;AACAyjC,UAAAA,oBAAoB,GAAG1P,iBAAvB;AACD,SAPD,MAOO;AACL0P,UAAAA,oBAAoB,GAAGH,YAAvB;AACD;;AAED,YAAII,WAAW,GAAG;AAChB1jC,UAAAA,OAAO,EAAEA,OADO;AAEhBsjC,UAAAA,YAAY,EAAEG,oBAFE;AAGhB77B,UAAAA,IAAI,EAAE;AAHU,SAAlB;;AAMA,YAAIs6B,qBAAqB,KAAK,IAA9B,EAAoC;AAClCljC,UAAAA,SAAS,CACPijC,uBAAuB,KAAK,IADrB,EAEP,sEACE,uEAHK,CAAT;AAMAA,UAAAA,uBAAuB,CAAC1L,sBAAxB,GAAiD2L,qBAAqB,GAAGwB,WAAzE;AACD,SARD,MAQO;AAELxB,UAAAA,qBAAqB,GAAGA,qBAAqB,CAACt6B,IAAtB,GAA6B87B,WAArD;AACD;AACF;;AACD,aAAO7b,iBAAiB,GAAG7nB,OAAO,CAACwiC,aAAX,GAA2BxiC,OAAO,CAAC0iC,cAA3D;AACD;;AAED,QAAIiB,UAAU,GAAG,EAAjB;AAEA,QAAIC,oBAAoB,GAAGpT,YAAY,CAACmT,UAAD,CAAvC;AACA,QAAIE,uBAAuB,GAAGrT,YAAY,CAACmT,UAAD,CAA1C;AACA,QAAIG,uBAAuB,GAAGtT,YAAY,CAACmT,UAAD,CAA1C;;AAEA,aAASI,eAAT,CAAyB3kC,CAAzB,EAA4B;AAC1BJ,MAAAA,SAAS,CACPI,CAAC,KAAKukC,UADC,EAEP,0EACE,iCAHK,CAAT;AAKA,aAAOvkC,CAAP;AACD;;AAED,aAAS4kC,oBAAT,GAAgC;AAC9B,UAAIC,YAAY,GAAGF,eAAe,CAACD,uBAAuB,CAACn8B,OAAzB,CAAlC;AACA,aAAOs8B,YAAP;AACD;;AAED,aAASC,iBAAT,CAA2BzlB,KAA3B,EAAkC0lB,gBAAlC,EAAoD;AAGlDt8B,MAAAA,IAAI,CAACi8B,uBAAD,EAA0BK,gBAA1B,EAA4C1lB,KAA5C,CAAJ;AAGA5W,MAAAA,IAAI,CAACg8B,uBAAD,EAA0BplB,KAA1B,EAAiCA,KAAjC,CAAJ;AAOA5W,MAAAA,IAAI,CAAC+7B,oBAAD,EAAuBD,UAAvB,EAAmCllB,KAAnC,CAAJ;AACA,UAAI2lB,eAAe,GAAGld,kBAAkB,CAACid,gBAAD,CAAxC;AAEAx0B,MAAAA,GAAG,CAACi0B,oBAAD,EAAuBnlB,KAAvB,CAAH;AACA5W,MAAAA,IAAI,CAAC+7B,oBAAD,EAAuBQ,eAAvB,EAAwC3lB,KAAxC,CAAJ;AACD;;AAED,aAAS4lB,gBAAT,CAA0B5lB,KAA1B,EAAiC;AAC/B9O,MAAAA,GAAG,CAACi0B,oBAAD,EAAuBnlB,KAAvB,CAAH;AACA9O,MAAAA,GAAG,CAACk0B,uBAAD,EAA0BplB,KAA1B,CAAH;AACA9O,MAAAA,GAAG,CAACm0B,uBAAD,EAA0BrlB,KAA1B,CAAH;AACD;;AAED,aAAS6lB,cAAT,GAA0B;AACxB,UAAItkC,OAAO,GAAG+jC,eAAe,CAACH,oBAAoB,CAACj8B,OAAtB,CAA7B;AACA,aAAO3H,OAAP;AACD;;AAED,aAASukC,eAAT,CAAyB9lB,KAAzB,EAAgC;AAC9B,UAAIwlB,YAAY,GAAGF,eAAe,CAACD,uBAAuB,CAACn8B,OAAzB,CAAlC;AACA,UAAI3H,OAAO,GAAG+jC,eAAe,CAACH,oBAAoB,CAACj8B,OAAtB,CAA7B;AACA,UAAI68B,WAAW,GAAGrd,mBAAmB,CAACnnB,OAAD,EAAUye,KAAK,CAAC5X,IAAhB,EAAsBo9B,YAAtB,CAArC;;AAGA,UAAIjkC,OAAO,KAAKwkC,WAAhB,EAA6B;AAC3B;AACD;;AAID38B,MAAAA,IAAI,CAACg8B,uBAAD,EAA0BplB,KAA1B,EAAiCA,KAAjC,CAAJ;AACA5W,MAAAA,IAAI,CAAC+7B,oBAAD,EAAuBY,WAAvB,EAAoC/lB,KAApC,CAAJ;AACD;;AAED,aAASgmB,cAAT,CAAwBhmB,KAAxB,EAA+B;AAG7B,UAAIolB,uBAAuB,CAACl8B,OAAxB,KAAoC8W,KAAxC,EAA+C;AAC7C;AACD;;AAED9O,MAAAA,GAAG,CAACi0B,oBAAD,EAAuBnlB,KAAvB,CAAH;AACA9O,MAAAA,GAAG,CAACk0B,uBAAD,EAA0BplB,KAA1B,CAAH;AACD;;AAED,QAAIimB,UAAU,GAAG,CAAjB;AACA,QAAIC,iBAAiB,GAAG,CAAC,CAAzB;;AAEA,aAASC,aAAT,GAAyB;AACvB,aAAOF,UAAP;AACD;;AAED,aAASG,gBAAT,GAA4B;AAC1B,UAAI,CAAClZ,mBAAL,EAA0B;AACxB;AACD;;AACD+Y,MAAAA,UAAU,GAAGt3B,GAAG,EAAhB;AACD;;AAED,aAAS03B,kBAAT,CAA4BrmB,KAA5B,EAAmC;AACjC,UAAI,CAACkN,mBAAL,EAA0B;AACxB;AACD;;AAEDgZ,MAAAA,iBAAiB,GAAGv3B,GAAG,EAAvB;;AAEA,UAAIqR,KAAK,CAACoY,eAAN,GAAwB,CAA5B,EAA+B;AAC7BpY,QAAAA,KAAK,CAACoY,eAAN,GAAwBzpB,GAAG,EAA3B;AACD;AACF;;AAED,aAAS23B,0BAAT,CAAoCtmB,KAApC,EAA2C;AACzC,UAAI,CAACkN,mBAAL,EAA0B;AACxB;AACD;;AACDgZ,MAAAA,iBAAiB,GAAG,CAAC,CAArB;AACD;;AAED,aAASK,wCAAT,CAAkDvmB,KAAlD,EAAyDwmB,gBAAzD,EAA2E;AACzE,UAAI,CAACtZ,mBAAL,EAA0B;AACxB;AACD;;AAED,UAAIgZ,iBAAiB,IAAI,CAAzB,EAA4B;AAC1B,YAAIO,WAAW,GAAG93B,GAAG,KAAKu3B,iBAA1B;AACAlmB,QAAAA,KAAK,CAACmY,cAAN,IAAwBsO,WAAxB;;AACA,YAAID,gBAAJ,EAAsB;AACpBxmB,UAAAA,KAAK,CAACqY,gBAAN,GAAyBoO,WAAzB;AACD;;AACDP,QAAAA,iBAAiB,GAAG,CAAC,CAArB;AACD;AACF;;AAID,QAAIpjC,cAAc,GAAG4M,MAAM,CAAChO,SAAP,CAAiBoB,cAAtC;;AAMA,aAAS4jC,EAAT,CAAY7/B,CAAZ,EAAe8/B,CAAf,EAAkB;AAEhB,UAAI9/B,CAAC,KAAK8/B,CAAV,EAAa;AAIX,eAAO9/B,CAAC,KAAK,CAAN,IAAW8/B,CAAC,KAAK,CAAjB,IAAsB,IAAI9/B,CAAJ,KAAU,IAAI8/B,CAA3C;AACD,OALD,MAKO;AAEL,eAAO9/B,CAAC,KAAKA,CAAN,IAAW8/B,CAAC,KAAKA,CAAxB;AACD;AACF;;AAOD,aAASC,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkC;AAChC,UAAIJ,EAAE,CAACG,IAAD,EAAOC,IAAP,CAAN,EAAoB;AAClB,eAAO,IAAP;AACD;;AAED,UACE,OAAOD,IAAP,KAAgB,QAAhB,IACAA,IAAI,KAAK,IADT,IAEA,OAAOC,IAAP,KAAgB,QAFhB,IAGAA,IAAI,KAAK,IAJX,EAKE;AACA,eAAO,KAAP;AACD;;AAED,UAAIC,KAAK,GAAGr3B,MAAM,CAAC0pB,IAAP,CAAYyN,IAAZ,CAAZ;AACA,UAAIG,KAAK,GAAGt3B,MAAM,CAAC0pB,IAAP,CAAY0N,IAAZ,CAAZ;;AAEA,UAAIC,KAAK,CAAC3gC,MAAN,KAAiB4gC,KAAK,CAAC5gC,MAA3B,EAAmC;AACjC,eAAO,KAAP;AACD;;AAGD,WAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGw+B,KAAK,CAAC3gC,MAA1B,EAAkCmC,CAAC,EAAnC,EAAuC;AACrC,YACE,CAACzF,cAAc,CAAClB,IAAf,CAAoBklC,IAApB,EAA0BC,KAAK,CAACx+B,CAAD,CAA/B,CAAD,IACA,CAACm+B,EAAE,CAACG,IAAI,CAACE,KAAK,CAACx+B,CAAD,CAAN,CAAL,EAAiBu+B,IAAI,CAACC,KAAK,CAACx+B,CAAD,CAAN,CAArB,CAFL,EAGE;AACA,iBAAO,KAAP;AACD;AACF;;AAED,aAAO,IAAP;AACD;;AAED,QAAI0+B,oBAAoB,GAAG,EAA3B;AACA,QAAIr/B,OAAO,GAAGnG,KAAK,CAACmG,OAApB;AAIA,QAAIs/B,eAAe,GAAG,IAAIvnC,KAAK,CAAC+yB,SAAV,GAAsByU,IAA5C;AAEA,QAAIC,uCAAuC,GAAG,KAAK,CAAnD;AACA,QAAIC,8BAA8B,GAAG,KAAK,CAA1C;AACA,QAAIC,mDAAmD,GAAG,KAAK,CAA/D;AACA,QAAIC,2CAA2C,GAAG,KAAK,CAAvD;AACA,QAAIC,iCAAiC,GAAG,KAAK,CAA7C;AACA,QAAIC,2BAA2B,GAAG,KAAK,CAAvC;AACA,QAAIC,qBAAqB,GAAG,KAAK,CAAjC;AACA,QAAIC,yCAAyC,GAAG,KAAK,CAArD;AAEA;AACEP,MAAAA,uCAAuC,GAAG,IAAIhZ,GAAJ,EAA1C;AACAiZ,MAAAA,8BAA8B,GAAG,IAAIjZ,GAAJ,EAAjC;AACAkZ,MAAAA,mDAAmD,GAAG,IAAIlZ,GAAJ,EAAtD;AACAmZ,MAAAA,2CAA2C,GAAG,IAAInZ,GAAJ,EAA9C;AACAuZ,MAAAA,yCAAyC,GAAG,IAAIvZ,GAAJ,EAA5C;AACAoZ,MAAAA,iCAAiC,GAAG,IAAIpZ,GAAJ,EAApC;AAEA,UAAIwZ,wBAAwB,GAAG,IAAIxZ,GAAJ,EAA/B;;AAEAsZ,MAAAA,qBAAqB,GAAG,+BAASrkB,QAAT,EAAmBwkB,UAAnB,EAA+B;AACrD,YAAIxkB,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAP,KAAoB,UAA7C,EAAyD;AACvD;AACD;;AACD,YAAIlH,GAAG,GAAG0rB,UAAU,GAAG,GAAb,GAAmBxkB,QAA7B;;AACA,YAAI,CAACukB,wBAAwB,CAACpY,GAAzB,CAA6BrT,GAA7B,CAAL,EAAwC;AACtCyrB,UAAAA,wBAAwB,CAACnY,GAAzB,CAA6BtT,GAA7B;AACArV,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,qEACE,iCAHiB,EAInB+gC,UAJmB,EAKnBxkB,QALmB,CAArB;AAOD;AACF,OAfD;;AAiBAokB,MAAAA,2BAA2B,GAAG,qCAASr/B,IAAT,EAAe45B,YAAf,EAA6B;AACzD,YAAIA,YAAY,KAAK3hC,SAArB,EAAgC;AAC9B,cAAIgvB,aAAa,GAAGlR,gBAAgB,CAAC/V,IAAD,CAAhB,IAA0B,WAA9C;;AACA,cAAI,CAACo/B,iCAAiC,CAAChY,GAAlC,CAAsCH,aAAtC,CAAL,EAA2D;AACzDmY,YAAAA,iCAAiC,CAAC/X,GAAlC,CAAsCJ,aAAtC;AACAvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,qFACE,8BAHiB,EAInBuoB,aAJmB,CAArB;AAMD;AACF;AACF,OAbD;;AAoBA3f,MAAAA,MAAM,CAACC,cAAP,CAAsBs3B,oBAAtB,EAA4C,sBAA5C,EAAoE;AAClEa,QAAAA,UAAU,EAAE,KADsD;AAElEzrB,QAAAA,KAAK,EAAE,iBAAW;AAChB9b,UAAAA,SAAS,CACP,KADO,EAEP,qEACE,qEADF,GAEE,+CAFF,GAGE,kEAHF,GAIE,oEAJF,GAKE,4BAPK,CAAT;AASD;AAZiE,OAApE;AAcAmP,MAAAA,MAAM,CAAC+L,MAAP,CAAcwrB,oBAAd;AACD;;AAED,aAASc,0BAAT,CACE9b,cADF,EAEE+b,IAFF,EAGEC,wBAHF,EAIEllB,SAJF,EAKE;AACA,UAAI8e,SAAS,GAAG5V,cAAc,CAAC4L,aAA/B;AAEA;AACE,YACEnL,2BAA2B,IAC1BC,wCAAwC,IACvCV,cAAc,CAACwL,IAAf,GAAsBX,UAH1B,EAIE;AAEAmR,UAAAA,wBAAwB,CAACllB,SAAD,EAAY8e,SAAZ,CAAxB;AACD;AACF;AAED,UAAIG,YAAY,GAAGiG,wBAAwB,CAACllB,SAAD,EAAY8e,SAAZ,CAA3C;AAEA;AACE4F,QAAAA,2BAA2B,CAACO,IAAD,EAAOhG,YAAP,CAA3B;AACD;AAED,UAAInK,aAAa,GACfmK,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK3hC,SAA1C,GACIwhC,SADJ,GAEI,SAAc,EAAd,EAAkBA,SAAlB,EAA6BG,YAA7B,CAHN;AAIA/V,MAAAA,cAAc,CAAC4L,aAAf,GAA+BA,aAA/B;AAIA,UAAID,WAAW,GAAG3L,cAAc,CAAC2L,WAAjC;;AACA,UAAIA,WAAW,KAAK,IAAhB,IAAwB3L,cAAc,CAACsE,cAAf,KAAkCgF,MAA9D,EAAsE;AACpEqC,QAAAA,WAAW,CAAC4I,SAAZ,GAAwB3I,aAAxB;AACD;AACF;;AAED,QAAIqQ,qBAAqB,GAAG;AAC1B9nB,MAAAA,SAAS,EAAEA,SADe;AAE1B+nB,MAAAA,eAAe,EAAE,yBAAShgC,IAAT,EAAeg5B,OAAf,EAAwB9d,QAAxB,EAAkC;AACjD,YAAIrD,KAAK,GAAG9D,KAAK,CAAC/T,IAAD,CAAjB;AACA,YAAIguB,WAAW,GAAGiS,kBAAkB,EAApC;AACA,YAAI7X,cAAc,GAAG8X,yBAAyB,CAAClS,WAAD,EAAcnW,KAAd,CAA9C;AAEA,YAAIqhB,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AACA8Q,QAAAA,MAAM,CAACF,OAAP,GAAiBA,OAAjB;;AACA,YAAI9d,QAAQ,KAAKhjB,SAAb,IAA0BgjB,QAAQ,KAAK,IAA3C,EAAiD;AAC/C;AACEqkB,YAAAA,qBAAqB,CAACrkB,QAAD,EAAW,UAAX,CAArB;AACD;AACDge,UAAAA,MAAM,CAAChe,QAAP,GAAkBA,QAAlB;AACD;;AAEDie,QAAAA,aAAa,CAACthB,KAAD,EAAQqhB,MAAR,CAAb;AACAiH,QAAAA,YAAY,CAACtoB,KAAD,EAAQuQ,cAAR,CAAZ;AACD,OAlByB;AAmB1BgY,MAAAA,mBAAmB,EAAE,6BAASpgC,IAAT,EAAeg5B,OAAf,EAAwB9d,QAAxB,EAAkC;AACrD,YAAIrD,KAAK,GAAG9D,KAAK,CAAC/T,IAAD,CAAjB;AACA,YAAIguB,WAAW,GAAGiS,kBAAkB,EAApC;AACA,YAAI7X,cAAc,GAAG8X,yBAAyB,CAAClS,WAAD,EAAcnW,KAAd,CAA9C;AAEA,YAAIqhB,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AACA8Q,QAAAA,MAAM,CAACn3B,GAAP,GAAa81B,YAAb;AACAqB,QAAAA,MAAM,CAACF,OAAP,GAAiBA,OAAjB;;AAEA,YAAI9d,QAAQ,KAAKhjB,SAAb,IAA0BgjB,QAAQ,KAAK,IAA3C,EAAiD;AAC/C;AACEqkB,YAAAA,qBAAqB,CAACrkB,QAAD,EAAW,cAAX,CAArB;AACD;AACDge,UAAAA,MAAM,CAAChe,QAAP,GAAkBA,QAAlB;AACD;;AAEDie,QAAAA,aAAa,CAACthB,KAAD,EAAQqhB,MAAR,CAAb;AACAiH,QAAAA,YAAY,CAACtoB,KAAD,EAAQuQ,cAAR,CAAZ;AACD,OArCyB;AAsC1BiY,MAAAA,kBAAkB,EAAE,4BAASrgC,IAAT,EAAekb,QAAf,EAAyB;AAC3C,YAAIrD,KAAK,GAAG9D,KAAK,CAAC/T,IAAD,CAAjB;AACA,YAAIguB,WAAW,GAAGiS,kBAAkB,EAApC;AACA,YAAI7X,cAAc,GAAG8X,yBAAyB,CAAClS,WAAD,EAAcnW,KAAd,CAA9C;AAEA,YAAIqhB,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AACA8Q,QAAAA,MAAM,CAACn3B,GAAP,GAAa+1B,WAAb;;AAEA,YAAI5c,QAAQ,KAAKhjB,SAAb,IAA0BgjB,QAAQ,KAAK,IAA3C,EAAiD;AAC/C;AACEqkB,YAAAA,qBAAqB,CAACrkB,QAAD,EAAW,aAAX,CAArB;AACD;AACDge,UAAAA,MAAM,CAAChe,QAAP,GAAkBA,QAAlB;AACD;;AAEDie,QAAAA,aAAa,CAACthB,KAAD,EAAQqhB,MAAR,CAAb;AACAiH,QAAAA,YAAY,CAACtoB,KAAD,EAAQuQ,cAAR,CAAZ;AACD;AAvDyB,KAA5B;;AA0DA,aAASkY,0BAAT,CACExc,cADF,EAEE+b,IAFF,EAGE/e,QAHF,EAIEC,QAJF,EAKEwf,QALF,EAMEC,QANF,EAOEC,iBAPF,EAQE;AACA,UAAI33B,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;;AACA,UAAI,OAAOyG,QAAQ,CAAC43B,qBAAhB,KAA0C,UAA9C,EAA0D;AACxDjY,QAAAA,eAAe,CAAC3E,cAAD,EAAiB,uBAAjB,CAAf;AACA,YAAIjJ,YAAY,GAAG/R,QAAQ,CAAC43B,qBAAT,CACjB3f,QADiB,EAEjByf,QAFiB,EAGjBC,iBAHiB,CAAnB;AAKA/X,QAAAA,cAAc;AAEd;AACE,YAAE7N,YAAY,KAAK3iB,SAAnB,IACIyG,qBAAqB,CACnB,KADmB,EAEnB,iEACE,mDAHiB,EAInBqX,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,WAJP,CADzB,GAOI,KAAK,CAPT;AAQD;AAED,eAAOhlB,YAAP;AACD;;AAED,UAAIglB,IAAI,CAACtmC,SAAL,IAAkBsmC,IAAI,CAACtmC,SAAL,CAAeonC,oBAArC,EAA2D;AACzD,eACE,CAAClC,YAAY,CAAC3d,QAAD,EAAWC,QAAX,CAAb,IAAqC,CAAC0d,YAAY,CAAC8B,QAAD,EAAWC,QAAX,CADpD;AAGD;;AAED,aAAO,IAAP;AACD;;AAED,aAASI,kBAAT,CAA4B9c,cAA5B,EAA4C+b,IAA5C,EAAkD9e,QAAlD,EAA4D;AAC1D,UAAIjY,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AACA;AACE,YAAIrJ,IAAI,GAAGgd,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,WAArC;AACA,YAAIgB,aAAa,GAAG/3B,QAAQ,CAACsN,MAA7B;;AAEA,YAAI,CAACyqB,aAAL,EAAoB;AAClB,cAAIhB,IAAI,CAACtmC,SAAL,IAAkB,OAAOsmC,IAAI,CAACtmC,SAAL,CAAe6c,MAAtB,KAAiC,UAAvD,EAAmE;AACjEzX,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,iEACE,uEAHiB,EAInB3F,IAJmB,CAArB;AAMD,WAPD,MAOO;AACL2F,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,iEACE,sDAHiB,EAInB3F,IAJmB,CAArB;AAMD;AACF;;AAED,YAAI8nC,sBAAsB,GACxB,CAACh4B,QAAQ,CAACi4B,eAAV,IACAj4B,QAAQ,CAACi4B,eAAT,CAAyBC,oBADzB,IAEAl4B,QAAQ,CAAC0P,KAHX;AAIA,SAACsoB,sBAAD,GACIniC,qBAAqB,CACnB,KADmB,EAEnB,kEACE,sEADF,GAEE,kDAJiB,EAKnB3F,IALmB,CADzB,GAQI,KAAK,CART;AASA,YAAIioC,sBAAsB,GACxB,CAACn4B,QAAQ,CAACo4B,eAAV,IACAp4B,QAAQ,CAACo4B,eAAT,CAAyBF,oBAF3B;AAGA,SAACC,sBAAD,GACItiC,qBAAqB,CACnB,KADmB,EAEnB,kEACE,sEADF,GAEE,uDAJiB,EAKnB3F,IALmB,CADzB,GAQI,KAAK,CART;AASA,YAAImoC,mBAAmB,GAAG,CAACr4B,QAAQ,CAACs4B,SAApC;AACA,SAACD,mBAAD,GACIxiC,qBAAqB,CACnB,KADmB,EAEnB,uEACE,uCAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIqoC,sBAAsB,GAAG,CAACv4B,QAAQ,CAACkiB,YAAvC;AACA,SAACqW,sBAAD,GACI1iC,qBAAqB,CACnB,KADmB,EAEnB,0EACE,0CAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIsoC,uBAAuB,GACzB,OAAOx4B,QAAQ,CAACy4B,qBAAhB,KAA0C,UAD5C;AAEA,SAACD,uBAAD,GACI3iC,qBAAqB,CACnB,KADmB,EAEnB,4BACE,iEADF,GAEE,4DAFF,GAGE,6BALiB,EAMnB3F,IANmB,CADzB,GASI,KAAK,CATT;;AAUA,YACE6mC,IAAI,CAACtmC,SAAL,IACAsmC,IAAI,CAACtmC,SAAL,CAAeonC,oBADf,IAEA,OAAO73B,QAAQ,CAAC43B,qBAAhB,KAA0C,WAH5C,EAIE;AACA/hC,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,qDACE,+EADF,GAEE,iEAJiB,EAKnBqX,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,kBALP,CAArB;AAOD;;AACD,YAAI2B,qBAAqB,GACvB,OAAO14B,QAAQ,CAAC24B,mBAAhB,KAAwC,UAD1C;AAEA,SAACD,qBAAD,GACI7iC,qBAAqB,CACnB,KADmB,EAEnB,4BACE,gEADF,GAEE,sCAJiB,EAKnB3F,IALmB,CADzB,GAQI,KAAK,CART;AASA,YAAI0oC,0BAA0B,GAC5B,OAAO54B,QAAQ,CAAC64B,wBAAhB,KAA6C,UAD/C;AAEA,SAACD,0BAAD,GACI/iC,qBAAqB,CACnB,KADmB,EAEnB,4BACE,qEADF,GAEE,kEAFF,GAGE,iEAHF,GAIE,yFANiB,EAOnB3F,IAPmB,CADzB,GAUI,KAAK,CAVT;AAWA,YAAI4oC,2BAA2B,GAC7B,OAAO94B,QAAQ,CAAC+4B,yBAAhB,KAA8C,UADhD;AAEA,SAACD,2BAAD,GACIjjC,qBAAqB,CACnB,KADmB,EAEnB,4BACE,wEAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAI8oC,iCAAiC,GACnC,OAAOh5B,QAAQ,CAACi5B,gCAAhB,KAAqD,UADvD;AAEA,SAACD,iCAAD,GACInjC,qBAAqB,CACnB,KADmB,EAEnB,4BACE,sFAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIgpC,eAAe,GAAGl5B,QAAQ,CAAC7G,KAAT,KAAmB8e,QAAzC;AACA,UAAEjY,QAAQ,CAAC7G,KAAT,KAAmB/J,SAAnB,IAAgC,CAAC8pC,eAAnC,IACIrjC,qBAAqB,CACnB,KADmB,EAEnB,8DACE,iEAHiB,EAInB3F,IAJmB,EAKnBA,IALmB,CADzB,GAQI,KAAK,CART;AASA,YAAIipC,sBAAsB,GAAG,CAACn5B,QAAQ,CAACo5B,YAAvC;AACA,SAACD,sBAAD,GACItjC,qBAAqB,CACnB,KADmB,EAEnB,6FACE,2DAHiB,EAInB3F,IAJmB,EAKnBA,IALmB,CADzB,GAQI,KAAK,CART;;AAUA,YACE,OAAO8P,QAAQ,CAACq5B,uBAAhB,KAA4C,UAA5C,IACA,OAAOr5B,QAAQ,CAACs5B,kBAAhB,KAAuC,UADvC,IAEA,CAACjD,mDAAmD,CAAC9X,GAApD,CAAwDwY,IAAxD,CAHH,EAIE;AACAV,UAAAA,mDAAmD,CAAC7X,GAApD,CAAwDuY,IAAxD;AACAlhC,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,6EACE,wDAHiB,EAInBqX,gBAAgB,CAAC6pB,IAAD,CAJG,CAArB;AAMD;;AAED,YAAIwC,kCAAkC,GACpC,OAAOv5B,QAAQ,CAACg3B,wBAAhB,KAA6C,UAD/C;AAEA,SAACuC,kCAAD,GACI1jC,qBAAqB,CACnB,KADmB,EAEnB,qEACE,8DAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIspC,kCAAkC,GACpC,OAAOx5B,QAAQ,CAACy5B,wBAAhB,KAA6C,UAD/C;AAEA,SAACD,kCAAD,GACI3jC,qBAAqB,CACnB,KADmB,EAEnB,qEACE,8DAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIwpC,+BAA+B,GACjC,OAAO3C,IAAI,CAACsC,uBAAZ,KAAwC,UAD1C;AAEA,SAACK,+BAAD,GACI7jC,qBAAqB,CACnB,KADmB,EAEnB,iEACE,iEAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQA,YAAIypC,MAAM,GAAG35B,QAAQ,CAAC0P,KAAtB;;AACA,YAAIiqB,MAAM,KAAK,OAAOA,MAAP,KAAkB,QAAlB,IAA8BhjC,OAAO,CAACgjC,MAAD,CAA1C,CAAV,EAA+D;AAC7D9jC,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,4CAFmB,EAGnB3F,IAHmB,CAArB;AAKD;;AACD,YAAI,OAAO8P,QAAQ,CAAC2iB,eAAhB,KAAoC,UAAxC,EAAoD;AAClD,YAAE,OAAOoU,IAAI,CAAC3U,iBAAZ,KAAkC,QAApC,IACIvsB,qBAAqB,CACnB,KADmB,EAEnB,yEACE,wBAHiB,EAInB3F,IAJmB,CADzB,GAOI,KAAK,CAPT;AAQD;AACF;AACF;;AAED,aAAS0pC,kBAAT,CAA4B5e,cAA5B,EAA4Chb,QAA5C,EAAsD;AACpDA,MAAAA,QAAQ,CAAC65B,OAAT,GAAmB5C,qBAAnB;AACAjc,MAAAA,cAAc,CAACzhB,SAAf,GAA2ByG,QAA3B;AAEAZ,MAAAA,GAAG,CAACY,QAAD,EAAWgb,cAAX,CAAH;AACA;AACEhb,QAAAA,QAAQ,CAAC85B,sBAAT,GAAkC9D,oBAAlC;AACD;AACF;;AAED,aAAS+D,sBAAT,CACE/e,cADF,EAEE+b,IAFF,EAGE59B,KAHF,EAIEu1B,oBAJF,EAKE;AACA,UAAI7M,eAAe,GAAGL,kBAAkB,CAACxG,cAAD,EAAiB+b,IAAjB,EAAuB,IAAvB,CAAxC;AACA,UAAI7U,YAAY,GAAG6U,IAAI,CAAC7U,YAAxB;AACA,UAAI8X,iBAAiB,GAAG9X,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK9yB,SAAlE;AACA,UAAIkB,OAAO,GAAG0pC,iBAAiB,GAC3B/X,gBAAgB,CAACjH,cAAD,EAAiB6G,eAAjB,CADW,GAE3BT,kBAFJ;AAKA;AACE,YACE3F,2BAA2B,IAC1BC,wCAAwC,IACvCV,cAAc,CAACwL,IAAf,GAAsBX,UAH1B,EAIE;AACA,cAAIkR,IAAJ,CAAS59B,KAAT,EAAgB7I,OAAhB;AACD;AACF;AAED,UAAI0P,QAAQ,GAAG,IAAI+2B,IAAJ,CAAS59B,KAAT,EAAgB7I,OAAhB,CAAf;AACA,UAAIof,KAAK,GAAIsL,cAAc,CAAC4L,aAAf,GACX5mB,QAAQ,CAAC0P,KAAT,KAAmB,IAAnB,IAA2B1P,QAAQ,CAAC0P,KAAT,KAAmBtgB,SAA9C,GACI4Q,QAAQ,CAAC0P,KADb,GAEI,IAHN;AAIAkqB,MAAAA,kBAAkB,CAAC5e,cAAD,EAAiBhb,QAAjB,CAAlB;AAEA;AACE,YAAI,OAAO+2B,IAAI,CAACC,wBAAZ,KAAyC,UAAzC,IAAuDtnB,KAAK,KAAK,IAArE,EAA2E;AACzE,cAAI0O,aAAa,GAAGlR,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,WAA9C;;AACA,cAAI,CAACX,8BAA8B,CAAC7X,GAA/B,CAAmCH,aAAnC,CAAL,EAAwD;AACtDgY,YAAAA,8BAA8B,CAAC5X,GAA/B,CAAmCJ,aAAnC;AACAvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,mEACE,oEADF,GAEE,kEAFF,GAGE,iFALiB,EAMnBuoB,aANmB,EAOnBpe,QAAQ,CAAC0P,KAAT,KAAmB,IAAnB,GAA0B,MAA1B,GAAmC,WAPhB,EAQnB0O,aARmB,CAArB;AAUD;AACF;;AAKD,YACE,OAAO2Y,IAAI,CAACC,wBAAZ,KAAyC,UAAzC,IACA,OAAOh3B,QAAQ,CAACq5B,uBAAhB,KAA4C,UAF9C,EAGE;AACA,cAAIY,kBAAkB,GAAG,IAAzB;AACA,cAAIC,yBAAyB,GAAG,IAAhC;AACA,cAAIC,mBAAmB,GAAG,IAA1B;;AACA,cACE,OAAOn6B,QAAQ,CAACktB,kBAAhB,KAAuC,UAAvC,IACAltB,QAAQ,CAACktB,kBAAT,CAA4BC,4BAA5B,KAA6D,IAF/D,EAGE;AACA8M,YAAAA,kBAAkB,GAAG,oBAArB;AACD,WALD,MAKO,IAAI,OAAOj6B,QAAQ,CAACirB,yBAAhB,KAA8C,UAAlD,EAA8D;AACnEgP,YAAAA,kBAAkB,GAAG,2BAArB;AACD;;AACD,cACE,OAAOj6B,QAAQ,CAACotB,yBAAhB,KAA8C,UAA9C,IACAptB,QAAQ,CAACotB,yBAAT,CAAmCD,4BAAnC,KAAoE,IAFtE,EAGE;AACA+M,YAAAA,yBAAyB,GAAG,2BAA5B;AACD,WALD,MAKO,IACL,OAAOl6B,QAAQ,CAACkrB,gCAAhB,KAAqD,UADhD,EAEL;AACAgP,YAAAA,yBAAyB,GAAG,kCAA5B;AACD;;AACD,cACE,OAAOl6B,QAAQ,CAACqtB,mBAAhB,KAAwC,UAAxC,IACArtB,QAAQ,CAACqtB,mBAAT,CAA6BF,4BAA7B,KAA8D,IAFhE,EAGE;AACAgN,YAAAA,mBAAmB,GAAG,qBAAtB;AACD,WALD,MAKO,IAAI,OAAOn6B,QAAQ,CAACmrB,0BAAhB,KAA+C,UAAnD,EAA+D;AACpEgP,YAAAA,mBAAmB,GAAG,4BAAtB;AACD;;AACD,cACEF,kBAAkB,KAAK,IAAvB,IACAC,yBAAyB,KAAK,IAD9B,IAEAC,mBAAmB,KAAK,IAH1B,EAIE;AACA,gBAAIC,cAAc,GAAGltB,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,WAA/C;;AACA,gBAAIsD,UAAU,GACZ,OAAOtD,IAAI,CAACC,wBAAZ,KAAyC,UAAzC,GACI,4BADJ,GAEI,2BAHN;;AAIA,gBAAI,CAACV,2CAA2C,CAAC/X,GAA5C,CAAgD6b,cAAhD,CAAL,EAAsE;AACpE9D,cAAAA,2CAA2C,CAAC9X,GAA5C,CAAgD4b,cAAhD;AACAvkC,cAAAA,qBAAqB,CACnB,KADmB,EAEnB,6FACE,yEADF,GAEE,+EAFF,GAGE,qDALiB,EAMnBukC,cANmB,EAOnBC,UAPmB,EAQnBJ,kBAAkB,KAAK,IAAvB,GAA8B,SAASA,kBAAvC,GAA4D,EARzC,EASnBC,yBAAyB,KAAK,IAA9B,GACI,SAASA,yBADb,GAEI,EAXe,EAYnBC,mBAAmB,KAAK,IAAxB,GAA+B,SAASA,mBAAxC,GAA8D,EAZ3C,CAArB;AAcD;AACF;AACF;AACF;;AAID,UAAIH,iBAAJ,EAAuB;AACrBpY,QAAAA,YAAY,CAAC5G,cAAD,EAAiB6G,eAAjB,EAAkCvxB,OAAlC,CAAZ;AACD;;AAED,aAAO0P,QAAP;AACD;;AAED,aAASs6B,sBAAT,CAAgCtf,cAAhC,EAAgDhb,QAAhD,EAA0D;AACxD2f,MAAAA,eAAe,CAAC3E,cAAD,EAAiB,oBAAjB,CAAf;AACA,UAAIyc,QAAQ,GAAGz3B,QAAQ,CAAC0P,KAAxB;;AAEA,UAAI,OAAO1P,QAAQ,CAACktB,kBAAhB,KAAuC,UAA3C,EAAuD;AACrDltB,QAAAA,QAAQ,CAACktB,kBAAT;AACD;;AACD,UAAI,OAAOltB,QAAQ,CAACirB,yBAAhB,KAA8C,UAAlD,EAA8D;AAC5DjrB,QAAAA,QAAQ,CAACirB,yBAAT;AACD;;AAEDrL,MAAAA,cAAc;;AAEd,UAAI6X,QAAQ,KAAKz3B,QAAQ,CAAC0P,KAA1B,EAAiC;AAC/B;AACE7Z,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,kEACE,0CADF,GAEE,qCAJiB,EAKnBqX,gBAAgB,CAAC8N,cAAc,CAAC7jB,IAAhB,CAAhB,IAAyC,WALtB,CAArB;AAOD;AACD8/B,QAAAA,qBAAqB,CAACK,mBAAtB,CAA0Ct3B,QAA1C,EAAoDA,QAAQ,CAAC0P,KAA7D,EAAoE,IAApE;AACD;AACF;;AAED,aAAS6qB,6BAAT,CACEvf,cADF,EAEEhb,QAFF,EAGEiY,QAHF,EAIE0f,iBAJF,EAKE;AACA,UAAIF,QAAQ,GAAGz3B,QAAQ,CAAC0P,KAAxB;AACAiQ,MAAAA,eAAe,CAAC3E,cAAD,EAAiB,2BAAjB,CAAf;;AACA,UAAI,OAAOhb,QAAQ,CAACotB,yBAAhB,KAA8C,UAAlD,EAA8D;AAC5DptB,QAAAA,QAAQ,CAACotB,yBAAT,CAAmCnV,QAAnC,EAA6C0f,iBAA7C;AACD;;AACD,UAAI,OAAO33B,QAAQ,CAACkrB,gCAAhB,KAAqD,UAAzD,EAAqE;AACnElrB,QAAAA,QAAQ,CAACkrB,gCAAT,CAA0CjT,QAA1C,EAAoD0f,iBAApD;AACD;;AACD/X,MAAAA,cAAc;;AAEd,UAAI5f,QAAQ,CAAC0P,KAAT,KAAmB+nB,QAAvB,EAAiC;AAC/B;AACE,cAAIrZ,aAAa,GAAGlR,gBAAgB,CAAC8N,cAAc,CAAC7jB,IAAhB,CAAhB,IAAyC,WAA7D;;AACA,cAAI,CAACg/B,uCAAuC,CAAC5X,GAAxC,CAA4CH,aAA5C,CAAL,EAAiE;AAC/D+X,YAAAA,uCAAuC,CAAC3X,GAAxC,CAA4CJ,aAA5C;AACAvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,2DACE,wDADF,GAEE,qCAJiB,EAKnBuoB,aALmB,CAArB;AAOD;AACF;AACD6Y,QAAAA,qBAAqB,CAACK,mBAAtB,CAA0Ct3B,QAA1C,EAAoDA,QAAQ,CAAC0P,KAA7D,EAAoE,IAApE;AACD;AACF;;AAGD,aAAS8qB,kBAAT,CACExf,cADF,EAEE+b,IAFF,EAGE9e,QAHF,EAIEyW,oBAJF,EAKE;AACA;AACEoJ,QAAAA,kBAAkB,CAAC9c,cAAD,EAAiB+b,IAAjB,EAAuB9e,QAAvB,CAAlB;AACD;AAED,UAAIjY,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AACA,UAAIsoB,eAAe,GAAGL,kBAAkB,CAACxG,cAAD,EAAiB+b,IAAjB,EAAuB,IAAvB,CAAxC;AAEA/2B,MAAAA,QAAQ,CAAC7G,KAAT,GAAiB8e,QAAjB;AACAjY,MAAAA,QAAQ,CAAC0P,KAAT,GAAiBsL,cAAc,CAAC4L,aAAhC;AACA5mB,MAAAA,QAAQ,CAACk2B,IAAT,GAAgBD,eAAhB;AACAj2B,MAAAA,QAAQ,CAAC1P,OAAT,GAAmB2xB,gBAAgB,CAACjH,cAAD,EAAiB6G,eAAjB,CAAnC;AAEA;AACE,YAAI7hB,QAAQ,CAAC0P,KAAT,KAAmBuI,QAAvB,EAAiC;AAC/B,cAAImG,aAAa,GAAGlR,gBAAgB,CAAC6pB,IAAD,CAAhB,IAA0B,WAA9C;;AACA,cAAI,CAACL,yCAAyC,CAACnY,GAA1C,CAA8CH,aAA9C,CAAL,EAAmE;AACjEsY,YAAAA,yCAAyC,CAAClY,GAA1C,CAA8CJ,aAA9C;AACAvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,iEACE,wDADF,GAEE,oDAJiB,EAKnBuoB,aALmB,CAArB;AAOD;AACF;;AAED,YAAIpD,cAAc,CAACwL,IAAf,GAAsBX,UAA1B,EAAsC;AACpC2E,UAAAA,uBAAuB,CAACK,6BAAxB,CACE7P,cADF,EAEEhb,QAFF;AAKAwqB,UAAAA,uBAAuB,CAACM,0BAAxB,CACE9P,cADF,EAEEhb,QAFF;AAID;;AAED,YAAI+b,6BAAJ,EAAmC;AACjCyO,UAAAA,uBAAuB,CAACI,yBAAxB,CACE5P,cADF,EAEEhb,QAFF;AAID;AACF;AAED,UAAI2mB,WAAW,GAAG3L,cAAc,CAAC2L,WAAjC;;AACA,UAAIA,WAAW,KAAK,IAApB,EAA0B;AACxBqK,QAAAA,kBAAkB,CAChBhW,cADgB,EAEhB2L,WAFgB,EAGhB1O,QAHgB,EAIhBjY,QAJgB,EAKhB0uB,oBALgB,CAAlB;AAOA1uB,QAAAA,QAAQ,CAAC0P,KAAT,GAAiBsL,cAAc,CAAC4L,aAAhC;AACD;;AAED,UAAIoQ,wBAAwB,GAAGD,IAAI,CAACC,wBAApC;;AACA,UAAI,OAAOA,wBAAP,KAAoC,UAAxC,EAAoD;AAClDF,QAAAA,0BAA0B,CACxB9b,cADwB,EAExB+b,IAFwB,EAGxBC,wBAHwB,EAIxB/e,QAJwB,CAA1B;AAMAjY,QAAAA,QAAQ,CAAC0P,KAAT,GAAiBsL,cAAc,CAAC4L,aAAhC;AACD;;AAID,UACE,OAAOmQ,IAAI,CAACC,wBAAZ,KAAyC,UAAzC,IACA,OAAOh3B,QAAQ,CAACq5B,uBAAhB,KAA4C,UAD5C,KAEC,OAAOr5B,QAAQ,CAACirB,yBAAhB,KAA8C,UAA9C,IACC,OAAOjrB,QAAQ,CAACktB,kBAAhB,KAAuC,UAHzC,CADF,EAKE;AACAoN,QAAAA,sBAAsB,CAACtf,cAAD,EAAiBhb,QAAjB,CAAtB;AAGA2mB,QAAAA,WAAW,GAAG3L,cAAc,CAAC2L,WAA7B;;AACA,YAAIA,WAAW,KAAK,IAApB,EAA0B;AACxBqK,UAAAA,kBAAkB,CAChBhW,cADgB,EAEhB2L,WAFgB,EAGhB1O,QAHgB,EAIhBjY,QAJgB,EAKhB0uB,oBALgB,CAAlB;AAOA1uB,UAAAA,QAAQ,CAAC0P,KAAT,GAAiBsL,cAAc,CAAC4L,aAAhC;AACD;AACF;;AAED,UAAI,OAAO5mB,QAAQ,CAACy6B,iBAAhB,KAAsC,UAA1C,EAAsD;AACpDzf,QAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;AACF;;AAED,aAAS6sB,wBAAT,CACE1f,cADF,EAEE+b,IAFF,EAGE9e,QAHF,EAIEyW,oBAJF,EAKE;AACA,UAAI1uB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AAEA,UAAIye,QAAQ,GAAGgD,cAAc,CAAC0L,aAA9B;AACA1mB,MAAAA,QAAQ,CAAC7G,KAAT,GAAiB6e,QAAjB;AAEA,UAAI2iB,UAAU,GAAG36B,QAAQ,CAAC1P,OAA1B;AACA,UAAIsqC,yBAAyB,GAAGpZ,kBAAkB,CAChDxG,cADgD,EAEhD+b,IAFgD,EAGhD,IAHgD,CAAlD;AAKA,UAAIY,iBAAiB,GAAG1V,gBAAgB,CACtCjH,cADsC,EAEtC4f,yBAFsC,CAAxC;AAKA,UAAI5D,wBAAwB,GAAGD,IAAI,CAACC,wBAApC;AACA,UAAI6D,gBAAgB,GAClB,OAAO7D,wBAAP,KAAoC,UAApC,IACA,OAAOh3B,QAAQ,CAACq5B,uBAAhB,KAA4C,UAF9C;;AAUA,UACE,CAACwB,gBAAD,KACC,OAAO76B,QAAQ,CAACkrB,gCAAhB,KAAqD,UAArD,IACC,OAAOlrB,QAAQ,CAACotB,yBAAhB,KAA8C,UAFhD,CADF,EAIE;AACA,YAAIpV,QAAQ,KAAKC,QAAb,IAAyB0iB,UAAU,KAAKhD,iBAA5C,EAA+D;AAC7D4C,UAAAA,6BAA6B,CAC3Bvf,cAD2B,EAE3Bhb,QAF2B,EAG3BiY,QAH2B,EAI3B0f,iBAJ2B,CAA7B;AAMD;AACF;;AAEDjG,MAAAA,mCAAmC;AAEnC,UAAI+F,QAAQ,GAAGzc,cAAc,CAAC4L,aAA9B;AACA,UAAI8Q,QAAQ,GAAI13B,QAAQ,CAAC0P,KAAT,GAAiB+nB,QAAjC;AACA,UAAI9Q,WAAW,GAAG3L,cAAc,CAAC2L,WAAjC;;AACA,UAAIA,WAAW,KAAK,IAApB,EAA0B;AACxBqK,QAAAA,kBAAkB,CAChBhW,cADgB,EAEhB2L,WAFgB,EAGhB1O,QAHgB,EAIhBjY,QAJgB,EAKhB0uB,oBALgB,CAAlB;AAOAgJ,QAAAA,QAAQ,GAAG1c,cAAc,CAAC4L,aAA1B;AACD;;AACD,UACE5O,QAAQ,KAAKC,QAAb,IACAwf,QAAQ,KAAKC,QADb,IAEA,CAACvV,iBAAiB,EAFlB,IAGA,CAACwP,kCAAkC,EAJrC,EAKE;AAGA,YAAI,OAAO3xB,QAAQ,CAACy6B,iBAAhB,KAAsC,UAA1C,EAAsD;AACpDzf,UAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AACD,eAAO,KAAP;AACD;;AAED,UAAI,OAAOmpB,wBAAP,KAAoC,UAAxC,EAAoD;AAClDF,QAAAA,0BAA0B,CACxB9b,cADwB,EAExB+b,IAFwB,EAGxBC,wBAHwB,EAIxB/e,QAJwB,CAA1B;AAMAyf,QAAAA,QAAQ,GAAG1c,cAAc,CAAC4L,aAA1B;AACD;;AAED,UAAI7U,YAAY,GACd4f,kCAAkC,MAClC6F,0BAA0B,CACxBxc,cADwB,EAExB+b,IAFwB,EAGxB/e,QAHwB,EAIxBC,QAJwB,EAKxBwf,QALwB,EAMxBC,QANwB,EAOxBC,iBAPwB,CAF5B;;AAYA,UAAI5lB,YAAJ,EAAkB;AAGhB,YACE,CAAC8oB,gBAAD,KACC,OAAO76B,QAAQ,CAACirB,yBAAhB,KAA8C,UAA9C,IACC,OAAOjrB,QAAQ,CAACktB,kBAAhB,KAAuC,UAFzC,CADF,EAIE;AACAvN,UAAAA,eAAe,CAAC3E,cAAD,EAAiB,oBAAjB,CAAf;;AACA,cAAI,OAAOhb,QAAQ,CAACktB,kBAAhB,KAAuC,UAA3C,EAAuD;AACrDltB,YAAAA,QAAQ,CAACktB,kBAAT;AACD;;AACD,cAAI,OAAOltB,QAAQ,CAACirB,yBAAhB,KAA8C,UAAlD,EAA8D;AAC5DjrB,YAAAA,QAAQ,CAACirB,yBAAT;AACD;;AACDrL,UAAAA,cAAc;AACf;;AACD,YAAI,OAAO5f,QAAQ,CAACy6B,iBAAhB,KAAsC,UAA1C,EAAsD;AACpDzf,UAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;AACF,OApBD,MAoBO;AAGL,YAAI,OAAO7N,QAAQ,CAACy6B,iBAAhB,KAAsC,UAA1C,EAAsD;AACpDzf,UAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AAIDmN,QAAAA,cAAc,CAAC0L,aAAf,GAA+BzO,QAA/B;AACA+C,QAAAA,cAAc,CAAC4L,aAAf,GAA+B8Q,QAA/B;AACD;;AAID13B,MAAAA,QAAQ,CAAC7G,KAAT,GAAiB8e,QAAjB;AACAjY,MAAAA,QAAQ,CAAC0P,KAAT,GAAiBgoB,QAAjB;AACA13B,MAAAA,QAAQ,CAAC1P,OAAT,GAAmBqnC,iBAAnB;AAEA,aAAO5lB,YAAP;AACD;;AAGD,aAAS+oB,mBAAT,CACE7iC,OADF,EAEE+iB,cAFF,EAGE+b,IAHF,EAIE9e,QAJF,EAKEyW,oBALF,EAME;AACA,UAAI1uB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AAEA,UAAIye,QAAQ,GAAGgD,cAAc,CAAC0L,aAA9B;AACA1mB,MAAAA,QAAQ,CAAC7G,KAAT,GAAiB6e,QAAjB;AAEA,UAAI2iB,UAAU,GAAG36B,QAAQ,CAAC1P,OAA1B;AACA,UAAIsqC,yBAAyB,GAAGpZ,kBAAkB,CAChDxG,cADgD,EAEhD+b,IAFgD,EAGhD,IAHgD,CAAlD;AAKA,UAAIY,iBAAiB,GAAG1V,gBAAgB,CACtCjH,cADsC,EAEtC4f,yBAFsC,CAAxC;AAKA,UAAI5D,wBAAwB,GAAGD,IAAI,CAACC,wBAApC;AACA,UAAI6D,gBAAgB,GAClB,OAAO7D,wBAAP,KAAoC,UAApC,IACA,OAAOh3B,QAAQ,CAACq5B,uBAAhB,KAA4C,UAF9C;;AAUA,UACE,CAACwB,gBAAD,KACC,OAAO76B,QAAQ,CAACkrB,gCAAhB,KAAqD,UAArD,IACC,OAAOlrB,QAAQ,CAACotB,yBAAhB,KAA8C,UAFhD,CADF,EAIE;AACA,YAAIpV,QAAQ,KAAKC,QAAb,IAAyB0iB,UAAU,KAAKhD,iBAA5C,EAA+D;AAC7D4C,UAAAA,6BAA6B,CAC3Bvf,cAD2B,EAE3Bhb,QAF2B,EAG3BiY,QAH2B,EAI3B0f,iBAJ2B,CAA7B;AAMD;AACF;;AAEDjG,MAAAA,mCAAmC;AAEnC,UAAI+F,QAAQ,GAAGzc,cAAc,CAAC4L,aAA9B;AACA,UAAI8Q,QAAQ,GAAI13B,QAAQ,CAAC0P,KAAT,GAAiB+nB,QAAjC;AACA,UAAI9Q,WAAW,GAAG3L,cAAc,CAAC2L,WAAjC;;AACA,UAAIA,WAAW,KAAK,IAApB,EAA0B;AACxBqK,QAAAA,kBAAkB,CAChBhW,cADgB,EAEhB2L,WAFgB,EAGhB1O,QAHgB,EAIhBjY,QAJgB,EAKhB0uB,oBALgB,CAAlB;AAOAgJ,QAAAA,QAAQ,GAAG1c,cAAc,CAAC4L,aAA1B;AACD;;AAED,UACE5O,QAAQ,KAAKC,QAAb,IACAwf,QAAQ,KAAKC,QADb,IAEA,CAACvV,iBAAiB,EAFlB,IAGA,CAACwP,kCAAkC,EAJrC,EAKE;AAGA,YAAI,OAAO3xB,QAAQ,CAACs5B,kBAAhB,KAAuC,UAA3C,EAAuD;AACrD,cACEthB,QAAQ,KAAK/f,OAAO,CAACyuB,aAArB,IACA+Q,QAAQ,KAAKx/B,OAAO,CAAC2uB,aAFvB,EAGE;AACA5L,YAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;AACF;;AACD,YAAI,OAAO7N,QAAQ,CAACq5B,uBAAhB,KAA4C,UAAhD,EAA4D;AAC1D,cACErhB,QAAQ,KAAK/f,OAAO,CAACyuB,aAArB,IACA+Q,QAAQ,KAAKx/B,OAAO,CAAC2uB,aAFvB,EAGE;AACA5L,YAAAA,cAAc,CAAC/L,SAAf,IAA4Bb,QAA5B;AACD;AACF;;AACD,eAAO,KAAP;AACD;;AAED,UAAI,OAAO4oB,wBAAP,KAAoC,UAAxC,EAAoD;AAClDF,QAAAA,0BAA0B,CACxB9b,cADwB,EAExB+b,IAFwB,EAGxBC,wBAHwB,EAIxB/e,QAJwB,CAA1B;AAMAyf,QAAAA,QAAQ,GAAG1c,cAAc,CAAC4L,aAA1B;AACD;;AAED,UAAI7U,YAAY,GACd4f,kCAAkC,MAClC6F,0BAA0B,CACxBxc,cADwB,EAExB+b,IAFwB,EAGxB/e,QAHwB,EAIxBC,QAJwB,EAKxBwf,QALwB,EAMxBC,QANwB,EAOxBC,iBAPwB,CAF5B;;AAYA,UAAI5lB,YAAJ,EAAkB;AAGhB,YACE,CAAC8oB,gBAAD,KACC,OAAO76B,QAAQ,CAACmrB,0BAAhB,KAA+C,UAA/C,IACC,OAAOnrB,QAAQ,CAACqtB,mBAAhB,KAAwC,UAF1C,CADF,EAIE;AACA1N,UAAAA,eAAe,CAAC3E,cAAD,EAAiB,qBAAjB,CAAf;;AACA,cAAI,OAAOhb,QAAQ,CAACqtB,mBAAhB,KAAwC,UAA5C,EAAwD;AACtDrtB,YAAAA,QAAQ,CAACqtB,mBAAT,CAA6BpV,QAA7B,EAAuCyf,QAAvC,EAAiDC,iBAAjD;AACD;;AACD,cAAI,OAAO33B,QAAQ,CAACmrB,0BAAhB,KAA+C,UAAnD,EAA+D;AAC7DnrB,YAAAA,QAAQ,CAACmrB,0BAAT,CACElT,QADF,EAEEyf,QAFF,EAGEC,iBAHF;AAKD;;AACD/X,UAAAA,cAAc;AACf;;AACD,YAAI,OAAO5f,QAAQ,CAACs5B,kBAAhB,KAAuC,UAA3C,EAAuD;AACrDte,UAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AACD,YAAI,OAAO7N,QAAQ,CAACq5B,uBAAhB,KAA4C,UAAhD,EAA4D;AAC1Dre,UAAAA,cAAc,CAAC/L,SAAf,IAA4Bb,QAA5B;AACD;AACF,OA3BD,MA2BO;AAGL,YAAI,OAAOpO,QAAQ,CAACs5B,kBAAhB,KAAuC,UAA3C,EAAuD;AACrD,cACEthB,QAAQ,KAAK/f,OAAO,CAACyuB,aAArB,IACA+Q,QAAQ,KAAKx/B,OAAO,CAAC2uB,aAFvB,EAGE;AACA5L,YAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;AACF;;AACD,YAAI,OAAO7N,QAAQ,CAACq5B,uBAAhB,KAA4C,UAAhD,EAA4D;AAC1D,cACErhB,QAAQ,KAAK/f,OAAO,CAACyuB,aAArB,IACA+Q,QAAQ,KAAKx/B,OAAO,CAAC2uB,aAFvB,EAGE;AACA5L,YAAAA,cAAc,CAAC/L,SAAf,IAA4Bb,QAA5B;AACD;AACF;;AAID4M,QAAAA,cAAc,CAAC0L,aAAf,GAA+BzO,QAA/B;AACA+C,QAAAA,cAAc,CAAC4L,aAAf,GAA+B8Q,QAA/B;AACD;;AAID13B,MAAAA,QAAQ,CAAC7G,KAAT,GAAiB8e,QAAjB;AACAjY,MAAAA,QAAQ,CAAC0P,KAAT,GAAiBgoB,QAAjB;AACA13B,MAAAA,QAAQ,CAAC1P,OAAT,GAAmBqnC,iBAAnB;AAEA,aAAO5lB,YAAP;AACD;;AAED,QAAIgpB,gBAAgB,GAAG,KAAK,CAA5B;AACA,QAAIC,sBAAsB,GAAG,KAAK,CAAlC;AACA,QAAIC,iCAAiC,GAAG,KAAK,CAA7C;AACA,QAAIC,qBAAqB,GAAG,KAAK,CAAjC;AACA,QAAIC,2BAA2B,GAAG,KAAK,CAAvC;;AACA,QAAIC,iBAAiB,GAAG,2BAASvrB,KAAT,EAAgB,CAAE,CAA1C;;AAEA;AACEkrB,MAAAA,gBAAgB,GAAG,KAAnB;AACAC,MAAAA,sBAAsB,GAAG,KAAzB;AACAC,MAAAA,iCAAiC,GAAG,EAApC;AAOAC,MAAAA,qBAAqB,GAAG,EAAxB;AACAC,MAAAA,2BAA2B,GAAG,EAA9B;;AAEAC,MAAAA,iBAAiB,GAAG,2BAASvrB,KAAT,EAAgB;AAClC,YAAIA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAAvC,EAAiD;AAC/C;AACD;;AACD,YAAI,CAACA,KAAK,CAACwrB,MAAP,IAAiBxrB,KAAK,CAACwrB,MAAN,CAAaC,SAA9B,IAA2CzrB,KAAK,CAAC3E,GAAN,IAAa,IAA5D,EAAkE;AAChE;AACD;;AACD5b,QAAAA,SAAS,CACP,OAAOugB,KAAK,CAACwrB,MAAb,KAAwB,QADjB,EAEP,gEACE,sEAHK,CAAT;AAKAxrB,QAAAA,KAAK,CAACwrB,MAAN,CAAaC,SAAb,GAAyB,IAAzB;AAEA,YAAIC,yBAAyB,GAC3B,6DACA,uDADA,GAEA,mBAFA,GAGApgB,yBAAyB,EAJ3B;;AAKA,YAAI+f,qBAAqB,CAACK,yBAAD,CAAzB,EAAsD;AACpD;AACD;;AACDL,QAAAA,qBAAqB,CAACK,yBAAD,CAArB,GAAmD,IAAnD;AAEAnJ,QAAAA,SAAS,CACP,KADO,EAEP,6DACE,uDADF,GAEE,mBAJK,CAAT;AAMD,OA9BD;AA+BD;AAED,QAAIoJ,SAAS,GAAGhrC,KAAK,CAACmG,OAAtB;;AAEA,aAAS8kC,SAAT,CAAmBC,WAAnB,EAAgCC,UAAhC,EAA4C7T,OAA5C,EAAqD;AACnD,UAAI8T,QAAQ,GAAG9T,OAAO,CAACrB,GAAvB;;AACA,UACEmV,QAAQ,KAAK,IAAb,IACA,OAAOA,QAAP,KAAoB,UADpB,IAEA,OAAOA,QAAP,KAAoB,QAHtB,EAIE;AACA;AACE,cAAIF,WAAW,CAAClV,IAAZ,GAAmBX,UAAvB,EAAmC;AACjC,gBAAIzH,aAAa,GAAGlR,gBAAgB,CAACwuB,WAAW,CAACvkC,IAAb,CAAhB,IAAsC,WAA1D;;AACA,gBAAI,CAAC8jC,iCAAiC,CAAC7c,aAAD,CAAtC,EAAuD;AACrDvoB,cAAAA,qBAAqB,CACnB,KADmB,EAEnB,mEACE,oEADF,GAEE,yCAFF,GAGE,MAHF,GAIE,8CAJF,GAKE,8CAPiB,EAQnB+lC,QARmB,EASnB7gB,2BAA2B,CAAC2gB,WAAD,CATR,CAArB;AAWAT,cAAAA,iCAAiC,CAAC7c,aAAD,CAAjC,GAAmD,IAAnD;AACD;AACF;AACF;;AAED,YAAI0J,OAAO,CAACtV,MAAZ,EAAoB;AAClB,cAAInD,KAAK,GAAGyY,OAAO,CAACtV,MAApB;AACA,cAAItb,IAAI,GAAG,KAAK,CAAhB;;AACA,cAAImY,KAAJ,EAAW;AACT,gBAAIC,UAAU,GAAGD,KAAjB;AACA/f,YAAAA,SAAS,CACPggB,UAAU,CAACrW,GAAX,KAAmBmB,cAAnB,IACEkV,UAAU,CAACrW,GAAX,KAAmBoB,kBAFd,EAGP,iDAHO,CAAT;AAKAnD,YAAAA,IAAI,GAAGoY,UAAU,CAAC/V,SAAlB;AACD;;AACDjK,UAAAA,SAAS,CACP4H,IADO,EAEP,uEACE,qCAHK,EAIP0kC,QAJO,CAAT;AAMA,cAAIC,SAAS,GAAG,KAAKD,QAArB;;AAEA,cACED,UAAU,KAAK,IAAf,IACAA,UAAU,CAAClV,GAAX,KAAmB,IADnB,IAEA,OAAOkV,UAAU,CAAClV,GAAlB,KAA0B,UAF1B,IAGAkV,UAAU,CAAClV,GAAX,CAAeqV,UAAf,KAA8BD,SAJhC,EAKE;AACA,mBAAOF,UAAU,CAAClV,GAAlB;AACD;;AACD,cAAIA,GAAG,GAAG,SAANA,GAAM,CAASrb,KAAT,EAAgB;AACxB,gBAAI8qB,IAAI,GAAGh/B,IAAI,CAACg/B,IAAhB;;AACA,gBAAIA,IAAI,KAAKD,eAAb,EAA8B;AAE5BC,cAAAA,IAAI,GAAGh/B,IAAI,CAACg/B,IAAL,GAAY,EAAnB;AACD;;AACD,gBAAI9qB,KAAK,KAAK,IAAd,EAAoB;AAClB,qBAAO8qB,IAAI,CAAC2F,SAAD,CAAX;AACD,aAFD,MAEO;AACL3F,cAAAA,IAAI,CAAC2F,SAAD,CAAJ,GAAkBzwB,KAAlB;AACD;AACF,WAXD;;AAYAqb,UAAAA,GAAG,CAACqV,UAAJ,GAAiBD,SAAjB;AACA,iBAAOpV,GAAP;AACD,SA1CD,MA0CO;AACLn3B,UAAAA,SAAS,CACP,OAAOssC,QAAP,KAAoB,QADb,EAEP,4FAFO,CAAT;AAIAtsC,UAAAA,SAAS,CACPw4B,OAAO,CAACtV,MADD,EAEP,kGACE,2BADF,GAEE,wDAFF,GAGE,qGAHF,GAIE,+CAJF,GAKE,oEAPK,EAQPopB,QARO,CAAT;AAUD;AACF;;AACD,aAAOA,QAAP;AACD;;AAED,aAASG,wBAAT,CAAkCL,WAAlC,EAA+CM,QAA/C,EAAyD;AACvD,UAAIN,WAAW,CAACvkC,IAAZ,KAAqB,UAAzB,EAAqC;AACnC,YAAI8kC,QAAQ,GAAG,EAAf;AACA;AACEA,UAAAA,QAAQ,GACN,oEACA,UADA,GAEA9gB,yBAAyB,EAH3B;AAID;AACD7rB,QAAAA,SAAS,CACP,KADO,EAEP,uDAFO,EAGPmP,MAAM,CAAChO,SAAP,CAAiByrC,QAAjB,CAA0BvrC,IAA1B,CAA+BqrC,QAA/B,MAA6C,iBAA7C,GACI,uBAAuBv9B,MAAM,CAAC0pB,IAAP,CAAY6T,QAAZ,EAAsBjQ,IAAtB,CAA2B,IAA3B,CAAvB,GAA0D,GAD9D,GAEIiQ,QALG,EAMPC,QANO,CAAT;AAQD;AACF;;AAED,aAASE,kBAAT,GAA8B;AAC5B,UAAIZ,yBAAyB,GAC3B,kEACA,+DADA,GAEA,iEAFA,GAGApgB,yBAAyB,EAJ3B;;AAMA,UAAIggB,2BAA2B,CAACI,yBAAD,CAA/B,EAA4D;AAC1D;AACD;;AACDJ,MAAAA,2BAA2B,CAACI,yBAAD,CAA3B,GAAyD,IAAzD;AAEAnJ,MAAAA,SAAS,CACP,KADO,EAEP,kEACE,+DADF,GAEE,iEAJK,CAAT;AAMD;;AAMD,aAASgK,eAAT,CAAyBC,sBAAzB,EAAiD;AAC/C,eAASC,WAAT,CAAqBZ,WAArB,EAAkCa,aAAlC,EAAiD;AAC/C,YAAI,CAACF,sBAAL,EAA6B;AAE3B;AACD;;AAMD,YAAIG,IAAI,GAAGd,WAAW,CAAC1U,UAAvB;;AACA,YAAIwV,IAAI,KAAK,IAAb,EAAmB;AACjBA,UAAAA,IAAI,CAAC1V,UAAL,GAAkByV,aAAlB;AACAb,UAAAA,WAAW,CAAC1U,UAAZ,GAAyBuV,aAAzB;AACD,SAHD,MAGO;AACLb,UAAAA,WAAW,CAAC3U,WAAZ,GAA0B2U,WAAW,CAAC1U,UAAZ,GAAyBuV,aAAnD;AACD;;AACDA,QAAAA,aAAa,CAACzV,UAAd,GAA2B,IAA3B;AACAyV,QAAAA,aAAa,CAACttB,SAAd,GAA0BlB,QAA1B;AACD;;AAED,eAAS0uB,uBAAT,CAAiCf,WAAjC,EAA8CgB,iBAA9C,EAAiE;AAC/D,YAAI,CAACL,sBAAL,EAA6B;AAE3B,iBAAO,IAAP;AACD;;AAID,YAAIE,aAAa,GAAGG,iBAApB;;AACA,eAAOH,aAAa,KAAK,IAAzB,EAA+B;AAC7BD,UAAAA,WAAW,CAACZ,WAAD,EAAca,aAAd,CAAX;AACAA,UAAAA,aAAa,GAAGA,aAAa,CAACzsB,OAA9B;AACD;;AACD,eAAO,IAAP;AACD;;AAED,eAAS6sB,oBAAT,CAA8BjB,WAA9B,EAA2CgB,iBAA3C,EAA8D;AAG5D,YAAIE,gBAAgB,GAAG,IAAIzW,GAAJ,EAAvB;AAEA,YAAI0W,aAAa,GAAGH,iBAApB;;AACA,eAAOG,aAAa,KAAK,IAAzB,EAA+B;AAC7B,cAAIA,aAAa,CAAC3xB,GAAd,KAAsB,IAA1B,EAAgC;AAC9B0xB,YAAAA,gBAAgB,CAACx9B,GAAjB,CAAqBy9B,aAAa,CAAC3xB,GAAnC,EAAwC2xB,aAAxC;AACD,WAFD,MAEO;AACLD,YAAAA,gBAAgB,CAACx9B,GAAjB,CAAqBy9B,aAAa,CAAClzB,KAAnC,EAA0CkzB,aAA1C;AACD;;AACDA,UAAAA,aAAa,GAAGA,aAAa,CAAC/sB,OAA9B;AACD;;AACD,eAAO8sB,gBAAP;AACD;;AAED,eAASE,QAAT,CAAkB/tB,KAAlB,EAAyBwX,YAAzB,EAAuCjH,cAAvC,EAAuD;AAGrD,YAAIyd,KAAK,GAAGrV,oBAAoB,CAAC3Y,KAAD,EAAQwX,YAAR,EAAsBjH,cAAtB,CAAhC;AACAyd,QAAAA,KAAK,CAACpzB,KAAN,GAAc,CAAd;AACAozB,QAAAA,KAAK,CAACjtB,OAAN,GAAgB,IAAhB;AACA,eAAOitB,KAAP;AACD;;AAED,eAASC,UAAT,CAAoBC,QAApB,EAA8BC,eAA9B,EAA+CC,QAA/C,EAAyD;AACvDF,QAAAA,QAAQ,CAACtzB,KAAT,GAAiBwzB,QAAjB;;AACA,YAAI,CAACd,sBAAL,EAA6B;AAE3B,iBAAOa,eAAP;AACD;;AACD,YAAIvB,UAAU,GAAGsB,QAAQ,CAACphC,SAA1B;;AACA,YAAI8/B,UAAU,KAAK,IAAnB,EAAyB;AACvB,cAAIyB,QAAQ,GAAGzB,UAAU,CAAChyB,KAA1B;;AACA,cAAIyzB,QAAQ,GAAGF,eAAf,EAAgC;AAE9BD,YAAAA,QAAQ,CAAChuB,SAAT,GAAqBrB,SAArB;AACA,mBAAOsvB,eAAP;AACD,WAJD,MAIO;AAEL,mBAAOE,QAAP;AACD;AACF,SAVD,MAUO;AAELH,UAAAA,QAAQ,CAAChuB,SAAT,GAAqBrB,SAArB;AACA,iBAAOsvB,eAAP;AACD;AACF;;AAED,eAASG,gBAAT,CAA0BJ,QAA1B,EAAoC;AAGlC,YAAIZ,sBAAsB,IAAIY,QAAQ,CAACphC,SAAT,KAAuB,IAArD,EAA2D;AACzDohC,UAAAA,QAAQ,CAAChuB,SAAT,GAAqBrB,SAArB;AACD;;AACD,eAAOqvB,QAAP;AACD;;AAED,eAASK,cAAT,CACE5B,WADF,EAEEC,UAFF,EAGE4B,WAHF,EAIEje,cAJF,EAKE;AACA,YAAIqc,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAAC1iC,GAAX,KAAmByB,QAA9C,EAAwD;AAEtD,cAAI8iC,OAAO,GAAGhV,mBAAmB,CAC/B+U,WAD+B,EAE/B7B,WAAW,CAAClV,IAFmB,EAG/BlH,cAH+B,CAAjC;AAKAke,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD,SATD,MASO;AAEL,cAAIC,QAAQ,GAAGX,QAAQ,CAACnB,UAAD,EAAa4B,WAAb,EAA0Bje,cAA1B,CAAvB;AACAme,UAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA,iBAAO+B,QAAP;AACD;AACF;;AAED,eAASC,aAAT,CAAuBhC,WAAvB,EAAoCC,UAApC,EAAgD7T,OAAhD,EAAyDxI,cAAzD,EAAyE;AACvE,YAAIqc,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAACxkC,IAAX,KAAoB2wB,OAAO,CAAC3wB,IAAvD,EAA6D;AAE3D,cAAIsmC,QAAQ,GAAGX,QAAQ,CAACnB,UAAD,EAAa7T,OAAO,CAAC3uB,KAArB,EAA4BmmB,cAA5B,CAAvB;AACAme,UAAAA,QAAQ,CAAChX,GAAT,GAAegV,SAAS,CAACC,WAAD,EAAcC,UAAd,EAA0B7T,OAA1B,CAAxB;AACA2V,UAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA;AACE+B,YAAAA,QAAQ,CAAC3iB,YAAT,GAAwBgN,OAAO,CAACM,OAAhC;AACAqV,YAAAA,QAAQ,CAAC5iB,WAAT,GAAuBiN,OAAO,CAACtV,MAA/B;AACD;AACD,iBAAOirB,QAAP;AACD,SAVD,MAUO;AAEL,cAAID,OAAO,GAAG3V,sBAAsB,CAClCC,OADkC,EAElC4T,WAAW,CAAClV,IAFsB,EAGlClH,cAHkC,CAApC;AAKAke,UAAAA,OAAO,CAAC/W,GAAR,GAAcgV,SAAS,CAACC,WAAD,EAAcC,UAAd,EAA0B7T,OAA1B,CAAvB;AACA0V,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD;AACF;;AAED,eAASG,YAAT,CAAsBjC,WAAtB,EAAmCC,UAAnC,EAA+C/S,MAA/C,EAAuDtJ,cAAvD,EAAuE;AACrE,YACEqc,UAAU,KAAK,IAAf,IACAA,UAAU,CAAC1iC,GAAX,KAAmBuB,UADnB,IAEAmhC,UAAU,CAACpiC,SAAX,CAAqBue,aAArB,KAAuC8Q,MAAM,CAAC9Q,aAF9C,IAGA6jB,UAAU,CAACpiC,SAAX,CAAqBuvB,cAArB,KAAwCF,MAAM,CAACE,cAJjD,EAKE;AAEA,cAAI0U,OAAO,GAAG7U,qBAAqB,CACjCC,MADiC,EAEjC8S,WAAW,CAAClV,IAFqB,EAGjClH,cAHiC,CAAnC;AAKAke,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD,SAdD,MAcO;AAEL,cAAIC,QAAQ,GAAGX,QAAQ,CACrBnB,UADqB,EAErB/S,MAAM,CAAC9P,QAAP,IAAmB,EAFE,EAGrBwG,cAHqB,CAAvB;AAKAme,UAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA,iBAAO+B,QAAP;AACD;AACF;;AAED,eAASG,cAAT,CACElC,WADF,EAEEC,UAFF,EAGEkC,QAHF,EAIEve,cAJF,EAKEpU,GALF,EAME;AACA,YAAIywB,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAAC1iC,GAAX,KAAmB0B,QAA9C,EAAwD;AAEtD,cAAI6iC,OAAO,GAAGvV,uBAAuB,CACnC4V,QADmC,EAEnCnC,WAAW,CAAClV,IAFuB,EAGnClH,cAHmC,EAInCpU,GAJmC,CAArC;AAMAsyB,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD,SAVD,MAUO;AAEL,cAAIC,QAAQ,GAAGX,QAAQ,CAACnB,UAAD,EAAakC,QAAb,EAAuBve,cAAvB,CAAvB;AACAme,UAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA,iBAAO+B,QAAP;AACD;AACF;;AAED,eAASK,WAAT,CAAqBpC,WAArB,EAAkCM,QAAlC,EAA4C1c,cAA5C,EAA4D;AAC1D,YAAI,OAAO0c,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAIhE,cAAIwB,OAAO,GAAGhV,mBAAmB,CAC/B,KAAKwT,QAD0B,EAE/BN,WAAW,CAAClV,IAFmB,EAG/BlH,cAH+B,CAAjC;AAKAke,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD;;AAED,YAAI,OAAOxB,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,kBAAQA,QAAQ,CAAC5uB,QAAjB;AACE,iBAAK1B,kBAAL;AAAyB;AACvB,oBAAIqyB,QAAQ,GAAGlW,sBAAsB,CACnCmU,QADmC,EAEnCN,WAAW,CAAClV,IAFuB,EAGnClH,cAHmC,CAArC;;AAKAye,gBAAAA,QAAQ,CAACtX,GAAT,GAAegV,SAAS,CAACC,WAAD,EAAc,IAAd,EAAoBM,QAApB,CAAxB;AACA+B,gBAAAA,QAAQ,CAAC3iC,MAAT,GAAkBsgC,WAAlB;AACA,uBAAOqC,QAAP;AACD;;AACD,iBAAKpyB,iBAAL;AAAwB;AACtB,oBAAIqyB,SAAS,GAAGrV,qBAAqB,CACnCqT,QADmC,EAEnCN,WAAW,CAAClV,IAFuB,EAGnClH,cAHmC,CAArC;;AAKA0e,gBAAAA,SAAS,CAAC5iC,MAAV,GAAmBsgC,WAAnB;AACA,uBAAOsC,SAAP;AACD;AAnBH;;AAsBA,cAAIxC,SAAS,CAACQ,QAAD,CAAT,IAAuBzvB,aAAa,CAACyvB,QAAD,CAAxC,EAAoD;AAClD,gBAAIiC,SAAS,GAAGhW,uBAAuB,CACrC+T,QADqC,EAErCN,WAAW,CAAClV,IAFyB,EAGrClH,cAHqC,EAIrC,IAJqC,CAAvC;;AAMA2e,YAAAA,SAAS,CAAC7iC,MAAV,GAAmBsgC,WAAnB;AACA,mBAAOuC,SAAP;AACD;;AAEDlC,UAAAA,wBAAwB,CAACL,WAAD,EAAcM,QAAd,CAAxB;AACD;;AAED;AACE,cAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClCG,YAAAA,kBAAkB;AACnB;AACF;AAED,eAAO,IAAP;AACD;;AAED,eAAS+B,UAAT,CAAoBxC,WAApB,EAAiCyC,QAAjC,EAA2CnC,QAA3C,EAAqD1c,cAArD,EAAqE;AAGnE,YAAIpU,GAAG,GAAGizB,QAAQ,KAAK,IAAb,GAAoBA,QAAQ,CAACjzB,GAA7B,GAAmC,IAA7C;;AAEA,YAAI,OAAO8wB,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAIhE,cAAI9wB,GAAG,KAAK,IAAZ,EAAkB;AAChB,mBAAO,IAAP;AACD;;AACD,iBAAOoyB,cAAc,CACnB5B,WADmB,EAEnByC,QAFmB,EAGnB,KAAKnC,QAHc,EAInB1c,cAJmB,CAArB;AAMD;;AAED,YAAI,OAAO0c,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,kBAAQA,QAAQ,CAAC5uB,QAAjB;AACE,iBAAK1B,kBAAL;AAAyB;AACvB,oBAAIswB,QAAQ,CAAC9wB,GAAT,KAAiBA,GAArB,EAA0B;AACxB,sBAAI8wB,QAAQ,CAAC7kC,IAAT,KAAkByU,mBAAtB,EAA2C;AACzC,2BAAOgyB,cAAc,CACnBlC,WADmB,EAEnByC,QAFmB,EAGnBnC,QAAQ,CAAC7iC,KAAT,CAAe2f,QAHI,EAInBwG,cAJmB,EAKnBpU,GALmB,CAArB;AAOD;;AACD,yBAAOwyB,aAAa,CAClBhC,WADkB,EAElByC,QAFkB,EAGlBnC,QAHkB,EAIlB1c,cAJkB,CAApB;AAMD,iBAhBD,MAgBO;AACL,yBAAO,IAAP;AACD;AACF;;AACD,iBAAK3T,iBAAL;AAAwB;AACtB,oBAAIqwB,QAAQ,CAAC9wB,GAAT,KAAiBA,GAArB,EAA0B;AACxB,yBAAOyyB,YAAY,CACjBjC,WADiB,EAEjByC,QAFiB,EAGjBnC,QAHiB,EAIjB1c,cAJiB,CAAnB;AAMD,iBAPD,MAOO;AACL,yBAAO,IAAP;AACD;AACF;AAjCH;;AAoCA,cAAIkc,SAAS,CAACQ,QAAD,CAAT,IAAuBzvB,aAAa,CAACyvB,QAAD,CAAxC,EAAoD;AAClD,gBAAI9wB,GAAG,KAAK,IAAZ,EAAkB;AAChB,qBAAO,IAAP;AACD;;AAED,mBAAO0yB,cAAc,CACnBlC,WADmB,EAEnByC,QAFmB,EAGnBnC,QAHmB,EAInB1c,cAJmB,EAKnB,IALmB,CAArB;AAOD;;AAEDyc,UAAAA,wBAAwB,CAACL,WAAD,EAAcM,QAAd,CAAxB;AACD;;AAED;AACE,cAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClCG,YAAAA,kBAAkB;AACnB;AACF;AAED,eAAO,IAAP;AACD;;AAED,eAASiC,aAAT,CACExB,gBADF,EAEElB,WAFF,EAGE2C,MAHF,EAIErC,QAJF,EAKE1c,cALF,EAME;AACA,YAAI,OAAO0c,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAGhE,cAAIsC,YAAY,GAAG1B,gBAAgB,CAACv9B,GAAjB,CAAqBg/B,MAArB,KAAgC,IAAnD;AACA,iBAAOf,cAAc,CACnB5B,WADmB,EAEnB4C,YAFmB,EAGnB,KAAKtC,QAHc,EAInB1c,cAJmB,CAArB;AAMD;;AAED,YAAI,OAAO0c,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,kBAAQA,QAAQ,CAAC5uB,QAAjB;AACE,iBAAK1B,kBAAL;AAAyB;AACvB,oBAAI6yB,aAAa,GACf3B,gBAAgB,CAACv9B,GAAjB,CACE28B,QAAQ,CAAC9wB,GAAT,KAAiB,IAAjB,GAAwBmzB,MAAxB,GAAiCrC,QAAQ,CAAC9wB,GAD5C,KAEK,IAHP;;AAIA,oBAAI8wB,QAAQ,CAAC7kC,IAAT,KAAkByU,mBAAtB,EAA2C;AACzC,yBAAOgyB,cAAc,CACnBlC,WADmB,EAEnB6C,aAFmB,EAGnBvC,QAAQ,CAAC7iC,KAAT,CAAe2f,QAHI,EAInBwG,cAJmB,EAKnB0c,QAAQ,CAAC9wB,GALU,CAArB;AAOD;;AACD,uBAAOwyB,aAAa,CAClBhC,WADkB,EAElB6C,aAFkB,EAGlBvC,QAHkB,EAIlB1c,cAJkB,CAApB;AAMD;;AACD,iBAAK3T,iBAAL;AAAwB;AACtB,oBAAI6yB,cAAc,GAChB5B,gBAAgB,CAACv9B,GAAjB,CACE28B,QAAQ,CAAC9wB,GAAT,KAAiB,IAAjB,GAAwBmzB,MAAxB,GAAiCrC,QAAQ,CAAC9wB,GAD5C,KAEK,IAHP;;AAIA,uBAAOyyB,YAAY,CACjBjC,WADiB,EAEjB8C,cAFiB,EAGjBxC,QAHiB,EAIjB1c,cAJiB,CAAnB;AAMD;AAjCH;;AAoCA,cAAIkc,SAAS,CAACQ,QAAD,CAAT,IAAuBzvB,aAAa,CAACyvB,QAAD,CAAxC,EAAoD;AAClD,gBAAIyC,cAAc,GAAG7B,gBAAgB,CAACv9B,GAAjB,CAAqBg/B,MAArB,KAAgC,IAArD;;AACA,mBAAOT,cAAc,CACnBlC,WADmB,EAEnB+C,cAFmB,EAGnBzC,QAHmB,EAInB1c,cAJmB,EAKnB,IALmB,CAArB;AAOD;;AAEDyc,UAAAA,wBAAwB,CAACL,WAAD,EAAcM,QAAd,CAAxB;AACD;;AAED;AACE,cAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClCG,YAAAA,kBAAkB;AACnB;AACF;AAED,eAAO,IAAP;AACD;;AAKD,eAASuC,gBAAT,CAA0B7uB,KAA1B,EAAiC8uB,SAAjC,EAA4C;AAC1C;AACE,cAAI,OAAO9uB,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,mBAAO8uB,SAAP;AACD;;AACD,kBAAQ9uB,KAAK,CAACzC,QAAd;AACE,iBAAK1B,kBAAL;AACA,iBAAKC,iBAAL;AACEyvB,cAAAA,iBAAiB,CAACvrB,KAAD,CAAjB;AACA,kBAAI3E,GAAG,GAAG2E,KAAK,CAAC3E,GAAhB;;AACA,kBAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AACD,kBAAIyzB,SAAS,KAAK,IAAlB,EAAwB;AACtBA,gBAAAA,SAAS,GAAG,IAAIxhB,GAAJ,EAAZ;AACAwhB,gBAAAA,SAAS,CAACngB,GAAV,CAActT,GAAd;AACA;AACD;;AACD,kBAAI,CAACyzB,SAAS,CAACpgB,GAAV,CAAcrT,GAAd,CAAL,EAAyB;AACvByzB,gBAAAA,SAAS,CAACngB,GAAV,CAActT,GAAd;AACA;AACD;;AACDknB,cAAAA,SAAS,CACP,KADO,EAEP,uDACE,mEADF,GAEE,2DAFF,GAGE,8DAHF,GAIE,mCANK,EAOPlnB,GAPO,CAAT;AASA;;AACF;AACE;AA5BJ;AA8BD;AACD,eAAOyzB,SAAP;AACD;;AAED,eAASC,sBAAT,CACElD,WADF,EAEEgB,iBAFF,EAGEmC,WAHF,EAIEvf,cAJF,EAKE;AAoBA;AAEE,cAAIqf,SAAS,GAAG,IAAhB;;AACA,eAAK,IAAIrnC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGunC,WAAW,CAAC1pC,MAAhC,EAAwCmC,CAAC,EAAzC,EAA6C;AAC3C,gBAAIuY,KAAK,GAAGgvB,WAAW,CAACvnC,CAAD,CAAvB;AACAqnC,YAAAA,SAAS,GAAGD,gBAAgB,CAAC7uB,KAAD,EAAQ8uB,SAAR,CAA5B;AACD;AACF;AAED,YAAIG,mBAAmB,GAAG,IAA1B;AACA,YAAIC,gBAAgB,GAAG,IAAvB;AAEA,YAAIZ,QAAQ,GAAGzB,iBAAf;AACA,YAAIQ,eAAe,GAAG,CAAtB;AACA,YAAImB,MAAM,GAAG,CAAb;AACA,YAAIW,YAAY,GAAG,IAAnB;;AACA,eAAOb,QAAQ,KAAK,IAAb,IAAqBE,MAAM,GAAGQ,WAAW,CAAC1pC,MAAjD,EAAyDkpC,MAAM,EAA/D,EAAmE;AACjE,cAAIF,QAAQ,CAACx0B,KAAT,GAAiB00B,MAArB,EAA6B;AAC3BW,YAAAA,YAAY,GAAGb,QAAf;AACAA,YAAAA,QAAQ,GAAG,IAAX;AACD,WAHD,MAGO;AACLa,YAAAA,YAAY,GAAGb,QAAQ,CAACruB,OAAxB;AACD;;AACD,cAAImtB,QAAQ,GAAGiB,UAAU,CACvBxC,WADuB,EAEvByC,QAFuB,EAGvBU,WAAW,CAACR,MAAD,CAHY,EAIvB/e,cAJuB,CAAzB;;AAMA,cAAI2d,QAAQ,KAAK,IAAjB,EAAuB;AAKrB,gBAAIkB,QAAQ,KAAK,IAAjB,EAAuB;AACrBA,cAAAA,QAAQ,GAAGa,YAAX;AACD;;AACD;AACD;;AACD,cAAI3C,sBAAJ,EAA4B;AAC1B,gBAAI8B,QAAQ,IAAIlB,QAAQ,CAACphC,SAAT,KAAuB,IAAvC,EAA6C;AAG3CygC,cAAAA,WAAW,CAACZ,WAAD,EAAcyC,QAAd,CAAX;AACD;AACF;;AACDjB,UAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4BmB,MAA5B,CAA5B;;AACA,cAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAE7BD,YAAAA,mBAAmB,GAAG7B,QAAtB;AACD,WAHD,MAGO;AAKL8B,YAAAA,gBAAgB,CAACjvB,OAAjB,GAA2BmtB,QAA3B;AACD;;AACD8B,UAAAA,gBAAgB,GAAG9B,QAAnB;AACAkB,UAAAA,QAAQ,GAAGa,YAAX;AACD;;AAED,YAAIX,MAAM,KAAKQ,WAAW,CAAC1pC,MAA3B,EAAmC;AAEjCsnC,UAAAA,uBAAuB,CAACf,WAAD,EAAcyC,QAAd,CAAvB;AACA,iBAAOW,mBAAP;AACD;;AAED,YAAIX,QAAQ,KAAK,IAAjB,EAAuB;AAGrB,iBAAOE,MAAM,GAAGQ,WAAW,CAAC1pC,MAA5B,EAAoCkpC,MAAM,EAA1C,EAA8C;AAC5C,gBAAIY,SAAS,GAAGnB,WAAW,CACzBpC,WADyB,EAEzBmD,WAAW,CAACR,MAAD,CAFc,EAGzB/e,cAHyB,CAA3B;;AAKA,gBAAI,CAAC2f,SAAL,EAAgB;AACd;AACD;;AACD/B,YAAAA,eAAe,GAAGF,UAAU,CAACiC,SAAD,EAAY/B,eAAZ,EAA6BmB,MAA7B,CAA5B;;AACA,gBAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAE7BD,cAAAA,mBAAmB,GAAGG,SAAtB;AACD,aAHD,MAGO;AACLF,cAAAA,gBAAgB,CAACjvB,OAAjB,GAA2BmvB,SAA3B;AACD;;AACDF,YAAAA,gBAAgB,GAAGE,SAAnB;AACD;;AACD,iBAAOH,mBAAP;AACD;;AAGD,YAAIlC,gBAAgB,GAAGD,oBAAoB,CAACjB,WAAD,EAAcyC,QAAd,CAA3C;;AAGA,eAAOE,MAAM,GAAGQ,WAAW,CAAC1pC,MAA5B,EAAoCkpC,MAAM,EAA1C,EAA8C;AAC5C,cAAIa,UAAU,GAAGd,aAAa,CAC5BxB,gBAD4B,EAE5BlB,WAF4B,EAG5B2C,MAH4B,EAI5BQ,WAAW,CAACR,MAAD,CAJiB,EAK5B/e,cAL4B,CAA9B;;AAOA,cAAI4f,UAAJ,EAAgB;AACd,gBAAI7C,sBAAJ,EAA4B;AAC1B,kBAAI6C,UAAU,CAACrjC,SAAX,KAAyB,IAA7B,EAAmC;AAKjC+gC,gBAAAA,gBAAgB,CAACuC,MAAjB,CACED,UAAU,CAACh0B,GAAX,KAAmB,IAAnB,GAA0BmzB,MAA1B,GAAmCa,UAAU,CAACh0B,GADhD;AAGD;AACF;;AACDgyB,YAAAA,eAAe,GAAGF,UAAU,CAACkC,UAAD,EAAahC,eAAb,EAA8BmB,MAA9B,CAA5B;;AACA,gBAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BD,cAAAA,mBAAmB,GAAGI,UAAtB;AACD,aAFD,MAEO;AACLH,cAAAA,gBAAgB,CAACjvB,OAAjB,GAA2BovB,UAA3B;AACD;;AACDH,YAAAA,gBAAgB,GAAGG,UAAnB;AACD;AACF;;AAED,YAAI7C,sBAAJ,EAA4B;AAG1BO,UAAAA,gBAAgB,CAACpkC,OAAjB,CAAyB,UAASqX,KAAT,EAAgB;AACvC,mBAAOysB,WAAW,CAACZ,WAAD,EAAc7rB,KAAd,CAAlB;AACD,WAFD;AAGD;;AAED,eAAOivB,mBAAP;AACD;;AAED,eAASM,yBAAT,CACE1D,WADF,EAEEgB,iBAFF,EAGE2C,mBAHF,EAIE/f,cAJF,EAKE;AAIA,YAAIggB,UAAU,GAAG/yB,aAAa,CAAC8yB,mBAAD,CAA9B;AACA/vC,QAAAA,SAAS,CACP,OAAOgwC,UAAP,KAAsB,UADf,EAEP,2EACE,8BAHK,CAAT;AAMA;AAGE,cACE,OAAO9zB,MAAP,KAAkB,UAAlB,IAEA6zB,mBAAmB,CAAC7zB,MAAM,CAAC+zB,WAAR,CAAnB,KAA4C,WAH9C,EAIE;AACA,aAACvE,sBAAD,GACI5I,SAAS,CACP,KADO,EAEP,uEACE,iEADF,GAEE,4DAFF,GAGE,wDAHF,GAIE,+DANK,CADb,GASI,KAAK,CATT;AAUA4I,YAAAA,sBAAsB,GAAG,IAAzB;AACD;;AAGD,cAAIqE,mBAAmB,CAACG,OAApB,KAAgCF,UAApC,EAAgD;AAC9C,aAACvE,gBAAD,GACI3I,SAAS,CACP,KADO,EAEP,iEACE,iEADF,GAEE,wBAJK,CADb,GAOI,KAAK,CAPT;AAQA2I,YAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAID,cAAI0E,YAAY,GAAGH,UAAU,CAAC3uC,IAAX,CAAgB0uC,mBAAhB,CAAnB;;AACA,cAAII,YAAJ,EAAkB;AAChB,gBAAId,SAAS,GAAG,IAAhB;;AACA,gBAAIe,KAAK,GAAGD,YAAY,CAACvnC,IAAb,EAAZ;;AACA,mBAAO,CAACwnC,KAAK,CAACC,IAAd,EAAoBD,KAAK,GAAGD,YAAY,CAACvnC,IAAb,EAA5B,EAAiD;AAC/C,kBAAI2X,KAAK,GAAG6vB,KAAK,CAACt0B,KAAlB;AACAuzB,cAAAA,SAAS,GAAGD,gBAAgB,CAAC7uB,KAAD,EAAQ8uB,SAAR,CAA5B;AACD;AACF;AACF;AAED,YAAIE,WAAW,GAAGS,UAAU,CAAC3uC,IAAX,CAAgB0uC,mBAAhB,CAAlB;AACA/vC,QAAAA,SAAS,CAACuvC,WAAW,IAAI,IAAhB,EAAsB,0CAAtB,CAAT;AAEA,YAAIC,mBAAmB,GAAG,IAA1B;AACA,YAAIC,gBAAgB,GAAG,IAAvB;AAEA,YAAIZ,QAAQ,GAAGzB,iBAAf;AACA,YAAIQ,eAAe,GAAG,CAAtB;AACA,YAAImB,MAAM,GAAG,CAAb;AACA,YAAIW,YAAY,GAAG,IAAnB;AAEA,YAAIY,IAAI,GAAGf,WAAW,CAAC3mC,IAAZ,EAAX;;AACA,eAEEimC,QAAQ,KAAK,IAAb,IAAqB,CAACyB,IAAI,CAACD,IAF7B,EAGEtB,MAAM,IAAIuB,IAAI,GAAGf,WAAW,CAAC3mC,IAAZ,EAHnB,EAIE;AACA,cAAIimC,QAAQ,CAACx0B,KAAT,GAAiB00B,MAArB,EAA6B;AAC3BW,YAAAA,YAAY,GAAGb,QAAf;AACAA,YAAAA,QAAQ,GAAG,IAAX;AACD,WAHD,MAGO;AACLa,YAAAA,YAAY,GAAGb,QAAQ,CAACruB,OAAxB;AACD;;AACD,cAAImtB,QAAQ,GAAGiB,UAAU,CACvBxC,WADuB,EAEvByC,QAFuB,EAGvByB,IAAI,CAACx0B,KAHkB,EAIvBkU,cAJuB,CAAzB;;AAMA,cAAI2d,QAAQ,KAAK,IAAjB,EAAuB;AAKrB,gBAAI,CAACkB,QAAL,EAAe;AACbA,cAAAA,QAAQ,GAAGa,YAAX;AACD;;AACD;AACD;;AACD,cAAI3C,sBAAJ,EAA4B;AAC1B,gBAAI8B,QAAQ,IAAIlB,QAAQ,CAACphC,SAAT,KAAuB,IAAvC,EAA6C;AAG3CygC,cAAAA,WAAW,CAACZ,WAAD,EAAcyC,QAAd,CAAX;AACD;AACF;;AACDjB,UAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4BmB,MAA5B,CAA5B;;AACA,cAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAE7BD,YAAAA,mBAAmB,GAAG7B,QAAtB;AACD,WAHD,MAGO;AAKL8B,YAAAA,gBAAgB,CAACjvB,OAAjB,GAA2BmtB,QAA3B;AACD;;AACD8B,UAAAA,gBAAgB,GAAG9B,QAAnB;AACAkB,UAAAA,QAAQ,GAAGa,YAAX;AACD;;AAED,YAAIY,IAAI,CAACD,IAAT,EAAe;AAEblD,UAAAA,uBAAuB,CAACf,WAAD,EAAcyC,QAAd,CAAvB;AACA,iBAAOW,mBAAP;AACD;;AAED,YAAIX,QAAQ,KAAK,IAAjB,EAAuB;AAGrB,iBAAO,CAACyB,IAAI,CAACD,IAAb,EAAmBtB,MAAM,IAAIuB,IAAI,GAAGf,WAAW,CAAC3mC,IAAZ,EAApC,EAAwD;AACtD,gBAAI2nC,UAAU,GAAG/B,WAAW,CAACpC,WAAD,EAAckE,IAAI,CAACx0B,KAAnB,EAA0BkU,cAA1B,CAA5B;;AACA,gBAAIugB,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACD;;AACD3C,YAAAA,eAAe,GAAGF,UAAU,CAAC6C,UAAD,EAAa3C,eAAb,EAA8BmB,MAA9B,CAA5B;;AACA,gBAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAE7BD,cAAAA,mBAAmB,GAAGe,UAAtB;AACD,aAHD,MAGO;AACLd,cAAAA,gBAAgB,CAACjvB,OAAjB,GAA2B+vB,UAA3B;AACD;;AACDd,YAAAA,gBAAgB,GAAGc,UAAnB;AACD;;AACD,iBAAOf,mBAAP;AACD;;AAGD,YAAIlC,gBAAgB,GAAGD,oBAAoB,CAACjB,WAAD,EAAcyC,QAAd,CAA3C;;AAGA,eAAO,CAACyB,IAAI,CAACD,IAAb,EAAmBtB,MAAM,IAAIuB,IAAI,GAAGf,WAAW,CAAC3mC,IAAZ,EAApC,EAAwD;AACtD,cAAI4nC,UAAU,GAAG1B,aAAa,CAC5BxB,gBAD4B,EAE5BlB,WAF4B,EAG5B2C,MAH4B,EAI5BuB,IAAI,CAACx0B,KAJuB,EAK5BkU,cAL4B,CAA9B;;AAOA,cAAIwgB,UAAU,KAAK,IAAnB,EAAyB;AACvB,gBAAIzD,sBAAJ,EAA4B;AAC1B,kBAAIyD,UAAU,CAACjkC,SAAX,KAAyB,IAA7B,EAAmC;AAKjC+gC,gBAAAA,gBAAgB,CAACuC,MAAjB,CACEW,UAAU,CAAC50B,GAAX,KAAmB,IAAnB,GAA0BmzB,MAA1B,GAAmCyB,UAAU,CAAC50B,GADhD;AAGD;AACF;;AACDgyB,YAAAA,eAAe,GAAGF,UAAU,CAAC8C,UAAD,EAAa5C,eAAb,EAA8BmB,MAA9B,CAA5B;;AACA,gBAAIU,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BD,cAAAA,mBAAmB,GAAGgB,UAAtB;AACD,aAFD,MAEO;AACLf,cAAAA,gBAAgB,CAACjvB,OAAjB,GAA2BgwB,UAA3B;AACD;;AACDf,YAAAA,gBAAgB,GAAGe,UAAnB;AACD;AACF;;AAED,YAAIzD,sBAAJ,EAA4B;AAG1BO,UAAAA,gBAAgB,CAACpkC,OAAjB,CAAyB,UAASqX,KAAT,EAAgB;AACvC,mBAAOysB,WAAW,CAACZ,WAAD,EAAc7rB,KAAd,CAAlB;AACD,WAFD;AAGD;;AAED,eAAOivB,mBAAP;AACD;;AAED,eAASiB,uBAAT,CACErE,WADF,EAEEgB,iBAFF,EAGEa,WAHF,EAIEje,cAJF,EAKE;AAGA,YAAIod,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACzjC,GAAlB,KAA0ByB,QAA5D,EAAsE;AAGpE+hC,UAAAA,uBAAuB,CAACf,WAAD,EAAcgB,iBAAiB,CAAC5sB,OAAhC,CAAvB;AACA,cAAI2tB,QAAQ,GAAGX,QAAQ,CAACJ,iBAAD,EAAoBa,WAApB,EAAiCje,cAAjC,CAAvB;AACAme,UAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA,iBAAO+B,QAAP;AACD;;AAGDhB,QAAAA,uBAAuB,CAACf,WAAD,EAAcgB,iBAAd,CAAvB;AACA,YAAIc,OAAO,GAAGhV,mBAAmB,CAC/B+U,WAD+B,EAE/B7B,WAAW,CAAClV,IAFmB,EAG/BlH,cAH+B,CAAjC;AAKAke,QAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,eAAO8B,OAAP;AACD;;AAED,eAASwC,sBAAT,CACEtE,WADF,EAEEgB,iBAFF,EAGE5U,OAHF,EAIExI,cAJF,EAKE;AACA,YAAIpU,GAAG,GAAG4c,OAAO,CAAC5c,GAAlB;AACA,YAAI2E,KAAK,GAAG6sB,iBAAZ;;AACA,eAAO7sB,KAAK,KAAK,IAAjB,EAAuB;AAGrB,cAAIA,KAAK,CAAC3E,GAAN,KAAcA,GAAlB,EAAuB;AACrB,gBACE2E,KAAK,CAAC5W,GAAN,KAAc0B,QAAd,GACImtB,OAAO,CAAC3wB,IAAR,KAAiByU,mBADrB,GAEIiE,KAAK,CAAC1Y,IAAN,KAAe2wB,OAAO,CAAC3wB,IAH7B,EAIE;AACAslC,cAAAA,uBAAuB,CAACf,WAAD,EAAc7rB,KAAK,CAACC,OAApB,CAAvB;AACA,kBAAI2tB,QAAQ,GAAGX,QAAQ,CACrBjtB,KADqB,EAErBiY,OAAO,CAAC3wB,IAAR,KAAiByU,mBAAjB,GACIkc,OAAO,CAAC3uB,KAAR,CAAc2f,QADlB,GAEIgP,OAAO,CAAC3uB,KAJS,EAKrBmmB,cALqB,CAAvB;AAOAme,cAAAA,QAAQ,CAAChX,GAAT,GAAegV,SAAS,CAACC,WAAD,EAAc7rB,KAAd,EAAqBiY,OAArB,CAAxB;AACA2V,cAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA;AACE+B,gBAAAA,QAAQ,CAAC3iB,YAAT,GAAwBgN,OAAO,CAACM,OAAhC;AACAqV,gBAAAA,QAAQ,CAAC5iB,WAAT,GAAuBiN,OAAO,CAACtV,MAA/B;AACD;AACD,qBAAOirB,QAAP;AACD,aApBD,MAoBO;AACLhB,cAAAA,uBAAuB,CAACf,WAAD,EAAc7rB,KAAd,CAAvB;AACA;AACD;AACF,WAzBD,MAyBO;AACLysB,YAAAA,WAAW,CAACZ,WAAD,EAAc7rB,KAAd,CAAX;AACD;;AACDA,UAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AAED,YAAIgY,OAAO,CAAC3wB,IAAR,KAAiByU,mBAArB,EAA0C;AACxC,cAAI4xB,OAAO,GAAGvV,uBAAuB,CACnCH,OAAO,CAAC3uB,KAAR,CAAc2f,QADqB,EAEnC4iB,WAAW,CAAClV,IAFuB,EAGnClH,cAHmC,EAInCwI,OAAO,CAAC5c,GAJ2B,CAArC;AAMAsyB,UAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,iBAAO8B,OAAP;AACD,SATD,MASO;AACL,cAAIyC,SAAS,GAAGpY,sBAAsB,CACpCC,OADoC,EAEpC4T,WAAW,CAAClV,IAFwB,EAGpClH,cAHoC,CAAtC;;AAKA2gB,UAAAA,SAAS,CAACxZ,GAAV,GAAgBgV,SAAS,CAACC,WAAD,EAAcgB,iBAAd,EAAiC5U,OAAjC,CAAzB;AACAmY,UAAAA,SAAS,CAAC7kC,MAAV,GAAmBsgC,WAAnB;AACA,iBAAOuE,SAAP;AACD;AACF;;AAED,eAASC,qBAAT,CACExE,WADF,EAEEgB,iBAFF,EAGE9T,MAHF,EAIEtJ,cAJF,EAKE;AACA,YAAIpU,GAAG,GAAG0d,MAAM,CAAC1d,GAAjB;AACA,YAAI2E,KAAK,GAAG6sB,iBAAZ;;AACA,eAAO7sB,KAAK,KAAK,IAAjB,EAAuB;AAGrB,cAAIA,KAAK,CAAC3E,GAAN,KAAcA,GAAlB,EAAuB;AACrB,gBACE2E,KAAK,CAAC5W,GAAN,KAAcuB,UAAd,IACAqV,KAAK,CAACtW,SAAN,CAAgBue,aAAhB,KAAkC8Q,MAAM,CAAC9Q,aADzC,IAEAjI,KAAK,CAACtW,SAAN,CAAgBuvB,cAAhB,KAAmCF,MAAM,CAACE,cAH5C,EAIE;AACA2T,cAAAA,uBAAuB,CAACf,WAAD,EAAc7rB,KAAK,CAACC,OAApB,CAAvB;AACA,kBAAI2tB,QAAQ,GAAGX,QAAQ,CAACjtB,KAAD,EAAQ+Y,MAAM,CAAC9P,QAAP,IAAmB,EAA3B,EAA+BwG,cAA/B,CAAvB;AACAme,cAAAA,QAAQ,CAACriC,MAAT,GAAkBsgC,WAAlB;AACA,qBAAO+B,QAAP;AACD,aATD,MASO;AACLhB,cAAAA,uBAAuB,CAACf,WAAD,EAAc7rB,KAAd,CAAvB;AACA;AACD;AACF,WAdD,MAcO;AACLysB,YAAAA,WAAW,CAACZ,WAAD,EAAc7rB,KAAd,CAAX;AACD;;AACDA,UAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AAED,YAAI0tB,OAAO,GAAG7U,qBAAqB,CACjCC,MADiC,EAEjC8S,WAAW,CAAClV,IAFqB,EAGjClH,cAHiC,CAAnC;AAKAke,QAAAA,OAAO,CAACpiC,MAAR,GAAiBsgC,WAAjB;AACA,eAAO8B,OAAP;AACD;;AAKD,eAAS2C,oBAAT,CACEzE,WADF,EAEEgB,iBAFF,EAGEV,QAHF,EAIE1c,cAJF,EAKE;AASA,YAAI8gB,yBAAyB,GAC3B,OAAOpE,QAAP,KAAoB,QAApB,IACAA,QAAQ,KAAK,IADb,IAEAA,QAAQ,CAAC7kC,IAAT,KAAkByU,mBAFlB,IAGAowB,QAAQ,CAAC9wB,GAAT,KAAiB,IAJnB;;AAKA,YAAIk1B,yBAAJ,EAA+B;AAC7BpE,UAAAA,QAAQ,GAAGA,QAAQ,CAAC7iC,KAAT,CAAe2f,QAA1B;AACD;;AAGD,YAAIunB,QAAQ,GAAG,OAAOrE,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAA5D;;AAEA,YAAIqE,QAAJ,EAAc;AACZ,kBAAQrE,QAAQ,CAAC5uB,QAAjB;AACE,iBAAK1B,kBAAL;AACE,qBAAO2xB,gBAAgB,CACrB2C,sBAAsB,CACpBtE,WADoB,EAEpBgB,iBAFoB,EAGpBV,QAHoB,EAIpB1c,cAJoB,CADD,CAAvB;;AAQF,iBAAK3T,iBAAL;AACE,qBAAO0xB,gBAAgB,CACrB6C,qBAAqB,CACnBxE,WADmB,EAEnBgB,iBAFmB,EAGnBV,QAHmB,EAInB1c,cAJmB,CADA,CAAvB;AAXJ;AAoBD;;AAED,YAAI,OAAO0c,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAChE,iBAAOqB,gBAAgB,CACrB0C,uBAAuB,CACrBrE,WADqB,EAErBgB,iBAFqB,EAGrB,KAAKV,QAHgB,EAIrB1c,cAJqB,CADF,CAAvB;AAQD;;AAED,YAAIkc,SAAS,CAACQ,QAAD,CAAb,EAAyB;AACvB,iBAAO4C,sBAAsB,CAC3BlD,WAD2B,EAE3BgB,iBAF2B,EAG3BV,QAH2B,EAI3B1c,cAJ2B,CAA7B;AAMD;;AAED,YAAI/S,aAAa,CAACyvB,QAAD,CAAjB,EAA6B;AAC3B,iBAAOoD,yBAAyB,CAC9B1D,WAD8B,EAE9BgB,iBAF8B,EAG9BV,QAH8B,EAI9B1c,cAJ8B,CAAhC;AAMD;;AAED,YAAI+gB,QAAJ,EAAc;AACZtE,UAAAA,wBAAwB,CAACL,WAAD,EAAcM,QAAd,CAAxB;AACD;;AAED;AACE,cAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClCG,YAAAA,kBAAkB;AACnB;AACF;;AACD,YAAI,OAAOH,QAAP,KAAoB,WAApB,IAAmC,CAACoE,yBAAxC,EAAmE;AAIjE,kBAAQ1E,WAAW,CAACziC,GAApB;AACE,iBAAKmB,cAAL;AACA,iBAAKC,kBAAL;AAAyB;AACvB;AACE,sBAAI2F,QAAQ,GAAG07B,WAAW,CAACniC,SAA3B;;AACA,sBAAIyG,QAAQ,CAACsN,MAAT,CAAgBgzB,eAApB,EAAqC;AAEnC;AACD;AACF;AACF;;AAID,iBAAKpmC,mBAAL;AAA0B;AACxB,oBAAIunB,SAAS,GAAGia,WAAW,CAACvkC,IAA5B;AACA7H,gBAAAA,SAAS,CACP,KADO,EAEP,qEACE,sDADF,GAEE,cAJK,EAKPmyB,SAAS,CAACtU,WAAV,IAAyBsU,SAAS,CAACvxB,IAAnC,IAA2C,WALpC,CAAT;AAOD;AAvBH;AAyBD;;AAGD,eAAOusC,uBAAuB,CAACf,WAAD,EAAcgB,iBAAd,CAA9B;AACD;;AAED,aAAOyD,oBAAP;AACD;;AAED,QAAIA,oBAAoB,GAAG/D,eAAe,CAAC,IAAD,CAA1C;AACA,QAAImE,gBAAgB,GAAGnE,eAAe,CAAC,KAAD,CAAtC;;AAEA,aAASoE,gBAAT,CAA0B7E,UAA1B,EAAsC3gB,cAAtC,EAAsD;AACpD1rB,MAAAA,SAAS,CACPqsC,UAAU,KAAK,IAAf,IAAuB3gB,cAAc,CAACnL,KAAf,KAAyB8rB,UAAU,CAAC9rB,KADpD,EAEP,oCAFO,CAAT;;AAKA,UAAImL,cAAc,CAACnL,KAAf,KAAyB,IAA7B,EAAmC;AACjC;AACD;;AAED,UAAI4wB,YAAY,GAAGzlB,cAAc,CAACnL,KAAlC;AACA,UAAImsB,QAAQ,GAAGtU,oBAAoB,CACjC+Y,YADiC,EAEjCA,YAAY,CAACla,YAFoB,EAGjCka,YAAY,CAACnhB,cAHoB,CAAnC;AAKAtE,MAAAA,cAAc,CAACnL,KAAf,GAAuBmsB,QAAvB;AAEAA,MAAAA,QAAQ,CAAC5gC,MAAT,GAAkB4f,cAAlB;;AACA,aAAOylB,YAAY,CAAC3wB,OAAb,KAAyB,IAAhC,EAAsC;AACpC2wB,QAAAA,YAAY,GAAGA,YAAY,CAAC3wB,OAA5B;AACAksB,QAAAA,QAAQ,GAAGA,QAAQ,CAAClsB,OAAT,GAAmB4X,oBAAoB,CAChD+Y,YADgD,EAEhDA,YAAY,CAACla,YAFmC,EAGhDka,YAAY,CAACnhB,cAHmC,CAAlD;AAKA0c,QAAAA,QAAQ,CAAC5gC,MAAT,GAAkB4f,cAAlB;AACD;;AACDghB,MAAAA,QAAQ,CAAClsB,OAAT,GAAmB,IAAnB;AACD;;AAID,QAAI4wB,oBAAoB,GAAG,IAA3B;AACA,QAAIC,sBAAsB,GAAG,IAA7B;AACA,QAAIC,WAAW,GAAG,KAAlB;;AAEA,aAASC,mBAAT,CAA6B9xB,KAA7B,EAAoC;AAClC,UAAI,CAACyG,iBAAL,EAAwB;AACtB,eAAO,KAAP;AACD;;AAED,UAAIoB,cAAc,GAAG7H,KAAK,CAACxV,SAAN,CAAgBue,aAArC;AACA6oB,MAAAA,sBAAsB,GAAG/qB,uBAAuB,CAACgB,cAAD,CAAhD;AACA8pB,MAAAA,oBAAoB,GAAG3xB,KAAvB;AACA6xB,MAAAA,WAAW,GAAG,IAAd;AACA,aAAO,IAAP;AACD;;AAED,aAASE,wBAAT,CAAkCpF,WAAlC,EAA+C17B,QAA/C,EAAyD;AACvD;AACE,gBAAQ07B,WAAW,CAACziC,GAApB;AACE,eAAKsB,QAAL;AACE0b,YAAAA,8BAA8B,CAC5BylB,WAAW,CAACniC,SAAZ,CAAsBue,aADM,EAE5B9X,QAF4B,CAA9B;AAIA;;AACF,eAAKvF,aAAL;AACEyb,YAAAA,qBAAqB,CACnBwlB,WAAW,CAACvkC,IADO,EAEnBukC,WAAW,CAAChV,aAFO,EAGnBgV,WAAW,CAACniC,SAHO,EAInByG,QAJmB,CAArB;AAMA;AAdJ;AAgBD;AAED,UAAIu8B,aAAa,GAAG7T,sCAAsC,EAA1D;AACA6T,MAAAA,aAAa,CAAChjC,SAAd,GAA0ByG,QAA1B;AACAu8B,MAAAA,aAAa,CAACnhC,MAAd,GAAuBsgC,WAAvB;AACAa,MAAAA,aAAa,CAACttB,SAAd,GAA0BlB,QAA1B;;AAOA,UAAI2tB,WAAW,CAAC1U,UAAZ,KAA2B,IAA/B,EAAqC;AACnC0U,QAAAA,WAAW,CAAC1U,UAAZ,CAAuBF,UAAvB,GAAoCyV,aAApC;AACAb,QAAAA,WAAW,CAAC1U,UAAZ,GAAyBuV,aAAzB;AACD,OAHD,MAGO;AACLb,QAAAA,WAAW,CAAC3U,WAAZ,GAA0B2U,WAAW,CAAC1U,UAAZ,GAAyBuV,aAAnD;AACD;AACF;;AAED,aAASwE,yBAAT,CAAmCrF,WAAnC,EAAgD3sB,KAAhD,EAAuD;AACrDA,MAAAA,KAAK,CAACE,SAAN,IAAmBrB,SAAnB;AACA;AACE,gBAAQ8tB,WAAW,CAACziC,GAApB;AACE,eAAKsB,QAAL;AAAe;AACb,kBAAIymC,eAAe,GAAGtF,WAAW,CAACniC,SAAZ,CAAsBue,aAA5C;;AACA,sBAAQ/I,KAAK,CAAC9V,GAAd;AACE,qBAAKwB,aAAL;AACE,sBAAItD,IAAI,GAAG4X,KAAK,CAAC5X,IAAjB;AACA,sBAAIgC,KAAK,GAAG4V,KAAK,CAACwX,YAAlB;AACApQ,kBAAAA,qCAAqC,CAAC6qB,eAAD,EAAkB7pC,IAAlB,EAAwBgC,KAAxB,CAArC;AACA;;AACF,qBAAKuB,QAAL;AACE,sBAAI0c,IAAI,GAAGrI,KAAK,CAACwX,YAAjB;AACAnQ,kBAAAA,yCAAyC,CAAC4qB,eAAD,EAAkB5pB,IAAlB,CAAzC;AACA;AATJ;;AAWA;AACD;;AACD,eAAK3c,aAAL;AAAoB;AAClB,kBAAIwmC,UAAU,GAAGvF,WAAW,CAACvkC,IAA7B;AACA,kBAAI+pC,WAAW,GAAGxF,WAAW,CAAChV,aAA9B;AACA,kBAAI9P,cAAc,GAAG8kB,WAAW,CAACniC,SAAjC;;AACA,sBAAQwV,KAAK,CAAC9V,GAAd;AACE,qBAAKwB,aAAL;AACE,sBAAI0mC,KAAK,GAAGpyB,KAAK,CAAC5X,IAAlB;AACA,sBAAIiqC,MAAM,GAAGryB,KAAK,CAACwX,YAAnB;AACAlQ,kBAAAA,4BAA4B,CAC1B4qB,UAD0B,EAE1BC,WAF0B,EAG1BtqB,cAH0B,EAI1BuqB,KAJ0B,EAK1BC,MAL0B,CAA5B;AAOA;;AACF,qBAAK1mC,QAAL;AACE,sBAAI2mC,KAAK,GAAGtyB,KAAK,CAACwX,YAAlB;AACAjQ,kBAAAA,gCAAgC,CAC9B2qB,UAD8B,EAE9BC,WAF8B,EAG9BtqB,cAH8B,EAI9ByqB,KAJ8B,CAAhC;AAMA;AApBJ;;AAsBA;AACD;;AACD;AACE;AA7CJ;AA+CD;AACF;;AAED,aAASC,UAAT,CAAoBvyB,KAApB,EAA2BwyB,YAA3B,EAAyC;AACvC,cAAQxyB,KAAK,CAAC9V,GAAd;AACE,aAAKwB,aAAL;AAAoB;AAClB,gBAAItD,IAAI,GAAG4X,KAAK,CAAC5X,IAAjB;AACA,gBAAIgC,KAAK,GAAG4V,KAAK,CAACwX,YAAlB;AACA,gBAAIvmB,QAAQ,GAAGyV,kBAAkB,CAAC8rB,YAAD,EAAepqC,IAAf,EAAqBgC,KAArB,CAAjC;;AACA,gBAAI6G,QAAQ,KAAK,IAAjB,EAAuB;AACrB+O,cAAAA,KAAK,CAACxV,SAAN,GAAkByG,QAAlB;AACA,qBAAO,IAAP;AACD;;AACD,mBAAO,KAAP;AACD;;AACD,aAAKtF,QAAL;AAAe;AACb,gBAAI0c,IAAI,GAAGrI,KAAK,CAACwX,YAAjB;AACA,gBAAIpN,YAAY,GAAGzD,sBAAsB,CAAC6rB,YAAD,EAAenqB,IAAf,CAAzC;;AACA,gBAAI+B,YAAY,KAAK,IAArB,EAA2B;AACzBpK,cAAAA,KAAK,CAACxV,SAAN,GAAkB4f,YAAlB;AACA,qBAAO,IAAP;AACD;;AACD,mBAAO,KAAP;AACD;;AACD;AACE,iBAAO,KAAP;AArBJ;AAuBD;;AAED,aAASqoB,gCAAT,CAA0CzyB,KAA1C,EAAiD;AAC/C,UAAI,CAAC6xB,WAAL,EAAkB;AAChB;AACD;;AACD,UAAIW,YAAY,GAAGZ,sBAAnB;;AACA,UAAI,CAACY,YAAL,EAAmB;AAEjBR,QAAAA,yBAAyB,CAACL,oBAAD,EAAuB3xB,KAAvB,CAAzB;AACA6xB,QAAAA,WAAW,GAAG,KAAd;AACAF,QAAAA,oBAAoB,GAAG3xB,KAAvB;AACA;AACD;;AACD,UAAI0yB,sBAAsB,GAAGF,YAA7B;;AACA,UAAI,CAACD,UAAU,CAACvyB,KAAD,EAAQwyB,YAAR,CAAf,EAAsC;AAIpCA,QAAAA,YAAY,GAAG5rB,wBAAwB,CAAC8rB,sBAAD,CAAvC;;AACA,YAAI,CAACF,YAAD,IAAiB,CAACD,UAAU,CAACvyB,KAAD,EAAQwyB,YAAR,CAAhC,EAAuD;AAErDR,UAAAA,yBAAyB,CAACL,oBAAD,EAAuB3xB,KAAvB,CAAzB;AACA6xB,UAAAA,WAAW,GAAG,KAAd;AACAF,UAAAA,oBAAoB,GAAG3xB,KAAvB;AACA;AACD;;AAKD+xB,QAAAA,wBAAwB,CAACJ,oBAAD,EAAuBe,sBAAvB,CAAxB;AACD;;AACDf,MAAAA,oBAAoB,GAAG3xB,KAAvB;AACA4xB,MAAAA,sBAAsB,GAAG/qB,uBAAuB,CAAC2rB,YAAD,CAAhD;AACD;;AAED,aAASG,4BAAT,CACE3yB,KADF,EAEE+H,qBAFF,EAGEC,WAHF,EAIE;AACA,UAAI,CAACvB,iBAAL,EAAwB;AACtBlmB,QAAAA,SAAS,CACP,KADO,EAEP,iEACE,sEAHK,CAAT;AAKD;;AAED,UAAI0Q,QAAQ,GAAG+O,KAAK,CAACxV,SAArB;AACA,UAAIoX,aAAa,GAAGkF,eAAe,CACjC7V,QADiC,EAEjC+O,KAAK,CAAC5X,IAF2B,EAGjC4X,KAAK,CAAC2X,aAH2B,EAIjC5P,qBAJiC,EAKjCC,WALiC,EAMjChI,KANiC,CAAnC;AASAA,MAAAA,KAAK,CAAC4X,WAAN,GAAoBhW,aAApB;;AAGA,UAAIA,aAAa,KAAK,IAAtB,EAA4B;AAC1B,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;AAED,aAASgxB,gCAAT,CAA0C5yB,KAA1C,EAAiD;AAC/C,UAAI,CAACyG,iBAAL,EAAwB;AACtBlmB,QAAAA,SAAS,CACP,KADO,EAEP,qEACE,sEAHK,CAAT;AAKD;;AAED,UAAI6pB,YAAY,GAAGpK,KAAK,CAACxV,SAAzB;AACA,UAAIgkC,WAAW,GAAGxuB,KAAK,CAAC2X,aAAxB;AACA,UAAI3U,YAAY,GAAG+D,mBAAmB,CAACqD,YAAD,EAAeokB,WAAf,EAA4BxuB,KAA5B,CAAtC;AACA;AACE,YAAIgD,YAAJ,EAAkB;AAGhB,cAAI2pB,WAAW,GAAGgF,oBAAlB;;AACA,cAAIhF,WAAW,KAAK,IAApB,EAA0B;AACxB,oBAAQA,WAAW,CAACziC,GAApB;AACE,mBAAKsB,QAAL;AAAe;AACb,sBAAIymC,eAAe,GAAGtF,WAAW,CAACniC,SAAZ,CAAsBue,aAA5C;AACA/B,kBAAAA,wCAAwC,CACtCirB,eADsC,EAEtC7nB,YAFsC,EAGtCokB,WAHsC,CAAxC;AAKA;AACD;;AACD,mBAAK9iC,aAAL;AAAoB;AAClB,sBAAIwmC,UAAU,GAAGvF,WAAW,CAACvkC,IAA7B;AACA,sBAAI+pC,WAAW,GAAGxF,WAAW,CAAChV,aAA9B;AACA,sBAAI9P,cAAc,GAAG8kB,WAAW,CAACniC,SAAjC;AACAyc,kBAAAA,+BAA+B,CAC7BirB,UAD6B,EAE7BC,WAF6B,EAG7BtqB,cAH6B,EAI7BuC,YAJ6B,EAK7BokB,WAL6B,CAA/B;AAOA;AACD;AAtBH;AAwBD;AACF;AACF;AACD,aAAOxrB,YAAP;AACD;;AAED,aAAS6vB,mBAAT,CAA6B7yB,KAA7B,EAAoC;AAClC,UAAImB,MAAM,GAAGnB,KAAK,CAAC3T,MAAnB;;AACA,aACE8U,MAAM,KAAK,IAAX,IACAA,MAAM,CAACjX,GAAP,KAAewB,aADf,IAEAyV,MAAM,CAACjX,GAAP,KAAesB,QAHjB,EAIE;AACA2V,QAAAA,MAAM,GAAGA,MAAM,CAAC9U,MAAhB;AACD;;AACDslC,MAAAA,oBAAoB,GAAGxwB,MAAvB;AACD;;AAED,aAAS2xB,iBAAT,CAA2B9yB,KAA3B,EAAkC;AAChC,UAAI,CAACyG,iBAAL,EAAwB;AACtB,eAAO,KAAP;AACD;;AACD,UAAIzG,KAAK,KAAK2xB,oBAAd,EAAoC;AAGlC,eAAO,KAAP;AACD;;AACD,UAAI,CAACE,WAAL,EAAkB;AAIhBgB,QAAAA,mBAAmB,CAAC7yB,KAAD,CAAnB;AACA6xB,QAAAA,WAAW,GAAG,IAAd;AACA,eAAO,KAAP;AACD;;AAED,UAAIzpC,IAAI,GAAG4X,KAAK,CAAC5X,IAAjB;;AAOA,UACE4X,KAAK,CAAC9V,GAAN,KAAcwB,aAAd,IACCtD,IAAI,KAAK,MAAT,IACCA,IAAI,KAAK,MADV,IAEC,CAACuhB,oBAAoB,CAACvhB,IAAD,EAAO4X,KAAK,CAAC2X,aAAb,CAJzB,EAKE;AACA,YAAI6a,YAAY,GAAGZ,sBAAnB;;AACA,eAAOY,YAAP,EAAqB;AACnBT,UAAAA,wBAAwB,CAAC/xB,KAAD,EAAQwyB,YAAR,CAAxB;AACAA,UAAAA,YAAY,GAAG5rB,wBAAwB,CAAC4rB,YAAD,CAAvC;AACD;AACF;;AAEDK,MAAAA,mBAAmB,CAAC7yB,KAAD,CAAnB;AACA4xB,MAAAA,sBAAsB,GAAGD,oBAAoB,GACzC/qB,wBAAwB,CAAC5G,KAAK,CAACxV,SAAP,CADiB,GAEzC,IAFJ;AAGA,aAAO,IAAP;AACD;;AAED,aAASuoC,mBAAT,GAA+B;AAC7B,UAAI,CAACtsB,iBAAL,EAAwB;AACtB;AACD;;AAEDkrB,MAAAA,oBAAoB,GAAG,IAAvB;AACAC,MAAAA,sBAAsB,GAAG,IAAzB;AACAC,MAAAA,WAAW,GAAG,KAAd;AACD;;AAED,aAASmB,qBAAT,CAA+Bj1B,QAA/B,EAAyC;AACvC,UAAIk1B,MAAM,GAAGl1B,QAAQ,CAACG,YAAtB;;AACA,cAAQ+0B,MAAR;AACE,aAAKr1B,QAAL;AACE,cAAI8U,SAAS,GAAG3U,QAAQ,CAACC,YAAzB;AACA,iBAAO0U,SAAP;;AACF,aAAK7U,QAAL;AACE,gBAAME,QAAQ,CAACC,YAAf;;AACF,aAAKL,OAAL;AACE,gBAAMI,QAAN;;AACF;AAAS;AACPA,YAAAA,QAAQ,CAACG,YAAT,GAAwBP,OAAxB;AACAI,YAAAA,QAAQ,CAACU,IAAT,CACE,UAASy0B,aAAT,EAAwB;AACtB,kBAAIn1B,QAAQ,CAACG,YAAT,KAA0BP,OAA9B,EAAuC;AACrCI,gBAAAA,QAAQ,CAACG,YAAT,GAAwBN,QAAxB;;AACA,oBAAI,OAAOs1B,aAAP,KAAyB,QAAzB,IAAqCA,aAAa,KAAK,IAA3D,EAAiE;AAI/D,sBAAIC,aAAa,GAAGD,aAAa,CAACE,OAAlC;AACAF,kBAAAA,aAAa,GACXC,aAAa,KAAK9yC,SAAlB,IAA+B8yC,aAAa,KAAK,IAAjD,GACIA,aADJ,GAEID,aAHN;AAID,iBATD,MASO;AACLA,kBAAAA,aAAa,GAAGA,aAAhB;AACD;;AACDn1B,gBAAAA,QAAQ,CAACC,YAAT,GAAwBk1B,aAAxB;AACD;AACF,aAlBH,EAmBE,UAASnyC,KAAT,EAAgB;AACd,kBAAIgd,QAAQ,CAACG,YAAT,KAA0BP,OAA9B,EAAuC;AACrCI,gBAAAA,QAAQ,CAACG,YAAT,GAAwBL,QAAxB;AACAE,gBAAAA,QAAQ,CAACC,YAAT,GAAwBjd,KAAxB;AACD;AACF,aAxBH;AA0BA,kBAAMgd,QAAN;AACD;AArCH;AAuCD;;AAED,QAAIs1B,mBAAmB,GAAG/2B,oBAAoB,CAACqD,iBAA/C;AAEA,QAAI2zB,oBAAoB,GAAG,KAAK,CAAhC;AACA,QAAIC,gDAAgD,GAAG,KAAK,CAA5D;AACA,QAAIC,yBAAyB,GAAG,KAAK,CAArC;AAEA;AACEF,MAAAA,oBAAoB,GAAG,EAAvB;AACAC,MAAAA,gDAAgD,GAAG,EAAnD;AACAC,MAAAA,yBAAyB,GAAG,EAA5B;AACD;;AAED,aAASC,iBAAT,CACE7G,UADF,EAEE3gB,cAFF,EAGEynB,YAHF,EAIE/T,oBAJF,EAKE;AACA,UAAIiN,UAAU,KAAK,IAAnB,EAAyB;AAKvB3gB,QAAAA,cAAc,CAACnL,KAAf,GAAuB0wB,gBAAgB,CACrCvlB,cADqC,EAErC,IAFqC,EAGrCynB,YAHqC,EAIrC/T,oBAJqC,CAAvC;AAMD,OAXD,MAWO;AAOL1T,QAAAA,cAAc,CAACnL,KAAf,GAAuBswB,oBAAoB,CACzCnlB,cADyC,EAEzC2gB,UAAU,CAAC9rB,KAF8B,EAGzC4yB,YAHyC,EAIzC/T,oBAJyC,CAA3C;AAMD;AACF;;AAED,aAASgU,gBAAT,CACE/G,UADF,EAEE3gB,cAFF,EAGE7jB,IAHF,EAIE2a,SAJF,EAKE4c,oBALF,EAME;AACA,UAAIphB,MAAM,GAAGnW,IAAI,CAACmW,MAAlB;AACA,UAAImZ,GAAG,GAAGzL,cAAc,CAACyL,GAAzB;;AACA,UAAItE,iBAAiB,EAArB,EAAyB,CAGxB,CAHD,MAGO,IAAInH,cAAc,CAAC0L,aAAf,KAAiC5U,SAArC,EAAgD;AACrD,YAAI6wB,UAAU,GAAGhH,UAAU,KAAK,IAAf,GAAsBA,UAAU,CAAClV,GAAjC,GAAuC,IAAxD;;AACA,YAAIA,GAAG,KAAKkc,UAAZ,EAAwB;AACtB,iBAAOC,4BAA4B,CACjCjH,UADiC,EAEjC3gB,cAFiC,EAGjC0T,oBAHiC,CAAnC;AAKD;AACF;;AAED,UAAI+T,YAAY,GAAG,KAAK,CAAxB;AACA;AACEL,QAAAA,mBAAmB,CAACnqC,OAApB,GAA8B+iB,cAA9B;AACAO,QAAAA,eAAe,CAAC,QAAD,CAAf;AACAknB,QAAAA,YAAY,GAAGn1B,MAAM,CAACwE,SAAD,EAAY2U,GAAZ,CAArB;AACAlL,QAAAA,eAAe,CAAC,IAAD,CAAf;AACD;AAEDinB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBlJ,SAAjB,CAAZ;AACA,aAAOkJ,cAAc,CAACnL,KAAtB;AACD;;AAED,aAAS+tB,cAAT,CAAwBjC,UAAxB,EAAoC3gB,cAApC,EAAoD0T,oBAApD,EAA0E;AACxE,UAAI+T,YAAY,GAAGznB,cAAc,CAACuL,YAAlC;AACAic,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBynB,YAAjB,CAAZ;AACA,aAAOznB,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASizB,UAAT,CAAoBnH,UAApB,EAAgC3gB,cAAhC,EAAgD0T,oBAAhD,EAAsE;AACpE,UAAI+T,YAAY,GAAGznB,cAAc,CAACuL,YAAf,CAA4BzN,QAA/C;AACA0pB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBynB,YAAjB,CAAZ;AACA,aAAOznB,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASkzB,cAAT,CAAwBpH,UAAxB,EAAoC3gB,cAApC,EAAoD0T,oBAApD,EAA0E;AACxE,UAAIzS,mBAAJ,EAAyB;AACvBjB,QAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AACD,UAAIiE,SAAS,GAAGkJ,cAAc,CAACuL,YAA/B;AACA,UAAIkc,YAAY,GAAG3wB,SAAS,CAACgH,QAA7B;AACA0pB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBlJ,SAAjB,CAAZ;AACA,aAAOkJ,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASmzB,OAAT,CAAiBrH,UAAjB,EAA6B3gB,cAA7B,EAA6C;AAC3C,UAAIyL,GAAG,GAAGzL,cAAc,CAACyL,GAAzB;;AACA,UACGkV,UAAU,KAAK,IAAf,IAAuBlV,GAAG,KAAK,IAAhC,IACCkV,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAAClV,GAAX,KAAmBA,GAF7C,EAGE;AAEAzL,QAAAA,cAAc,CAAC/L,SAAf,IAA4Bd,GAA5B;AACD;AACF;;AAED,aAAS80B,yBAAT,CACEtH,UADF,EAEE3gB,cAFF,EAGEyG,SAHF,EAIE3P,SAJF,EAKE4c,oBALF,EAME;AACA,UAAI7M,eAAe,GAAGL,kBAAkB,CAACxG,cAAD,EAAiByG,SAAjB,EAA4B,IAA5B,CAAxC;AACA,UAAInxB,OAAO,GAAG2xB,gBAAgB,CAACjH,cAAD,EAAiB6G,eAAjB,CAA9B;AAEA,UAAI4gB,YAAY,GAAG,KAAK,CAAxB;AACA5O,MAAAA,oBAAoB,CAAC7Y,cAAD,EAAiB0T,oBAAjB,CAApB;AACA;AACE0T,QAAAA,mBAAmB,CAACnqC,OAApB,GAA8B+iB,cAA9B;AACAO,QAAAA,eAAe,CAAC,QAAD,CAAf;AACAknB,QAAAA,YAAY,GAAGhhB,SAAS,CAAC3P,SAAD,EAAYxhB,OAAZ,CAAxB;AACAirB,QAAAA,eAAe,CAAC,IAAD,CAAf;AACD;AAGDP,MAAAA,cAAc,CAAC/L,SAAf,IAA4BtB,aAA5B;AACA60B,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBlJ,SAAjB,CAAZ;AACA,aAAOkJ,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASqzB,oBAAT,CACEvH,UADF,EAEE3gB,cAFF,EAGEyG,SAHF,EAIE3P,SAJF,EAKE4c,oBALF,EAME;AAIA,UAAIyU,UAAU,GAAG,KAAK,CAAtB;;AACA,UAAIxhB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChC0hB,QAAAA,UAAU,GAAG,IAAb;AACArgB,QAAAA,mBAAmB,CAAC9H,cAAD,CAAnB;AACD,OAHD,MAGO;AACLmoB,QAAAA,UAAU,GAAG,KAAb;AACD;;AACDtP,MAAAA,oBAAoB,CAAC7Y,cAAD,EAAiB0T,oBAAjB,CAApB;AAEA,UAAI3c,YAAY,GAAG,KAAK,CAAxB;;AACA,UAAI4pB,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAI3gB,cAAc,CAACzhB,SAAf,KAA6B,IAAjC,EAAuC;AAErCwgC,UAAAA,sBAAsB,CACpB/e,cADoB,EAEpByG,SAFoB,EAGpB3P,SAHoB,EAIpB4c,oBAJoB,CAAtB;AAMA8L,UAAAA,kBAAkB,CAChBxf,cADgB,EAEhByG,SAFgB,EAGhB3P,SAHgB,EAIhB4c,oBAJgB,CAAlB;AAMA3c,UAAAA,YAAY,GAAG,IAAf;AACD,SAfD,MAeO;AAELA,UAAAA,YAAY,GAAG2oB,wBAAwB,CACrC1f,cADqC,EAErCyG,SAFqC,EAGrC3P,SAHqC,EAIrC4c,oBAJqC,CAAvC;AAMD;AACF,OAzBD,MAyBO;AACL3c,QAAAA,YAAY,GAAG+oB,mBAAmB,CAChCa,UADgC,EAEhC3gB,cAFgC,EAGhCyG,SAHgC,EAIhC3P,SAJgC,EAKhC4c,oBALgC,CAAlC;AAOD;;AACD,aAAO0U,oBAAoB,CACzBzH,UADyB,EAEzB3gB,cAFyB,EAGzByG,SAHyB,EAIzB1P,YAJyB,EAKzBoxB,UALyB,EAMzBzU,oBANyB,CAA3B;AAQD;;AAED,aAAS0U,oBAAT,CACEzH,UADF,EAEE3gB,cAFF,EAGEyG,SAHF,EAIE1P,YAJF,EAKEoxB,UALF,EAMEzU,oBANF,EAOE;AAEAsU,MAAAA,OAAO,CAACrH,UAAD,EAAa3gB,cAAb,CAAP;AAEA,UAAIqoB,eAAe,GAAG,CAACroB,cAAc,CAAC/L,SAAf,GAA2Bf,UAA5B,MAA4CR,QAAlE;;AAEA,UAAI,CAACqE,YAAD,IAAiB,CAACsxB,eAAtB,EAAuC;AAErC,YAAIF,UAAJ,EAAgB;AACdlgB,UAAAA,yBAAyB,CAACjI,cAAD,EAAiByG,SAAjB,EAA4B,KAA5B,CAAzB;AACD;;AAED,eAAOmhB,4BAA4B,CACjCjH,UADiC,EAEjC3gB,cAFiC,EAGjC0T,oBAHiC,CAAnC;AAKD;;AAED,UAAI1uB,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AAGA6oC,MAAAA,mBAAmB,CAACnqC,OAApB,GAA8B+iB,cAA9B;AACA,UAAIynB,YAAY,GAAG,KAAK,CAAxB;;AACA,UACEY,eAAe,KACd,CAAC1nB,8BAAD,IACC,OAAO8F,SAAS,CAACgY,wBAAjB,KAA8C,UAFjC,CADjB,EAIE;AAMAgJ,QAAAA,YAAY,GAAG,IAAf;;AAEA,YAAIxmB,mBAAJ,EAAyB;AACvBoZ,UAAAA,0BAA0B,CAACra,cAAD,CAA1B;AACD;AACF,OAfD,MAeO;AACL;AACEO,UAAAA,eAAe,CAAC,QAAD,CAAf;AACAknB,UAAAA,YAAY,GAAGziC,QAAQ,CAACsN,MAAT,EAAf;;AACA,cACEmO,2BAA2B,IAC1BC,wCAAwC,IACvCV,cAAc,CAACwL,IAAf,GAAsBX,UAH1B,EAIE;AACA7lB,YAAAA,QAAQ,CAACsN,MAAT;AACD;;AACDiO,UAAAA,eAAe,CAAC,IAAD,CAAf;AACD;AACF;;AAGDP,MAAAA,cAAc,CAAC/L,SAAf,IAA4BtB,aAA5B;;AACA,UAAIguB,UAAU,KAAK,IAAf,IAAuB0H,eAA3B,EAA4C;AAG1Cb,QAAAA,iBAAiB,CAAC7G,UAAD,EAAa3gB,cAAb,EAA6B,IAA7B,EAAmC0T,oBAAnC,CAAjB;AACA1T,QAAAA,cAAc,CAACnL,KAAf,GAAuB,IAAvB;AAID;;AACD2yB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAQA4U,MAAAA,YAAY,CAACtoB,cAAD,EAAiBhb,QAAQ,CAAC0P,KAA1B,CAAZ;AACAmzB,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBhb,QAAQ,CAAC7G,KAA1B,CAAZ;;AAGA,UAAIgqC,UAAJ,EAAgB;AACdlgB,QAAAA,yBAAyB,CAACjI,cAAD,EAAiByG,SAAjB,EAA4B,IAA5B,CAAzB;AACD;;AAED,aAAOzG,cAAc,CAACnL,KAAtB;AACD;;AAED,aAAS0zB,mBAAT,CAA6BvoB,cAA7B,EAA6C;AAC3C,UAAIkJ,IAAI,GAAGlJ,cAAc,CAACzhB,SAA1B;;AACA,UAAI2qB,IAAI,CAACyF,cAAT,EAAyB;AACvBpH,QAAAA,yBAAyB,CACvBvH,cADuB,EAEvBkJ,IAAI,CAACyF,cAFkB,EAGvBzF,IAAI,CAACyF,cAAL,KAAwBzF,IAAI,CAAC5zB,OAHN,CAAzB;AAKD,OAND,MAMO,IAAI4zB,IAAI,CAAC5zB,OAAT,EAAkB;AAEvBiyB,QAAAA,yBAAyB,CAACvH,cAAD,EAAiBkJ,IAAI,CAAC5zB,OAAtB,EAA+B,KAA/B,CAAzB;AACD;;AACDkkC,MAAAA,iBAAiB,CAACxZ,cAAD,EAAiBkJ,IAAI,CAACpM,aAAtB,CAAjB;AACD;;AAED,aAAS0rB,cAAT,CAAwB7H,UAAxB,EAAoC3gB,cAApC,EAAoD0T,oBAApD,EAA0E;AACxE6U,MAAAA,mBAAmB,CAACvoB,cAAD,CAAnB;AACA,UAAI2L,WAAW,GAAG3L,cAAc,CAAC2L,WAAjC;AACAr3B,MAAAA,SAAS,CACPq3B,WAAW,KAAK,IADT,EAEP,sEACE,oEADF,GAEE,gBAJK,CAAT;AAMA,UAAI7U,SAAS,GAAGkJ,cAAc,CAACuL,YAA/B;AACA,UAAIqK,SAAS,GAAG5V,cAAc,CAAC4L,aAA/B;AACA,UAAI6c,YAAY,GAAG7S,SAAS,KAAK,IAAd,GAAqBA,SAAS,CAAC9I,OAA/B,GAAyC,IAA5D;AACAkJ,MAAAA,kBAAkB,CAChBhW,cADgB,EAEhB2L,WAFgB,EAGhB7U,SAHgB,EAIhB,IAJgB,EAKhB4c,oBALgB,CAAlB;AAOA,UAAIgV,SAAS,GAAG1oB,cAAc,CAAC4L,aAA/B;AAGA,UAAI6b,YAAY,GAAGiB,SAAS,CAAC5b,OAA7B;;AACA,UAAI2a,YAAY,KAAKgB,YAArB,EAAmC;AAGjC3B,QAAAA,mBAAmB;AACnB,eAAOc,4BAA4B,CACjCjH,UADiC,EAEjC3gB,cAFiC,EAGjC0T,oBAHiC,CAAnC;AAKD;;AACD,UAAIxK,IAAI,GAAGlJ,cAAc,CAACzhB,SAA1B;;AACA,UACE,CAACoiC,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAAC9rB,KAAX,KAAqB,IAA7C,KACAqU,IAAI,CAAC+E,OADL,IAEA4X,mBAAmB,CAAC7lB,cAAD,CAHrB,EAIE;AAUAA,QAAAA,cAAc,CAAC/L,SAAf,IAA4BrB,SAA5B;AAKAoN,QAAAA,cAAc,CAACnL,KAAf,GAAuB0wB,gBAAgB,CACrCvlB,cADqC,EAErC,IAFqC,EAGrCynB,YAHqC,EAIrC/T,oBAJqC,CAAvC;AAMD,OAzBD,MAyBO;AAGL8T,QAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAoT,QAAAA,mBAAmB;AACpB;;AACD,aAAO9mB,cAAc,CAACnL,KAAtB;AACD;;AAED,aAAS8zB,mBAAT,CAA6BhI,UAA7B,EAAyC3gB,cAAzC,EAAyD0T,oBAAzD,EAA+E;AAC7EmG,MAAAA,eAAe,CAAC7Z,cAAD,CAAf;;AAEA,UAAI2gB,UAAU,KAAK,IAAnB,EAAyB;AACvB6F,QAAAA,gCAAgC,CAACxmB,cAAD,CAAhC;AACD;;AAED,UAAI7jB,IAAI,GAAG6jB,cAAc,CAAC7jB,IAA1B;AACA,UAAI2a,SAAS,GAAGkJ,cAAc,CAACuL,YAA/B;AACA,UAAI1U,SAAS,GAAG8pB,UAAU,KAAK,IAAf,GAAsBA,UAAU,CAACjV,aAAjC,GAAiD,IAAjE;AAEA,UAAI+b,YAAY,GAAG3wB,SAAS,CAACgH,QAA7B;AACA,UAAI8qB,iBAAiB,GAAGlrB,oBAAoB,CAACvhB,IAAD,EAAO2a,SAAP,CAA5C;;AAEA,UAAI8xB,iBAAJ,EAAuB;AAKrBnB,QAAAA,YAAY,GAAG,IAAf;AACD,OAND,MAMO,IAAI5wB,SAAS,KAAK,IAAd,IAAsB6G,oBAAoB,CAACvhB,IAAD,EAAO0a,SAAP,CAA9C,EAAiE;AAGtEmJ,QAAAA,cAAc,CAAC/L,SAAf,IAA4BjB,YAA5B;AACD;;AAEDg1B,MAAAA,OAAO,CAACrH,UAAD,EAAa3gB,cAAb,CAAP;;AAGA,UACE0T,oBAAoB,KAAKlK,KAAzB,IACAxJ,cAAc,CAACwL,IAAf,GAAsBZ,SADtB,IAEAnN,yBAAyB,CAACthB,IAAD,EAAO2a,SAAP,CAH3B,EAIE;AAEAkJ,QAAAA,cAAc,CAACsE,cAAf,GAAgCkF,KAAhC;AACAxJ,QAAAA,cAAc,CAAC0L,aAAf,GAA+B5U,SAA/B;AACA,eAAO,IAAP;AACD;;AAED0wB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBlJ,SAAjB,CAAZ;AACA,aAAOkJ,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASg0B,cAAT,CAAwBlI,UAAxB,EAAoC3gB,cAApC,EAAoD;AAClD,UAAI2gB,UAAU,KAAK,IAAnB,EAAyB;AACvB6F,QAAAA,gCAAgC,CAACxmB,cAAD,CAAhC;AACD;;AACD,UAAIlJ,SAAS,GAAGkJ,cAAc,CAACuL,YAA/B;AACAsc,MAAAA,YAAY,CAAC7nB,cAAD,EAAiBlJ,SAAjB,CAAZ;AAGA,aAAO,IAAP;AACD;;AAED,aAASgyB,mBAAT,CAA6BriB,SAA7B,EAAwCsiB,SAAxC,EAAmD;AACjD,UAAItiB,SAAS,IAAIA,SAAS,CAAC2X,YAA3B,EAAyC;AAEvC,YAAIjgC,KAAK,GAAG,SAAc,EAAd,EAAkB4qC,SAAlB,CAAZ;;AACA,YAAI3K,YAAY,GAAG3X,SAAS,CAAC2X,YAA7B;;AACA,aAAK,IAAIj7B,QAAT,IAAqBi7B,YAArB,EAAmC;AACjC,cAAIjgC,KAAK,CAACgF,QAAD,CAAL,KAAoB/O,SAAxB,EAAmC;AACjC+J,YAAAA,KAAK,CAACgF,QAAD,CAAL,GAAkBi7B,YAAY,CAACj7B,QAAD,CAA9B;AACD;AACF;;AACD,eAAOhF,KAAP;AACD;;AACD,aAAO4qC,SAAP;AACD;;AAED,aAASC,2BAAT,CACErI,UADF,EAEE3gB,cAFF,EAGEyG,SAHF,EAIEiN,oBAJF,EAKE;AACAp/B,MAAAA,SAAS,CACPqsC,UAAU,KAAK,IADR,EAEP,yEACE,wDAHK,CAAT;AAMA,UAAIxiC,KAAK,GAAG6hB,cAAc,CAACuL,YAA3B;;AACA,UACE,OAAO9E,SAAP,KAAqB,QAArB,IACAA,SAAS,KAAK,IADd,IAEA,OAAOA,SAAS,CAACjU,IAAjB,KAA0B,UAH5B,EAIE;AACAiU,QAAAA,SAAS,GAAGsgB,qBAAqB,CAACtgB,SAAD,CAAjC;AACA,YAAIwiB,WAAW,GAAIjpB,cAAc,CAAC/hB,GAAf,GAAqBwuB,uBAAuB,CAC7DzM,cAD6D,EAE7DyG,SAF6D,CAA/D;AAIA,YAAIyiB,aAAa,GAAGJ,mBAAmB,CAACriB,SAAD,EAAYtoB,KAAZ,CAAvC;;AACA,gBAAQ8qC,WAAR;AACE,eAAK9pC,uBAAL;AAA8B;AAC5B,qBAAO8oC,yBAAyB,CAC9BtH,UAD8B,EAE9B3gB,cAF8B,EAG9ByG,SAH8B,EAI9ByiB,aAJ8B,EAK9BxV,oBAL8B,CAAhC;AAOD;;AACD,eAAKr0B,kBAAL;AAAyB;AACvB,qBAAO6oC,oBAAoB,CACzBvH,UADyB,EAEzB3gB,cAFyB,EAGzByG,SAHyB,EAIzByiB,aAJyB,EAKzBxV,oBALyB,CAA3B;AAOD;;AACD,eAAK1zB,cAAL;AAAqB;AACnB,qBAAO0nC,gBAAgB,CACrB/G,UADqB,EAErB3gB,cAFqB,EAGrByG,SAHqB,EAIrByiB,aAJqB,EAKrBxV,oBALqB,CAAvB;AAOD;;AACD;AAAS;AAGPp/B,cAAAA,SAAS,CACP,KADO,EAEP,uEACE,uDAHK,EAIPmyB,SAJO,CAAT;AAMD;AArCH;AAuCD;;AAED,UAAII,eAAe,GAAGL,kBAAkB,CAACxG,cAAD,EAAiByG,SAAjB,EAA4B,KAA5B,CAAxC;AACA,UAAInxB,OAAO,GAAG2xB,gBAAgB,CAACjH,cAAD,EAAiB6G,eAAjB,CAA9B;AAEAgS,MAAAA,oBAAoB,CAAC7Y,cAAD,EAAiB0T,oBAAjB,CAApB;AAEA,UAAItjB,KAAK,GAAG,KAAK,CAAjB;AAEA;AACE,YACEqW,SAAS,CAAChxB,SAAV,IACA,OAAOgxB,SAAS,CAAChxB,SAAV,CAAoB6c,MAA3B,KAAsC,UAFxC,EAGE;AACA,cAAI8Q,aAAa,GAAGlR,gBAAgB,CAACuU,SAAD,CAAhB,IAA+B,SAAnD;;AAEA,cAAI,CAAC4gB,oBAAoB,CAACjkB,aAAD,CAAzB,EAA0C;AACxCvoB,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,+FACE,8EAHiB,EAInBuoB,aAJmB,EAKnBA,aALmB,CAArB;AAOAikB,YAAAA,oBAAoB,CAACjkB,aAAD,CAApB,GAAsC,IAAtC;AACD;AACF;;AAED,YAAIpD,cAAc,CAACwL,IAAf,GAAsBX,UAA1B,EAAsC;AACpC2E,UAAAA,uBAAuB,CAACM,0BAAxB,CAAmD9P,cAAnD,EAAmE,IAAnE;AACD;;AAEDonB,QAAAA,mBAAmB,CAACnqC,OAApB,GAA8B+iB,cAA9B;AACA5P,QAAAA,KAAK,GAAGqW,SAAS,CAACtoB,KAAD,EAAQ7I,OAAR,CAAjB;AACD;AAED0qB,MAAAA,cAAc,CAAC/L,SAAf,IAA4BtB,aAA5B;;AAEA,UACE,OAAOvC,KAAP,KAAiB,QAAjB,IACAA,KAAK,KAAK,IADV,IAEA,OAAOA,KAAK,CAACkC,MAAb,KAAwB,UAFxB,IAGAlC,KAAK,CAACgC,QAAN,KAAmBhe,SAJrB,EAKE;AAEA4rB,QAAAA,cAAc,CAAC/hB,GAAf,GAAqBmB,cAArB;AAKA,YAAI+oC,UAAU,GAAG,KAAjB;;AACA,YAAIxhB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChC0hB,UAAAA,UAAU,GAAG,IAAb;AACArgB,UAAAA,mBAAmB,CAAC9H,cAAD,CAAnB;AACD,SAHD,MAGO;AACLmoB,UAAAA,UAAU,GAAG,KAAb;AACD;;AAEDnoB,QAAAA,cAAc,CAAC4L,aAAf,GACExb,KAAK,CAACsE,KAAN,KAAgB,IAAhB,IAAwBtE,KAAK,CAACsE,KAAN,KAAgBtgB,SAAxC,GAAoDgc,KAAK,CAACsE,KAA1D,GAAkE,IADpE;AAGA,YAAIsnB,wBAAwB,GAAGvV,SAAS,CAACuV,wBAAzC;;AACA,YAAI,OAAOA,wBAAP,KAAoC,UAAxC,EAAoD;AAClDF,UAAAA,0BAA0B,CACxB9b,cADwB,EAExByG,SAFwB,EAGxBuV,wBAHwB,EAIxB79B,KAJwB,CAA1B;AAMD;;AAEDygC,QAAAA,kBAAkB,CAAC5e,cAAD,EAAiB5P,KAAjB,CAAlB;AACAovB,QAAAA,kBAAkB,CAACxf,cAAD,EAAiByG,SAAjB,EAA4BtoB,KAA5B,EAAmCu1B,oBAAnC,CAAlB;AACA,eAAO0U,oBAAoB,CACzBzH,UADyB,EAEzB3gB,cAFyB,EAGzByG,SAHyB,EAIzB,IAJyB,EAKzB0hB,UALyB,EAMzBzU,oBANyB,CAA3B;AAQD,OA3CD,MA2CO;AAEL1T,QAAAA,cAAc,CAAC/hB,GAAf,GAAqBiB,mBAArB;AACA;AACE,cAAIunB,SAAJ,EAAe;AACb,aAAC,CAACA,SAAS,CAACW,iBAAZ,GACIvsB,qBAAqB,CACnB,KADmB,EAEnB,yEAFmB,EAGnB4rB,SAAS,CAACtU,WAAV,IAAyBsU,SAAS,CAACvxB,IAAnC,IAA2C,WAHxB,CADzB,GAMI,KAAK,CANT;AAOD;;AACD,cAAI8qB,cAAc,CAACyL,GAAf,KAAuB,IAA3B,EAAiC;AAC/B,gBAAIxL,IAAI,GAAG,EAAX;AACA,gBAAId,SAAS,GAAGe,mCAAmC,EAAnD;;AACA,gBAAIf,SAAJ,EAAe;AACbc,cAAAA,IAAI,IAAI,qCAAqCd,SAArC,GAAiD,IAAzD;AACD;;AAED,gBAAIgqB,UAAU,GAAGhqB,SAAS,IAAIa,cAAc,CAACsD,QAA5B,IAAwC,EAAzD;AACA,gBAAI8lB,WAAW,GAAGppB,cAAc,CAACF,YAAjC;;AACA,gBAAIspB,WAAJ,EAAiB;AACfD,cAAAA,UAAU,GAAGC,WAAW,CAAC/pB,QAAZ,GAAuB,GAAvB,GAA6B+pB,WAAW,CAAC1pB,UAAtD;AACD;;AACD,gBAAI,CAAC6nB,yBAAyB,CAAC4B,UAAD,CAA9B,EAA4C;AAC1C5B,cAAAA,yBAAyB,CAAC4B,UAAD,CAAzB,GAAwC,IAAxC;AACA/R,cAAAA,SAAS,CACP,KADO,EAEP,yDACE,0CAHK,EAIPnX,IAJO,CAAT;AAMD;AACF;;AAED,cAAI,OAAOwG,SAAS,CAACuV,wBAAjB,KAA8C,UAAlD,EAA8D;AAC5D,gBAAIoD,cAAc,GAAGltB,gBAAgB,CAACuU,SAAD,CAAhB,IAA+B,SAApD;;AAEA,gBAAI,CAAC6gB,gDAAgD,CAAClI,cAAD,CAArD,EAAuE;AACrEvkC,cAAAA,qBAAqB,CACnB,KADmB,EAEnB,8EAFmB,EAGnBukC,cAHmB,CAArB;AAKAkI,cAAAA,gDAAgD,CAC9ClI,cAD8C,CAAhD,GAEI,IAFJ;AAGD;AACF;AACF;AACDoI,QAAAA,iBAAiB,CAAC7G,UAAD,EAAa3gB,cAAb,EAA6B5P,KAA7B,EAAoCsjB,oBAApC,CAAjB;AACAmU,QAAAA,YAAY,CAAC7nB,cAAD,EAAiB7hB,KAAjB,CAAZ;AACA,eAAO6hB,cAAc,CAACnL,KAAtB;AACD;AACF;;AAED,aAASw0B,0BAAT,CACE1I,UADF,EAEE3gB,cAFF,EAGE0T,oBAHF,EAIE;AACA,UAAI9S,cAAJ,EAAoB;AAClB,YAAI9J,SAAS,GAAGkJ,cAAc,CAACuL,YAA/B;AAIA,YAAI+d,eAAe,GAAG,CAACtpB,cAAc,CAAC/L,SAAf,GAA2Bf,UAA5B,MAA4CR,QAAlE;AAEA,YAAI62B,cAAc,GAAG,KAAK,CAA1B;;AACA,YAAI5I,UAAU,KAAK,IAAf,IAAuB3gB,cAAc,CAAC2L,WAAf,KAA+B,IAA1D,EAAgE;AAG9D3L,UAAAA,cAAc,CAAC2L,WAAf,GAA6B,IAA7B;AACA4d,UAAAA,cAAc,GAAG,IAAjB;AAGA/B,UAAAA,iBAAiB,CAAC7G,UAAD,EAAa3gB,cAAb,EAA6B,IAA7B,EAAmC0T,oBAAnC,CAAjB;AACAiN,UAAAA,UAAU,CAAC9rB,KAAX,GAAmB,IAAnB;AAID,SAZD,MAYO;AACL00B,UAAAA,cAAc,GAAG,CAACD,eAAlB;AACD;;AAED,YAAI,CAACtpB,cAAc,CAACwL,IAAf,GAAsBX,UAAvB,MAAuCnY,QAA3C,EAAqD;AACnD,cAAI62B,cAAJ,EAAoB;AAGlBvpB,YAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD,WAJD,MAIO;AAGLmN,YAAAA,cAAc,CAACzhB,SAAf,GAA2B,IAA3B;AACD;AACF;;AAID,YAAIuf,QAAQ,GAAGhH,SAAS,CAACgH,QAAzB;AACA,YAAI2pB,YAAY,GAAG,KAAK,CAAxB;;AACA,YAAI,OAAO3pB,QAAP,KAAoB,UAAxB,EAAoC;AAClC2pB,UAAAA,YAAY,GAAG3pB,QAAQ,CAACyrB,cAAD,CAAvB;AACD,SAFD,MAEO;AACL9B,UAAAA,YAAY,GAAG8B,cAAc,GAAGzyB,SAAS,CAAC0yB,QAAb,GAAwB1rB,QAArD;AACD;;AAEDkC,QAAAA,cAAc,CAAC0L,aAAf,GAA+B5U,SAA/B;AACAkJ,QAAAA,cAAc,CAAC4L,aAAf,GAA+B2d,cAA/B;AACA/B,QAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMA,eAAO1T,cAAc,CAACnL,KAAtB;AACD,OAvDD,MAuDO;AACL,eAAO,IAAP;AACD;AACF;;AAED,aAAS40B,qBAAT,CACE9I,UADF,EAEE3gB,cAFF,EAGE0T,oBAHF,EAIE;AACA8F,MAAAA,iBAAiB,CAACxZ,cAAD,EAAiBA,cAAc,CAACzhB,SAAf,CAAyBue,aAA1C,CAAjB;AACA,UAAI2qB,YAAY,GAAGznB,cAAc,CAACuL,YAAlC;;AACA,UAAIoV,UAAU,KAAK,IAAnB,EAAyB;AAMvB3gB,QAAAA,cAAc,CAACnL,KAAf,GAAuBswB,oBAAoB,CACzCnlB,cADyC,EAEzC,IAFyC,EAGzCynB,YAHyC,EAIzC/T,oBAJyC,CAA3C;AAMAmU,QAAAA,YAAY,CAAC7nB,cAAD,EAAiBynB,YAAjB,CAAZ;AACD,OAbD,MAaO;AACLD,QAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGfynB,YAHe,EAIf/T,oBAJe,CAAjB;AAMAmU,QAAAA,YAAY,CAAC7nB,cAAD,EAAiBynB,YAAjB,CAAZ;AACD;;AACD,aAAOznB,cAAc,CAACnL,KAAtB;AACD;;AAED,aAAS60B,qBAAT,CACE/I,UADF,EAEE3gB,cAFF,EAGE0T,oBAHF,EAIE;AACA,UAAIiW,YAAY,GAAG3pB,cAAc,CAAC7jB,IAAlC;AACA,UAAI7G,OAAO,GAAGq0C,YAAY,CAAC9R,QAA3B;AAEA,UAAI5a,QAAQ,GAAG+C,cAAc,CAACuL,YAA9B;AACA,UAAIvO,QAAQ,GAAGgD,cAAc,CAAC0L,aAA9B;AAEA,UAAI2M,QAAQ,GAAGpb,QAAQ,CAAC7M,KAAxB;AACA4P,MAAAA,cAAc,CAAC0L,aAAf,GAA+BzO,QAA/B;AAEA;AACE,YAAI2sB,iBAAiB,GAAG5pB,cAAc,CAAC7jB,IAAf,CAAoBmhC,SAA5C;;AAEA,YAAIsM,iBAAJ,EAAuB;AACrB71C,UAAAA,cAAc,CACZ61C,iBADY,EAEZ3sB,QAFY,EAGZ,MAHY,EAIZ,kBAJY,EAKZkD,yBALY,CAAd;AAOD;AACF;AAEDwX,MAAAA,YAAY,CAAC3X,cAAD,EAAiBqY,QAAjB,CAAZ;;AAEA,UAAIrb,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAIsb,QAAQ,GAAGtb,QAAQ,CAAC5M,KAAxB;AACA,YAAImoB,WAAW,GAAGH,oBAAoB,CAAC9iC,OAAD,EAAU+iC,QAAV,EAAoBC,QAApB,CAAtC;;AACA,YAAIC,WAAW,KAAK,CAApB,EAAuB;AAErB,cAAIvb,QAAQ,CAACc,QAAT,KAAsBb,QAAQ,CAACa,QAA/B,IAA2C,CAACqJ,iBAAiB,EAAjE,EAAqE;AACnE,mBAAOygB,4BAA4B,CACjCjH,UADiC,EAEjC3gB,cAFiC,EAGjC0T,oBAHiC,CAAnC;AAKD;AACF,SATD,MASO;AAGL+E,UAAAA,sBAAsB,CACpBzY,cADoB,EAEpB1qB,OAFoB,EAGpBijC,WAHoB,EAIpB7E,oBAJoB,CAAtB;AAMD;AACF;;AAED,UAAImQ,WAAW,GAAG5mB,QAAQ,CAACa,QAA3B;AACA0pB,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGf6jB,WAHe,EAIfnQ,oBAJe,CAAjB;AAMA,aAAO1T,cAAc,CAACnL,KAAtB;AACD;;AAED,aAASg1B,qBAAT,CACElJ,UADF,EAEE3gB,cAFF,EAGE0T,oBAHF,EAIE;AACA,UAAIp+B,OAAO,GAAG0qB,cAAc,CAAC7jB,IAA7B;AACA,UAAI8gB,QAAQ,GAAG+C,cAAc,CAACuL,YAA9B;AACA,UAAIjZ,MAAM,GAAG2K,QAAQ,CAACa,QAAtB;AAEA;AACE,UAAE,OAAOxL,MAAP,KAAkB,UAApB,IACIzX,qBAAqB,CACnB,KADmB,EAEnB,wEACE,mEADF,GAEE,kEAFF,GAGE,iDALiB,CADzB,GAQI,KAAK,CART;AASD;AAEDg+B,MAAAA,oBAAoB,CAAC7Y,cAAD,EAAiB0T,oBAAjB,CAApB;AACA,UAAI2E,QAAQ,GAAGS,WAAW,CAACxjC,OAAD,EAAU2nB,QAAQ,CAAC6sB,qBAAnB,CAA1B;AACA,UAAIjG,WAAW,GAAG,KAAK,CAAvB;AACA;AACEuD,QAAAA,mBAAmB,CAACnqC,OAApB,GAA8B+iB,cAA9B;AACAO,QAAAA,eAAe,CAAC,QAAD,CAAf;AACAsjB,QAAAA,WAAW,GAAGvxB,MAAM,CAAC+lB,QAAD,CAApB;AACA9X,QAAAA,eAAe,CAAC,IAAD,CAAf;AACD;AAGDP,MAAAA,cAAc,CAAC/L,SAAf,IAA4BtB,aAA5B;AACA60B,MAAAA,iBAAiB,CACf7G,UADe,EAEf3gB,cAFe,EAGf6jB,WAHe,EAIfnQ,oBAJe,CAAjB;AAMA1T,MAAAA,cAAc,CAAC0L,aAAf,GAA+BzO,QAA/B;AACA,aAAO+C,cAAc,CAACnL,KAAtB;AACD;;AAqBD,aAAS+yB,4BAAT,CACEjH,UADF,EAEE3gB,cAFF,EAGE0T,oBAHF,EAIE;AACAlP,MAAAA,eAAe,CAACxE,cAAD,CAAf;;AAEA,UAAI2gB,UAAU,KAAK,IAAnB,EAAyB;AAEvB3gB,QAAAA,cAAc,CAAC6L,sBAAf,GAAwC8U,UAAU,CAAC9U,sBAAnD;AACD;;AAED,UAAI5K,mBAAJ,EAAyB;AAEvBoZ,QAAAA,0BAA0B,CAACra,cAAD,CAA1B;AACD;;AAGD,UAAIiM,mBAAmB,GAAGjM,cAAc,CAACiM,mBAAzC;;AACA,UACEA,mBAAmB,KAAK3C,MAAxB,IACA2C,mBAAmB,GAAGyH,oBAFxB,EAGE;AAIA,eAAO,IAAP;AACD,OARD,MAQO;AAGL8R,QAAAA,gBAAgB,CAAC7E,UAAD,EAAa3gB,cAAb,CAAhB;AACA,eAAOA,cAAc,CAACnL,KAAtB;AACD;AACF;;AAGD,aAASgzB,YAAT,CAAsB7nB,cAAtB,EAAsClJ,SAAtC,EAAiD;AAC/CkJ,MAAAA,cAAc,CAAC0L,aAAf,GAA+B5U,SAA/B;AACD;;AAED,aAASwxB,YAAT,CAAsBtoB,cAAtB,EAAsC0oB,SAAtC,EAAiD;AAC/C1oB,MAAAA,cAAc,CAAC4L,aAAf,GAA+B8c,SAA/B;AAGD;;AAED,aAASqB,SAAT,CAAmBpJ,UAAnB,EAA+B3gB,cAA/B,EAA+C0T,oBAA/C,EAAqE;AACnE,UAAI2C,oBAAoB,GAAGrW,cAAc,CAACsE,cAA1C;;AACA,UACE,CAAC6C,iBAAiB,EAAlB,KACCkP,oBAAoB,KAAK/M,MAAzB,IACC+M,oBAAoB,GAAG3C,oBAFzB,CADF,EAIE;AAIA,gBAAQ1T,cAAc,CAAC/hB,GAAvB;AACE,eAAKsB,QAAL;AACEgpC,YAAAA,mBAAmB,CAACvoB,cAAD,CAAnB;AACA8mB,YAAAA,mBAAmB;AACnB;;AACF,eAAKrnC,aAAL;AACEo6B,YAAAA,eAAe,CAAC7Z,cAAD,CAAf;AACA;;AACF,eAAK5gB,cAAL;AAAqB;AACnB,kBAAIqnB,SAAS,GAAGzG,cAAc,CAAC7jB,IAA/B;;AACA,kBAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChCqB,gBAAAA,mBAAmB,CAAC9H,cAAD,CAAnB;AACD;;AACD;AACD;;AACD,eAAK3gB,kBAAL;AAAyB;AACvB,kBAAIyS,QAAQ,GAAGkO,cAAc,CAAC7jB,IAA9B;;AACA,kBAAIisB,UAAU,GAAGvW,6BAA6B,CAACC,QAAD,CAA9C;;AACA,kBAAI6U,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjCN,gBAAAA,mBAAmB,CAAC9H,cAAD,CAAnB;AACD;;AACD;AACD;;AACD,eAAKxgB,UAAL;AACEg6B,YAAAA,iBAAiB,CACfxZ,cADe,EAEfA,cAAc,CAACzhB,SAAf,CAAyBue,aAFV,CAAjB;AAIA;;AACF,eAAKhd,eAAL;AAAsB;AACpB,kBAAIu4B,QAAQ,GAAGrY,cAAc,CAAC0L,aAAf,CAA6Btb,KAA5C;AACAunB,cAAAA,YAAY,CAAC3X,cAAD,EAAiBqY,QAAjB,CAAZ;AACA;AACD;;AACD,eAAKp4B,QAAL;AACE,gBAAIghB,mBAAJ,EAAyB;AACvBjB,cAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AACD;AAtCJ;;AAwCA,eAAO+0B,4BAA4B,CACjCjH,UADiC,EAEjC3gB,cAFiC,EAGjC0T,oBAHiC,CAAnC;AAKD;;AAGD1T,MAAAA,cAAc,CAACsE,cAAf,GAAgCgF,MAAhC;;AAEA,cAAQtJ,cAAc,CAAC/hB,GAAvB;AACE,aAAKqB,sBAAL;AAA6B;AAC3B,gBAAI0qC,WAAW,GAAGhqB,cAAc,CAAC7jB,IAAjC;AACA,mBAAO6sC,2BAA2B,CAChCrI,UADgC,EAEhC3gB,cAFgC,EAGhCgqB,WAHgC,EAIhCtW,oBAJgC,CAAlC;AAMD;;AACD,aAAKx0B,mBAAL;AAA0B;AACxB,gBAAI+qC,WAAW,GAAGjqB,cAAc,CAAC7jB,IAAjC;AACA,gBAAI+tC,gBAAgB,GAAGlqB,cAAc,CAACuL,YAAtC;AACA,mBAAO0c,yBAAyB,CAC9BtH,UAD8B,EAE9B3gB,cAF8B,EAG9BiqB,WAH8B,EAI9BC,gBAJ8B,EAK9BxW,oBAL8B,CAAhC;AAOD;;AACD,aAAKv0B,uBAAL;AAA8B;AAC5B,gBAAIgrC,UAAU,GAAGnqB,cAAc,CAAC7jB,IAAhC;;AACA,gBAAIiuC,WAAW,GAAGv4B,6BAA6B,CAACs4B,UAAD,CAA/C;;AACA,gBAAIE,iBAAiB,GAAGrqB,cAAc,CAACuL,YAAvC;;AACA,gBAAIvW,MAAM,GAAGizB,yBAAyB,CACpCtH,UADoC,EAEpC3gB,cAFoC,EAGpCoqB,WAHoC,EAIpCtB,mBAAmB,CAACsB,WAAD,EAAcC,iBAAd,CAJiB,EAKpC3W,oBALoC,CAAtC;;AAOA1T,YAAAA,cAAc,CAAC0L,aAAf,GAA+B2e,iBAA/B;AACA,mBAAOr1B,MAAP;AACD;;AACD,aAAK5V,cAAL;AAAqB;AACnB,gBAAIkrC,WAAW,GAAGtqB,cAAc,CAAC7jB,IAAjC;AACA,gBAAIouC,iBAAiB,GAAGvqB,cAAc,CAACuL,YAAvC;AACA,mBAAO2c,oBAAoB,CACzBvH,UADyB,EAEzB3gB,cAFyB,EAGzBsqB,WAHyB,EAIzBC,iBAJyB,EAKzB7W,oBALyB,CAA3B;AAOD;;AACD,aAAKr0B,kBAAL;AAAyB;AACvB,gBAAImrC,UAAU,GAAGxqB,cAAc,CAAC7jB,IAAhC;;AACA,gBAAIsuC,WAAW,GAAG54B,6BAA6B,CAAC24B,UAAD,CAA/C;;AACA,gBAAIE,iBAAiB,GAAG1qB,cAAc,CAACuL,YAAvC;;AACA,gBAAIof,OAAO,GAAGzC,oBAAoB,CAChCvH,UADgC,EAEhC3gB,cAFgC,EAGhCyqB,WAHgC,EAIhC3B,mBAAmB,CAAC2B,WAAD,EAAcC,iBAAd,CAJa,EAKhChX,oBALgC,CAAlC;;AAOA1T,YAAAA,cAAc,CAAC0L,aAAf,GAA+Bgf,iBAA/B;AACA,mBAAOC,OAAP;AACD;;AACD,aAAKprC,QAAL;AACE,iBAAOipC,cAAc,CAAC7H,UAAD,EAAa3gB,cAAb,EAA6B0T,oBAA7B,CAArB;;AACF,aAAKj0B,aAAL;AACE,iBAAOkpC,mBAAmB,CACxBhI,UADwB,EAExB3gB,cAFwB,EAGxB0T,oBAHwB,CAA1B;;AAKF,aAAKh0B,QAAL;AACE,iBAAOmpC,cAAc,CAAClI,UAAD,EAAa3gB,cAAb,CAArB;;AACF,aAAK9f,oBAAL;AACE,iBAAOmpC,0BAA0B,CAC/B1I,UAD+B,EAE/B3gB,cAF+B,EAG/B0T,oBAH+B,CAAjC;;AAKF,aAAKl0B,UAAL;AACE,iBAAOiqC,qBAAqB,CAC1B9I,UAD0B,EAE1B3gB,cAF0B,EAG1B0T,oBAH0B,CAA5B;;AAKF,aAAK3zB,UAAL;AAAiB;AACf,gBAAI5D,IAAI,GAAG6jB,cAAc,CAAC7jB,IAA1B;AACA,mBAAOurC,gBAAgB,CACrB/G,UADqB,EAErB3gB,cAFqB,EAGrB7jB,IAHqB,EAIrB6jB,cAAc,CAACuL,YAJM,EAKrBmI,oBALqB,CAAvB;AAOD;;AACD,aAAK1zB,cAAL;AACE,cAAI4qC,SAAS,GAAG5qB,cAAc,CAAC7jB,IAA/B;;AACA,cAAI0uC,WAAW,GAAGh5B,6BAA6B,CAAC+4B,SAAD,CAA/C;;AACA,cAAIE,eAAe,GAAG9qB,cAAc,CAACuL,YAArC;AACA,cAAI1W,KAAK,GAAG6yB,gBAAgB,CAC1B/G,UAD0B,EAE1B3gB,cAF0B,EAG1B6qB,WAH0B,EAI1B/B,mBAAmB,CAAC+B,WAAD,EAAcC,eAAd,CAJO,EAK1BpX,oBAL0B,CAA5B;AAOA1T,UAAAA,cAAc,CAAC0L,aAAf,GAA+Bof,eAA/B;AACA,iBAAOj2B,KAAP;;AACF,aAAKlV,QAAL;AACE,iBAAOijC,cAAc,CAACjC,UAAD,EAAa3gB,cAAb,EAA6B0T,oBAA7B,CAArB;;AACF,aAAK9zB,IAAL;AACE,iBAAOkoC,UAAU,CAACnH,UAAD,EAAa3gB,cAAb,EAA6B0T,oBAA7B,CAAjB;;AACF,aAAKzzB,QAAL;AACE,iBAAO8nC,cAAc,CAACpH,UAAD,EAAa3gB,cAAb,EAA6B0T,oBAA7B,CAArB;;AACF,aAAK5zB,eAAL;AACE,iBAAO4pC,qBAAqB,CAC1B/I,UAD0B,EAE1B3gB,cAF0B,EAG1B0T,oBAH0B,CAA5B;;AAKF,aAAK7zB,eAAL;AACE,iBAAOgqC,qBAAqB,CAC1BlJ,UAD0B,EAE1B3gB,cAF0B,EAG1B0T,oBAH0B,CAA5B;;AAKF;AACEp/B,UAAAA,SAAS,CACP,KADO,EAEP,uEACE,8BAHK,CAAT;AA5HJ;AAkID;;AAED,aAASy2C,UAAT,CAAoB/qB,cAApB,EAAoC;AAGlCA,MAAAA,cAAc,CAAC/L,SAAf,IAA4BpB,MAA5B;AACD;;AAED,aAASm4B,SAAT,CAAmBhrB,cAAnB,EAAmC;AACjCA,MAAAA,cAAc,CAAC/L,SAAf,IAA4Bd,GAA5B;AACD;;AAED,aAAS83B,iBAAT,CAA2B/1B,MAA3B,EAAmC8K,cAAnC,EAAmD;AAGjD,UAAIhM,IAAI,GAAGgM,cAAc,CAACnL,KAA1B;;AACA,aAAOb,IAAI,KAAK,IAAhB,EAAsB;AACpB,YAAIA,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAA/C,EAAyD;AACvDic,UAAAA,kBAAkB,CAACzG,MAAD,EAASlB,IAAI,CAACzV,SAAd,CAAlB;AACD,SAFD,MAEO,IAAIyV,IAAI,CAAC/V,GAAL,KAAauB,UAAjB,EAA6B,CAInC,CAJM,MAIA,IAAIwU,IAAI,CAACa,KAAL,KAAe,IAAnB,EAAyB;AAC9Bb,UAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,UAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;;AACD,YAAIb,IAAI,KAAKgM,cAAb,EAA6B;AAC3B;AACD;;AACD,eAAOhM,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,cAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC5T,MAAL,KAAgB4f,cAA5C,EAA4D;AAC1D;AACD;;AACDhM,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;AACF;;AAED,QAAIo2B,mBAAmB,GAAG,KAAK,CAA/B;AACA,QAAIC,qBAAqB,GAAG,KAAK,CAAjC;AACA,QAAIC,gBAAgB,GAAG,KAAK,CAA5B;;AACA,QAAIztB,gBAAJ,EAAsB;AAGpButB,MAAAA,mBAAmB,GAAG,6BAASlrB,cAAT,EAAyB,CAE9C,CAFD;;AAGAmrB,MAAAA,qBAAqB,GAAG,+BACtBluC,OADsB,EAEtB+iB,cAFsB,EAGtB7jB,IAHsB,EAItB8gB,QAJsB,EAKtBnB,qBALsB,EAMtB;AAGA,YAAIkB,QAAQ,GAAG/f,OAAO,CAACyuB,aAAvB;;AACA,YAAI1O,QAAQ,KAAKC,QAAjB,EAA2B;AAGzB;AACD;;AAMD,YAAIjY,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;AACA,YAAI8sC,kBAAkB,GAAGzR,cAAc,EAAvC;AAIA,YAAIjkB,aAAa,GAAGoH,aAAa,CAC/B/X,QAD+B,EAE/B7I,IAF+B,EAG/B6gB,QAH+B,EAI/BC,QAJ+B,EAK/BnB,qBAL+B,EAM/BuvB,kBAN+B,CAAjC;AASArrB,QAAAA,cAAc,CAAC2L,WAAf,GAA6BhW,aAA7B;;AAGA,YAAIA,aAAJ,EAAmB;AACjBo1B,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;AACF,OAxCD;;AAyCAorB,MAAAA,gBAAgB,GAAG,0BAASnuC,OAAT,EAAkB+iB,cAAlB,EAAkC5B,OAAlC,EAA2CC,OAA3C,EAAoD;AAErE,YAAID,OAAO,KAAKC,OAAhB,EAAyB;AACvB0sB,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;AACF,OALD;AAMD,KArDD,MAqDO,IAAI/F,mBAAJ,EAAyB;AAI9B,UAAIqxB,4BAA4B,GAAG,SAA/BA,4BAA+B,CACjCC,iBADiC,EAEjCvrB,cAFiC,EAGjC;AAGA,YAAIhM,IAAI,GAAGgM,cAAc,CAACnL,KAA1B;;AACA,eAAOb,IAAI,KAAK,IAAhB,EAAsB;AACpB,cAAIA,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAA/C,EAAyD;AACvD0a,YAAAA,8BAA8B,CAACmxB,iBAAD,EAAoBv3B,IAAI,CAACzV,SAAzB,CAA9B;AACD,WAFD,MAEO,IAAIyV,IAAI,CAAC/V,GAAL,KAAauB,UAAjB,EAA6B,CAInC,CAJM,MAIA,IAAIwU,IAAI,CAACa,KAAL,KAAe,IAAnB,EAAyB;AAC9Bb,YAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,YAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;;AACD,cAAIb,IAAI,KAAKgM,cAAb,EAA6B;AAC3B;AACD;;AACD,iBAAOhM,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,gBAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC5T,MAAL,KAAgB4f,cAA5C,EAA4D;AAC1D;AACD;;AACDhM,YAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,UAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,UAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;AACF,OA/BD;;AAgCAo2B,MAAAA,mBAAmB,GAAG,6BAASlrB,cAAT,EAAyB;AAC7C,YAAIwrB,YAAY,GAAGxrB,cAAc,CAACzhB,SAAlC;AACA,YAAIktC,iBAAiB,GAAGzrB,cAAc,CAAC+L,WAAf,KAA+B,IAAvD;;AACA,YAAI0f,iBAAJ,EAAuB,CAEtB,CAFD,MAEO;AACL,cAAIC,SAAS,GAAGF,YAAY,CAAC1uB,aAA7B;AACA,cAAI6uB,WAAW,GAAGxxB,uBAAuB,CAACuxB,SAAD,CAAzC;AAEAJ,UAAAA,4BAA4B,CAACK,WAAD,EAAc3rB,cAAd,CAA5B;AACAwrB,UAAAA,YAAY,CAAC3d,eAAb,GAA+B8d,WAA/B;AAEAZ,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACA3F,UAAAA,yBAAyB,CAACqxB,SAAD,EAAYC,WAAZ,CAAzB;AACD;AACF,OAfD;;AAgBAR,MAAAA,qBAAqB,GAAG,+BACtBluC,OADsB,EAEtB+iB,cAFsB,EAGtB7jB,IAHsB,EAItB8gB,QAJsB,EAKtBnB,qBALsB,EAMtB;AACA,YAAI8vB,eAAe,GAAG3uC,OAAO,CAACsB,SAA9B;AACA,YAAIye,QAAQ,GAAG/f,OAAO,CAACyuB,aAAvB;AAGA,YAAI+f,iBAAiB,GAAGzrB,cAAc,CAAC+L,WAAf,KAA+B,IAAvD;;AACA,YAAI0f,iBAAiB,IAAIzuB,QAAQ,KAAKC,QAAtC,EAAgD;AAG9C+C,UAAAA,cAAc,CAACzhB,SAAf,GAA2BqtC,eAA3B;AACA;AACD;;AACD,YAAIC,kBAAkB,GAAG7rB,cAAc,CAACzhB,SAAxC;AACA,YAAI8sC,kBAAkB,GAAGzR,cAAc,EAAvC;AACA,YAAIjkB,aAAa,GAAG,IAApB;;AACA,YAAIqH,QAAQ,KAAKC,QAAjB,EAA2B;AACzBtH,UAAAA,aAAa,GAAGoH,aAAa,CAC3B8uB,kBAD2B,EAE3B1vC,IAF2B,EAG3B6gB,QAH2B,EAI3BC,QAJ2B,EAK3BnB,qBAL2B,EAM3BuvB,kBAN2B,CAA7B;AAQD;;AACD,YAAII,iBAAiB,IAAI91B,aAAa,KAAK,IAA3C,EAAiD;AAG/CqK,UAAAA,cAAc,CAACzhB,SAAf,GAA2BqtC,eAA3B;AACA;AACD;;AACD,YAAIE,WAAW,GAAG5xB,aAAa,CAC7B0xB,eAD6B,EAE7Bj2B,aAF6B,EAG7BxZ,IAH6B,EAI7B6gB,QAJ6B,EAK7BC,QAL6B,EAM7B+C,cAN6B,EAO7ByrB,iBAP6B,EAQ7BI,kBAR6B,CAA/B;;AAUA,YACExvB,uBAAuB,CACrByvB,WADqB,EAErB3vC,IAFqB,EAGrB8gB,QAHqB,EAIrBnB,qBAJqB,EAKrBuvB,kBALqB,CADzB,EAQE;AACAN,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;;AACDA,QAAAA,cAAc,CAACzhB,SAAf,GAA2ButC,WAA3B;;AACA,YAAIL,iBAAJ,EAAuB;AAIrBV,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD,SALD,MAKO;AAELirB,UAAAA,iBAAiB,CAACa,WAAD,EAAc9rB,cAAd,CAAjB;AACD;AACF,OApED;;AAqEAorB,MAAAA,gBAAgB,GAAG,0BAASnuC,OAAT,EAAkB+iB,cAAlB,EAAkC5B,OAAlC,EAA2CC,OAA3C,EAAoD;AACrE,YAAID,OAAO,KAAKC,OAAhB,EAAyB;AAEvB,cAAIvC,qBAAqB,GAAGwd,oBAAoB,EAAhD;AACA,cAAI+R,kBAAkB,GAAGzR,cAAc,EAAvC;AACA5Z,UAAAA,cAAc,CAACzhB,SAAf,GAA2B4d,kBAAkB,CAC3CkC,OAD2C,EAE3CvC,qBAF2C,EAG3CuvB,kBAH2C,EAI3CrrB,cAJ2C,CAA7C;AAQA+qB,UAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;AACF,OAfD;AAgBD,KAzIM,MAyIA;AAELkrB,MAAAA,mBAAmB,GAAG,6BAASlrB,cAAT,EAAyB,CAE9C,CAFD;;AAGAmrB,MAAAA,qBAAqB,GAAG,+BACtBluC,OADsB,EAEtB+iB,cAFsB,EAGtB7jB,IAHsB,EAItB8gB,QAJsB,EAKtBnB,qBALsB,EAMtB,CAED,CARD;;AASAsvB,MAAAA,gBAAgB,GAAG,0BAASnuC,OAAT,EAAkB+iB,cAAlB,EAAkC5B,OAAlC,EAA2CC,OAA3C,EAAoD,CAEtE,CAFD;AAGD;;AAED,aAAS0tB,YAAT,CAAsB9uC,OAAtB,EAA+B+iB,cAA/B,EAA+C0T,oBAA/C,EAAqE;AACnE,UAAIzW,QAAQ,GAAG+C,cAAc,CAACuL,YAA9B;;AAEA,cAAQvL,cAAc,CAAC/hB,GAAvB;AACE,aAAKiB,mBAAL;AACA,aAAKC,uBAAL;AACE;;AACF,aAAKC,cAAL;AAAqB;AACnB,gBAAIqnB,SAAS,GAAGzG,cAAc,CAAC7jB,IAA/B;;AACA,gBAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChCY,cAAAA,UAAU,CAACrH,cAAD,CAAV;AACD;;AACD;AACD;;AACD,aAAK3gB,kBAAL;AAAyB;AACvB,gBAAI+oB,UAAU,GAAGvW,6BAA6B,CAACmO,cAAc,CAAC7jB,IAAhB,CAA9C;;AACA,gBAAIwqB,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjCf,cAAAA,UAAU,CAACrH,cAAD,CAAV;AACD;;AACD;AACD;;AACD,aAAKzgB,QAAL;AAAe;AACbo6B,YAAAA,gBAAgB,CAAC3Z,cAAD,CAAhB;AACAsH,YAAAA,wBAAwB,CAACtH,cAAD,CAAxB;AACA,gBAAIgsB,SAAS,GAAGhsB,cAAc,CAACzhB,SAA/B;;AACA,gBAAIytC,SAAS,CAACrd,cAAd,EAA8B;AAC5Bqd,cAAAA,SAAS,CAAC12C,OAAV,GAAoB02C,SAAS,CAACrd,cAA9B;AACAqd,cAAAA,SAAS,CAACrd,cAAV,GAA2B,IAA3B;AACD;;AACD,gBAAI1xB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAAC4X,KAAR,KAAkB,IAA1C,EAAgD;AAG9CgyB,cAAAA,iBAAiB,CAAC7mB,cAAD,CAAjB;AAGAA,cAAAA,cAAc,CAAC/L,SAAf,IAA4B,CAACrB,SAA7B;AACD;;AACDs4B,YAAAA,mBAAmB,CAAClrB,cAAD,CAAnB;AACA;AACD;;AACD,aAAKvgB,aAAL;AAAoB;AAClBs6B,YAAAA,cAAc,CAAC/Z,cAAD,CAAd;AACA,gBAAIlE,qBAAqB,GAAGwd,oBAAoB,EAAhD;AACA,gBAAIn9B,IAAI,GAAG6jB,cAAc,CAAC7jB,IAA1B;;AACA,gBAAIc,OAAO,KAAK,IAAZ,IAAoB+iB,cAAc,CAACzhB,SAAf,IAA4B,IAApD,EAA0D;AACxD4sC,cAAAA,qBAAqB,CACnBluC,OADmB,EAEnB+iB,cAFmB,EAGnB7jB,IAHmB,EAInB8gB,QAJmB,EAKnBnB,qBALmB,CAArB;;AAQA,kBAAI7e,OAAO,CAACwuB,GAAR,KAAgBzL,cAAc,CAACyL,GAAnC,EAAwC;AACtCuf,gBAAAA,SAAS,CAAChrB,cAAD,CAAT;AACD;AACF,aAZD,MAYO;AACL,kBAAI,CAAC/C,QAAL,EAAe;AACb3oB,gBAAAA,SAAS,CACP0rB,cAAc,CAACzhB,SAAf,KAA6B,IADtB,EAEP,iEACE,iDAHK,CAAT;AAMA;AACD;;AAED,kBAAI8sC,kBAAkB,GAAGzR,cAAc,EAAvC;AAKA,kBAAIqS,WAAW,GAAGpF,iBAAiB,CAAC7mB,cAAD,CAAnC;;AACA,kBAAIisB,WAAJ,EAAiB;AAGf,oBACEvF,4BAA4B,CAC1B1mB,cAD0B,EAE1BlE,qBAF0B,EAG1BuvB,kBAH0B,CAD9B,EAME;AAGAN,kBAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;AACF,eAdD,MAcO;AACL,oBAAIhb,QAAQ,GAAG6W,cAAc,CAC3B1f,IAD2B,EAE3B8gB,QAF2B,EAG3BnB,qBAH2B,EAI3BuvB,kBAJ2B,EAK3BrrB,cAL2B,CAA7B;AAQAirB,gBAAAA,iBAAiB,CAACjmC,QAAD,EAAWgb,cAAX,CAAjB;;AAKA,oBACE3D,uBAAuB,CACrBrX,QADqB,EAErB7I,IAFqB,EAGrB8gB,QAHqB,EAIrBnB,qBAJqB,EAKrBuvB,kBALqB,CADzB,EAQE;AACAN,kBAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;;AACDA,gBAAAA,cAAc,CAACzhB,SAAf,GAA2ByG,QAA3B;AACD;;AAED,kBAAIgb,cAAc,CAACyL,GAAf,KAAuB,IAA3B,EAAiC;AAE/Buf,gBAAAA,SAAS,CAAChrB,cAAD,CAAT;AACD;AACF;;AACD;AACD;;AACD,aAAKtgB,QAAL;AAAe;AACb,gBAAI2e,OAAO,GAAGpB,QAAd;;AACA,gBAAIhgB,OAAO,IAAI+iB,cAAc,CAACzhB,SAAf,IAA4B,IAA3C,EAAiD;AAC/C,kBAAI6f,OAAO,GAAGnhB,OAAO,CAACyuB,aAAtB;AAGA0f,cAAAA,gBAAgB,CAACnuC,OAAD,EAAU+iB,cAAV,EAA0B5B,OAA1B,EAAmCC,OAAnC,CAAhB;AACD,aALD,MAKO;AACL,kBAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B/pB,gBAAAA,SAAS,CACP0rB,cAAc,CAACzhB,SAAf,KAA6B,IADtB,EAEP,iEACE,iDAHK,CAAT;AAMD;;AACD,kBAAI2tC,sBAAsB,GAAG5S,oBAAoB,EAAjD;;AACA,kBAAI6S,mBAAmB,GAAGvS,cAAc,EAAxC;;AACA,kBAAIwS,YAAY,GAAGvF,iBAAiB,CAAC7mB,cAAD,CAApC;;AACA,kBAAIosB,YAAJ,EAAkB;AAChB,oBAAIzF,gCAAgC,CAAC3mB,cAAD,CAApC,EAAsD;AACpD+qB,kBAAAA,UAAU,CAAC/qB,cAAD,CAAV;AACD;AACF,eAJD,MAIO;AACLA,gBAAAA,cAAc,CAACzhB,SAAf,GAA2B4d,kBAAkB,CAC3CkC,OAD2C,EAE3C6tB,sBAF2C,EAG3CC,mBAH2C,EAI3CnsB,cAJ2C,CAA7C;AAMD;AACF;;AACD;AACD;;AACD,aAAKjgB,UAAL;AACA,aAAKC,cAAL;AACE;;AACF,aAAKE,oBAAL;AACE;;AACF,aAAKP,QAAL;AACE;;AACF,aAAKC,IAAL;AACE;;AACF,aAAKK,QAAL;AACE;;AACF,aAAKT,UAAL;AACEm6B,UAAAA,gBAAgB,CAAC3Z,cAAD,CAAhB;AACAkrB,UAAAA,mBAAmB,CAAClrB,cAAD,CAAnB;AACA;;AACF,aAAKlgB,eAAL;AAEEo4B,UAAAA,WAAW,CAAClY,cAAD,CAAX;AACA;;AACF,aAAKngB,eAAL;AACE;;AAEF,aAAKP,sBAAL;AACEhL,UAAAA,SAAS,CACP,KADO,EAEP,sEACE,oEADF,GAEE,gBAJK,CAAT;;AAOF;AACEA,UAAAA,SAAS,CACP,KADO,EAEP,uEACE,8BAHK,CAAT;AAxLJ;;AA+LA,aAAO,IAAP;AACD;;AAOD,aAAS+3C,eAAT,CAAyBC,aAAzB,EAAwC;AACtC,UAAIC,cAAc,GAAGD,aAAa,CAACC,cAAnC;AAAA,UACEz3C,KAAK,GAAGw3C,aAAa,CAACx3C,KADxB;AAGA,UAAI03C,aAAa,GAAG,KAAK,CAAzB;;AAGA,UAAI13C,KAAK,YAAYT,KAArB,EAA4B;AAC1B,YAAIsG,OAAO,GAAG7F,KAAK,CAAC6F,OAApB;AAAA,YACEzF,IAAI,GAAGJ,KAAK,CAACI,IADf;AAGA,YAAIu3C,OAAO,GAAG9xC,OAAO,GAAGzF,IAAI,GAAG,IAAP,GAAcyF,OAAjB,GAA2BzF,IAAhD;AAEAs3C,QAAAA,aAAa,GAAG13C,KAAhB;;AAEA,YAAI;AACF03C,UAAAA,aAAa,CAAC7xC,OAAd,GACE8xC,OAAO,GAAG,+BAAV,GAA4CF,cAD9C;AAED,SAHD,CAGE,OAAO33C,CAAP,EAAU,CAAE;AACf,OAZD,MAYO,IAAI,OAAOE,KAAP,KAAiB,QAArB,EAA+B;AACpC03C,QAAAA,aAAa,GAAG,IAAIn4C,KAAJ,CACdS,KAAK,GAAG,+BAAR,GAA0Cy3C,cAD5B,CAAhB;AAGD,OAJM,MAIA;AACLC,QAAAA,aAAa,GAAG,IAAIn4C,KAAJ,CAAU,0BAA0Bk4C,cAApC,CAAhB;AACD;;AAEDt4C,MAAAA,iBAAiB,CAACy4C,eAAlB,CAAkCF,aAAlC,EAAiD,KAAjD;AAMA,aAAO,KAAP;AACD;;AAED,aAASG,gBAAT,CAA0BL,aAA1B,EAAyC;AACvC,UAAIM,QAAQ,GAAGP,eAAe,CAACC,aAAD,CAA9B;;AAIA,UAAIM,QAAQ,KAAK,KAAjB,EAAwB;AACtB;AACD;;AAED,UAAI93C,KAAK,GAAGw3C,aAAa,CAACx3C,KAA1B;AACA;AACE,YAAIsuB,aAAa,GAAGkpB,aAAa,CAAClpB,aAAlC;AAAA,YACEmpB,cAAc,GAAGD,aAAa,CAACC,cADjC;AAAA,YAEEM,iBAAiB,GAAGP,aAAa,CAACO,iBAFpC;AAAA,YAGEC,kBAAkB,GAAGR,aAAa,CAACQ,kBAHrC;AAAA,YAIEC,SAAS,GAAGT,aAAa,CAACS,SAJ5B;;AAUA,YAAIj4C,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACsC,gBAA3B,EAA6C;AAC3C,cAAI01C,kBAAkB,IAAIC,SAA1B,EAAqC;AAInC;AACD;;AAKD1yC,UAAAA,OAAO,CAACvF,KAAR,CAAcA,KAAd;AAGD;;AAED,YAAIk4C,oBAAoB,GAAG5pB,aAAa,GACpC,sCAAsCA,aAAtC,GAAsD,cADlB,GAEpC,2DAFJ;AAIA,YAAI6pB,oBAAoB,GAAG,KAAK,CAAhC;;AAEA,YAAIH,kBAAkB,IAAID,iBAA1B,EAA6C;AAC3C,cAAIE,SAAJ,EAAe;AACbE,YAAAA,oBAAoB,GAClB,kEACC,4CAA4CJ,iBAA5C,GAAgE,GADjE,CADF;AAGD,WAJD,MAIO;AACLI,YAAAA,oBAAoB,GAClB,4DACAJ,iBADA,GAEA,KAFA,GAGA,yEAJF;AAKD;AACF,SAZD,MAYO;AACLI,UAAAA,oBAAoB,GAClB,2FACA,kFAFF;AAGD;;AACD,YAAIC,eAAe,GACjB,KACAF,oBADA,GAEAT,cAFA,GAGA,MAHA,IAIC,KAAKU,oBAJN,CADF;AAWA5yC,QAAAA,OAAO,CAACvF,KAAR,CAAco4C,eAAd;AACD;AACF;;AAED,QAAIC,aAAa,GAAG,EAApB;AAEA,QAAIC,yCAAyC,GAAG,IAAhD;AACA;AACEA,MAAAA,yCAAyC,GAAG,IAAIjrB,GAAJ,EAA5C;AACD;;AAED,aAASyqB,QAAT,CAAkBS,QAAlB,EAA4BC,SAA5B,EAAuC;AACrC,UAAIpuB,MAAM,GAAGouB,SAAS,CAACpuB,MAAvB;AACA,UAAIgY,KAAK,GAAGoW,SAAS,CAACpW,KAAtB;;AACA,UAAIA,KAAK,KAAK,IAAV,IAAkBhY,MAAM,KAAK,IAAjC,EAAuC;AACrCgY,QAAAA,KAAK,GAAGnX,2BAA2B,CAACb,MAAD,CAAnC;AACD;;AAED,UAAIotB,aAAa,GAAG;AAClBlpB,QAAAA,aAAa,EAAElE,MAAM,KAAK,IAAX,GAAkBhN,gBAAgB,CAACgN,MAAM,CAAC/iB,IAAR,CAAlC,GAAkD,IAD/C;AAElBowC,QAAAA,cAAc,EAAErV,KAAK,KAAK,IAAV,GAAiBA,KAAjB,GAAyB,EAFvB;AAGlBpiC,QAAAA,KAAK,EAAEw4C,SAAS,CAACl9B,KAHC;AAIlBm9B,QAAAA,aAAa,EAAE,IAJG;AAKlBV,QAAAA,iBAAiB,EAAE,IALD;AAMlBC,QAAAA,kBAAkB,EAAE,KANF;AAOlBC,QAAAA,SAAS,EAAE;AAPO,OAApB;;AAUA,UAAIM,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,CAACpvC,GAAT,KAAiBmB,cAA1C,EAA0D;AACxDktC,QAAAA,aAAa,CAACiB,aAAd,GAA8BF,QAAQ,CAAC9uC,SAAvC;AACA+tC,QAAAA,aAAa,CAACO,iBAAd,GAAkC36B,gBAAgB,CAACm7B,QAAQ,CAAClxC,IAAV,CAAlD;AACAmwC,QAAAA,aAAa,CAACQ,kBAAd,GAAmC,IAAnC;AACAR,QAAAA,aAAa,CAACS,SAAd,GAA0B,IAA1B;AACD;;AAED,UAAI;AACFJ,QAAAA,gBAAgB,CAACL,aAAD,CAAhB;AACD,OAFD,CAEE,OAAO13C,CAAP,EAAU;AAKVglB,QAAAA,UAAU,CAAC,YAAW;AACpB,gBAAMhlB,CAAN;AACD,SAFS,CAAV;AAGD;AACF;;AAED,QAAI44C,iCAAiC,GAAG,SAApCA,iCAAoC,CAAS7M,UAAT,EAAqB37B,QAArB,EAA+B;AACrE2f,MAAAA,eAAe,CAACgc,UAAD,EAAa,sBAAb,CAAf;AACA37B,MAAAA,QAAQ,CAAC7G,KAAT,GAAiBwiC,UAAU,CAACjV,aAA5B;AACA1mB,MAAAA,QAAQ,CAAC0P,KAAT,GAAiBisB,UAAU,CAAC/U,aAA5B;AACA5mB,MAAAA,QAAQ,CAACyoC,oBAAT;AACA7oB,MAAAA,cAAc;AACf,KAND;;AASA,aAAS8oB,8BAAT,CAAwC/M,UAAxC,EAAoD37B,QAApD,EAA8D;AAC5D;AACElN,QAAAA,qBAAqB,CACnB,IADmB,EAEnB01C,iCAFmB,EAGnB,IAHmB,EAInB7M,UAJmB,EAKnB37B,QALmB,CAArB;;AAOA,YAAI9M,cAAc,EAAlB,EAAsB;AACpB,cAAIy1C,YAAY,GAAG31C,gBAAgB,EAAnC;AACA41C,UAAAA,uBAAuB,CAACjN,UAAD,EAAagN,YAAb,CAAvB;AACD;AACF;AACF;;AAED,aAASE,eAAT,CAAyBlN,UAAzB,EAAqC;AACnC,UAAIlV,GAAG,GAAGkV,UAAU,CAAClV,GAArB;;AACA,UAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,YAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B;AACE3zB,YAAAA,qBAAqB,CAAC,IAAD,EAAO2zB,GAAP,EAAY,IAAZ,EAAkB,IAAlB,CAArB;;AACA,gBAAIvzB,cAAc,EAAlB,EAAsB;AACpB,kBAAI41C,QAAQ,GAAG91C,gBAAgB,EAA/B;AACA41C,cAAAA,uBAAuB,CAACjN,UAAD,EAAamN,QAAb,CAAvB;AACD;AACF;AACF,SARD,MAQO;AACLriB,UAAAA,GAAG,CAACxuB,OAAJ,GAAc,IAAd;AACD;AACF;AACF;;AAED,aAAS8wC,8BAAT,CAAwCpN,UAAxC,EAAoDlS,YAApD,EAAkE;AAChE,cAAQA,YAAY,CAACxwB,GAArB;AACE,aAAKmB,cAAL;AACA,aAAKC,kBAAL;AAAyB;AACvB,gBAAIovB,YAAY,CAACxa,SAAb,GAAyBb,QAA7B,EAAuC;AACrC,kBAAIutB,UAAU,KAAK,IAAnB,EAAyB;AACvB,oBAAI9pB,SAAS,GAAG8pB,UAAU,CAACjV,aAA3B;AACA,oBAAIkK,SAAS,GAAG+K,UAAU,CAAC/U,aAA3B;AACAjH,gBAAAA,eAAe,CAAC8J,YAAD,EAAe,yBAAf,CAAf;AACA,oBAAIzpB,QAAQ,GAAGypB,YAAY,CAAClwB,SAA5B;AACAyG,gBAAAA,QAAQ,CAAC7G,KAAT,GAAiBswB,YAAY,CAAC/C,aAA9B;AACA1mB,gBAAAA,QAAQ,CAAC0P,KAAT,GAAiB+Z,YAAY,CAAC7C,aAA9B;AACA,oBAAIoiB,QAAQ,GAAGhpC,QAAQ,CAACq5B,uBAAT,CAAiCxnB,SAAjC,EAA4C+e,SAA5C,CAAf;AACA;AACE,sBAAIqY,UAAU,GAAGb,yCAAjB;;AACA,sBAAIY,QAAQ,KAAK55C,SAAb,IAA0B,CAAC65C,UAAU,CAAC1qB,GAAX,CAAekL,YAAY,CAACtyB,IAA5B,CAA/B,EAAkE;AAChE8xC,oBAAAA,UAAU,CAACzqB,GAAX,CAAeiL,YAAY,CAACtyB,IAA5B;AACAtB,oBAAAA,qBAAqB,CACnB,KADmB,EAEnB,8DACE,gDAHiB,EAInBqX,gBAAgB,CAACuc,YAAY,CAACtyB,IAAd,CAJG,CAArB;AAMD;AACF;AACD6I,gBAAAA,QAAQ,CAACkpC,mCAAT,GAA+CF,QAA/C;AACAppB,gBAAAA,cAAc;AACf;AACF;;AACD;AACD;;AACD,aAAKrlB,QAAL;AACA,aAAKE,aAAL;AACA,aAAKC,QAAL;AACA,aAAKF,UAAL;AAEE;;AACF;AAAS;AACPlL,YAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AA1CH;AA4CD;;AAED,aAAS65C,gBAAT,CACEC,YADF,EAEEzN,UAFF,EAGElS,YAHF,EAIE4f,uBAJF,EAKE;AACA,cAAQ5f,YAAY,CAACxwB,GAArB;AACE,aAAKmB,cAAL;AACA,aAAKC,kBAAL;AAAyB;AACvB,gBAAI2F,QAAQ,GAAGypB,YAAY,CAAClwB,SAA5B;;AACA,gBAAIkwB,YAAY,CAACxa,SAAb,GAAyBpB,MAA7B,EAAqC;AACnC,kBAAI8tB,UAAU,KAAK,IAAnB,EAAyB;AACvBhc,gBAAAA,eAAe,CAAC8J,YAAD,EAAe,mBAAf,CAAf;AACAzpB,gBAAAA,QAAQ,CAAC7G,KAAT,GAAiBswB,YAAY,CAAC/C,aAA9B;AACA1mB,gBAAAA,QAAQ,CAAC0P,KAAT,GAAiB+Z,YAAY,CAAC7C,aAA9B;AACA5mB,gBAAAA,QAAQ,CAACy6B,iBAAT;AACA7a,gBAAAA,cAAc;AACf,eAND,MAMO;AACL,oBAAI/N,SAAS,GAAG8pB,UAAU,CAACjV,aAA3B;AACA,oBAAIkK,SAAS,GAAG+K,UAAU,CAAC/U,aAA3B;AACAjH,gBAAAA,eAAe,CAAC8J,YAAD,EAAe,oBAAf,CAAf;AACAzpB,gBAAAA,QAAQ,CAAC7G,KAAT,GAAiBswB,YAAY,CAAC/C,aAA9B;AACA1mB,gBAAAA,QAAQ,CAAC0P,KAAT,GAAiB+Z,YAAY,CAAC7C,aAA9B;AACA5mB,gBAAAA,QAAQ,CAACs5B,kBAAT,CACEznB,SADF,EAEE+e,SAFF,EAGE5wB,QAAQ,CAACkpC,mCAHX;AAKAtpB,gBAAAA,cAAc;AACf;AACF;;AACD,gBAAI+G,WAAW,GAAG8C,YAAY,CAAC9C,WAA/B;;AACA,gBAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB3mB,cAAAA,QAAQ,CAAC7G,KAAT,GAAiBswB,YAAY,CAAC/C,aAA9B;AACA1mB,cAAAA,QAAQ,CAAC0P,KAAT,GAAiB+Z,YAAY,CAAC7C,aAA9B;AACAgL,cAAAA,iBAAiB,CACfnI,YADe,EAEf9C,WAFe,EAGf3mB,QAHe,EAIfqpC,uBAJe,CAAjB;AAMD;;AACD;AACD;;AACD,aAAK9uC,QAAL;AAAe;AACb,gBAAI+uC,YAAY,GAAG7f,YAAY,CAAC9C,WAAhC;;AACA,gBAAI2iB,YAAY,KAAK,IAArB,EAA2B;AACzB,kBAAIC,SAAS,GAAG,IAAhB;;AACA,kBAAI9f,YAAY,CAAC5Z,KAAb,KAAuB,IAA3B,EAAiC;AAC/B,wBAAQ4Z,YAAY,CAAC5Z,KAAb,CAAmB5W,GAA3B;AACE,uBAAKwB,aAAL;AACE8uC,oBAAAA,SAAS,GAAG3xB,iBAAiB,CAAC6R,YAAY,CAAC5Z,KAAb,CAAmBtW,SAApB,CAA7B;AACA;;AACF,uBAAKa,cAAL;AACA,uBAAKC,kBAAL;AACEkvC,oBAAAA,SAAS,GAAG9f,YAAY,CAAC5Z,KAAb,CAAmBtW,SAA/B;AACA;AAPJ;AASD;;AACDq4B,cAAAA,iBAAiB,CACfnI,YADe,EAEf6f,YAFe,EAGfC,SAHe,EAIfF,uBAJe,CAAjB;AAMD;;AACD;AACD;;AACD,aAAK5uC,aAAL;AAAoB;AAClB,gBAAI+uC,UAAU,GAAG/f,YAAY,CAAClwB,SAA9B;;AAMA,gBAAIoiC,UAAU,KAAK,IAAf,IAAuBlS,YAAY,CAACxa,SAAb,GAAyBpB,MAApD,EAA4D;AAC1D,kBAAI1W,IAAI,GAAGsyB,YAAY,CAACtyB,IAAxB;AACA,kBAAIgC,KAAK,GAAGswB,YAAY,CAAC/C,aAAzB;AACD;;AAED;AACD;;AACD,aAAKhsB,QAAL;AAAe;AAEb;AACD;;AACD,aAAKF,UAAL;AAAiB;AAEf;AACD;;AACD,aAAKS,QAAL;AAAe;AACb,gBAAIghB,mBAAJ,EAAyB;AACvB,kBAAIsM,QAAQ,GAAGkB,YAAY,CAAC/C,aAAb,CAA2B6B,QAA1C;;AAEA,kBAAIrM,uBAAJ,EAA6B;AAC3BqM,gBAAAA,QAAQ,CACNkB,YAAY,CAAC/C,aAAb,CAA2B4B,EADrB,EAENqT,UAAU,KAAK,IAAf,GAAsB,OAAtB,GAAgC,QAF1B,EAGNlS,YAAY,CAACvC,cAHP,EAINuC,YAAY,CAACpC,gBAJP,EAKNoC,YAAY,CAACtC,eALP,EAMN+N,aAAa,EANP,EAONkU,YAAY,CAACnf,oBAPP,CAAR;AASD,eAVD,MAUO;AACL1B,gBAAAA,QAAQ,CACNkB,YAAY,CAAC/C,aAAb,CAA2B4B,EADrB,EAENqT,UAAU,KAAK,IAAf,GAAsB,OAAtB,GAAgC,QAF1B,EAGNlS,YAAY,CAACvC,cAHP,EAINuC,YAAY,CAACpC,gBAJP,EAKNoC,YAAY,CAACtC,eALP,EAMN+N,aAAa,EANP,CAAR;AAQD;AACF;;AACD;AACD;;AACD,aAAKh6B,oBAAL;AAA2B;AACzB,gBAAI0gB,cAAJ,EAAoB;AAClB,kBAAI,CAAC6N,YAAY,CAACjD,IAAb,GAAoBX,UAArB,MAAqCnY,QAAzC,EAAmD;AAMjD+b,gBAAAA,YAAY,CAAC9C,WAAb,GAA2BwhB,aAA3B;AACA9Q,gBAAAA,YAAY,CAAC5N,YAAD,EAAelF,IAAf,CAAZ;AACD,eARD,MAQO;AAGL,oBAAIW,WAAW,GAAGiS,kBAAkB,EAApC;AACA1N,gBAAAA,YAAY,CAAClwB,SAAb,GAAyB;AAAEkwC,kBAAAA,UAAU,EAAEvkB;AAAd,iBAAzB;AACD;AACF;;AACD;AACD;;AACD;AAAS;AACP51B,YAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AAxIH;AA0ID;;AAED,aAASo6C,eAAT,CAAyBjgB,YAAzB,EAAuC;AACrC,UAAIhD,GAAG,GAAGgD,YAAY,CAAChD,GAAvB;;AACA,UAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,YAAIzmB,QAAQ,GAAGypB,YAAY,CAAClwB,SAA5B;AACA,YAAIowC,aAAa,GAAG,KAAK,CAAzB;;AACA,gBAAQlgB,YAAY,CAACxwB,GAArB;AACE,eAAKwB,aAAL;AACEkvC,YAAAA,aAAa,GAAG/xB,iBAAiB,CAAC5X,QAAD,CAAjC;AACA;;AACF;AACE2pC,YAAAA,aAAa,GAAG3pC,QAAhB;AALJ;;AAOA,YAAI,OAAOymB,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,UAAAA,GAAG,CAACkjB,aAAD,CAAH;AACD,SAFD,MAEO;AACL;AACE,gBAAI,CAACljB,GAAG,CAAC50B,cAAJ,CAAmB,SAAnB,CAAL,EAAoC;AAClCgE,cAAAA,qBAAqB,CACnB,KADmB,EAEnB,4CACE,0DAHiB,EAInBqX,gBAAgB,CAACuc,YAAY,CAACtyB,IAAd,CAJG,EAKnB4jB,2BAA2B,CAAC0O,YAAD,CALR,CAArB;AAOD;AACF;AAEDhD,UAAAA,GAAG,CAACxuB,OAAJ,GAAc0xC,aAAd;AACD;AACF;AACF;;AAED,aAASC,eAAT,CAAyBjO,UAAzB,EAAqC;AACnC,UAAIgH,UAAU,GAAGhH,UAAU,CAAClV,GAA5B;;AACA,UAAIkc,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAI,OAAOA,UAAP,KAAsB,UAA1B,EAAsC;AACpCA,UAAAA,UAAU,CAAC,IAAD,CAAV;AACD,SAFD,MAEO;AACLA,UAAAA,UAAU,CAAC1qC,OAAX,GAAqB,IAArB;AACD;AACF;AACF;;AAKD,aAAS4xC,aAAT,CAAuBlO,UAAvB,EAAmC;AACjCvX,MAAAA,eAAe,CAACuX,UAAD,CAAf;;AAEA,cAAQA,UAAU,CAAC1iC,GAAnB;AACE,aAAKmB,cAAL;AACA,aAAKC,kBAAL;AAAyB;AACvBwuC,YAAAA,eAAe,CAAClN,UAAD,CAAf;AACA,gBAAI37B,QAAQ,GAAG27B,UAAU,CAACpiC,SAA1B;;AACA,gBAAI,OAAOyG,QAAQ,CAACyoC,oBAAhB,KAAyC,UAA7C,EAAyD;AACvDC,cAAAA,8BAA8B,CAAC/M,UAAD,EAAa37B,QAAb,CAA9B;AACD;;AACD;AACD;;AACD,aAAKvF,aAAL;AAAoB;AAClBouC,YAAAA,eAAe,CAAClN,UAAD,CAAf;AACA;AACD;;AACD,aAAKnhC,UAAL;AAAiB;AAIf,gBAAIme,gBAAJ,EAAsB;AACpBmxB,cAAAA,qBAAqB,CAACnO,UAAD,CAArB;AACD,aAFD,MAEO,IAAI1mB,mBAAJ,EAAyB;AAC9B80B,cAAAA,oBAAoB,CAACpO,UAAD,CAApB;AACD;;AACD;AACD;AAxBH;AA0BD;;AAED,aAASqO,oBAAT,CAA8B9lB,IAA9B,EAAoC;AAKlC,UAAIlV,IAAI,GAAGkV,IAAX;;AACA,aAAO,IAAP,EAAa;AACX2lB,QAAAA,aAAa,CAAC76B,IAAD,CAAb;;AAGA,YACEA,IAAI,CAACa,KAAL,KAAe,IAAf,KAGC,CAAC8I,gBAAD,IAAqB3J,IAAI,CAAC/V,GAAL,KAAauB,UAHnC,CADF,EAKE;AACAwU,UAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,UAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;;AACD,YAAIb,IAAI,KAAKkV,IAAb,EAAmB;AACjB;AACD;;AACD,eAAOlV,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,cAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC5T,MAAL,KAAgB8oB,IAA5C,EAAkD;AAChD;AACD;;AACDlV,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;AACF;;AAED,aAASm6B,WAAT,CAAqBtO,UAArB,EAAiC;AAM/BA,MAAAA,UAAU,CAACvgC,MAAX,GAAoB,IAApB;AACAugC,MAAAA,UAAU,CAAC9rB,KAAX,GAAmB,IAAnB;;AACA,UAAI8rB,UAAU,CAAC9/B,SAAf,EAA0B;AACxB8/B,QAAAA,UAAU,CAAC9/B,SAAX,CAAqBgU,KAArB,GAA6B,IAA7B;AACA8rB,QAAAA,UAAU,CAAC9/B,SAAX,CAAqBT,MAArB,GAA8B,IAA9B;AACD;AACF;;AAED,aAAS2uC,oBAAT,CAA8BpO,UAA9B,EAA0C;AACxC,UAAI,CAAC1mB,mBAAL,EAA0B;AACxB;AACD;;AAED,UAAI2T,MAAM,GAAG+S,UAAU,CAACpiC,SAAxB;AACA,UAAIue,aAAa,GAAG8Q,MAAM,CAAC9Q,aAA3B;AAEA,UAAIoyB,aAAa,GAAG/0B,uBAAuB,CAAC2C,aAAD,CAA3C;AACAxC,MAAAA,wBAAwB,CAACwC,aAAD,EAAgBoyB,aAAhB,CAAxB;AACD;;AAED,aAASC,eAAT,CAAyB1gB,YAAzB,EAAuC;AACrC,UAAI,CAACxU,mBAAL,EAA0B;AACxB;AACD;;AAED,cAAQwU,YAAY,CAACxwB,GAArB;AACE,aAAKmB,cAAL;AACA,aAAKC,kBAAL;AAAyB;AACvB;AACD;;AACD,aAAKI,aAAL;AAAoB;AAClB;AACD;;AACD,aAAKC,QAAL;AAAe;AACb;AACD;;AACD,aAAKH,QAAL;AACA,aAAKC,UAAL;AAAiB;AACf,gBAAIgsC,YAAY,GAAG/c,YAAY,CAAClwB,SAAhC;AACA,gBAAIue,aAAa,GAAG0uB,YAAY,CAAC1uB,aAAjC;AAAA,gBACEsyB,gBAAgB,GAAG5D,YAAY,CAAC3d,eADlC;AAGAvT,YAAAA,wBAAwB,CAACwC,aAAD,EAAgBsyB,gBAAhB,CAAxB;AACA;AACD;;AACD;AAAS;AACP96C,YAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AA1BH;AA4BD;;AAED,aAAS+6C,kBAAT,CAA4Bt7B,KAA5B,EAAmC;AACjC,UAAImB,MAAM,GAAGnB,KAAK,CAAC3T,MAAnB;;AACA,aAAO8U,MAAM,KAAK,IAAlB,EAAwB;AACtB,YAAIo6B,YAAY,CAACp6B,MAAD,CAAhB,EAA0B;AACxB,iBAAOA,MAAP;AACD;;AACDA,QAAAA,MAAM,GAAGA,MAAM,CAAC9U,MAAhB;AACD;;AACD9L,MAAAA,SAAS,CACP,KADO,EAEP,0EACE,iCAHK,CAAT;AAKD;;AAED,aAASg7C,YAAT,CAAsBv7B,KAAtB,EAA6B;AAC3B,aACEA,KAAK,CAAC9V,GAAN,KAAcwB,aAAd,IACAsU,KAAK,CAAC9V,GAAN,KAAcsB,QADd,IAEAwU,KAAK,CAAC9V,GAAN,KAAcuB,UAHhB;AAKD;;AAED,aAAS+vC,cAAT,CAAwBx7B,KAAxB,EAA+B;AAI7B,UAAIC,IAAI,GAAGD,KAAX;;AACAy7B,MAAAA,QAAQ,EAAE,OAAO,IAAP,EAAa;AAErB,eAAOx7B,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,cAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwBkvC,YAAY,CAACt7B,IAAI,CAAC5T,MAAN,CAAxC,EAAuD;AAGrD,mBAAO,IAAP;AACD;;AACD4T,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;;AACA,eAAOd,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAAlD,EAA4D;AAG1D,cAAIsU,IAAI,CAACC,SAAL,GAAiBrB,SAArB,EAAgC;AAE9B,qBAAS48B,QAAT;AACD;;AAGD,cAAIx7B,IAAI,CAACa,KAAL,KAAe,IAAf,IAAuBb,IAAI,CAAC/V,GAAL,KAAauB,UAAxC,EAAoD;AAClD,qBAASgwC,QAAT;AACD,WAFD,MAEO;AACLx7B,YAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,YAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACD;AACF;;AAED,YAAI,EAAEb,IAAI,CAACC,SAAL,GAAiBrB,SAAnB,CAAJ,EAAmC;AAEjC,iBAAOoB,IAAI,CAACzV,SAAZ;AACD;AACF;AACF;;AAED,aAASkxC,eAAT,CAAyBhhB,YAAzB,EAAuC;AACrC,UAAI,CAAC9Q,gBAAL,EAAuB;AACrB;AACD;;AAGD,UAAI+xB,WAAW,GAAGL,kBAAkB,CAAC5gB,YAAD,CAApC;AAGA,UAAIvZ,MAAM,GAAG,KAAK,CAAlB;AACA,UAAIy6B,WAAW,GAAG,KAAK,CAAvB;;AAEA,cAAQD,WAAW,CAACzxC,GAApB;AACE,aAAKwB,aAAL;AACEyV,UAAAA,MAAM,GAAGw6B,WAAW,CAACnxC,SAArB;AACAoxC,UAAAA,WAAW,GAAG,KAAd;AACA;;AACF,aAAKpwC,QAAL;AACE2V,UAAAA,MAAM,GAAGw6B,WAAW,CAACnxC,SAAZ,CAAsBue,aAA/B;AACA6yB,UAAAA,WAAW,GAAG,IAAd;AACA;;AACF,aAAKnwC,UAAL;AACE0V,UAAAA,MAAM,GAAGw6B,WAAW,CAACnxC,SAAZ,CAAsBue,aAA/B;AACA6yB,UAAAA,WAAW,GAAG,IAAd;AACA;;AACF;AACEr7C,UAAAA,SAAS,CACP,KADO,EAEP,qEACE,iCAHK,CAAT;AAdJ;;AAoBA,UAAIo7C,WAAW,CAACz7B,SAAZ,GAAwBjB,YAA5B,EAA0C;AAExC08B,QAAAA,WAAW,CAACz7B,SAAZ,IAAyB,CAACjB,YAA1B;AACD;;AAED,UAAI48B,MAAM,GAAGL,cAAc,CAAC9gB,YAAD,CAA3B;AAGA,UAAIza,IAAI,GAAGya,YAAX;;AACA,aAAO,IAAP,EAAa;AACX,YAAIza,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAA/C,EAAyD;AACvD,cAAIkwC,MAAJ,EAAY;AACV,gBAAID,WAAJ,EAAiB;AACf/wB,cAAAA,uBAAuB,CAAC1J,MAAD,EAASlB,IAAI,CAACzV,SAAd,EAAyBqxC,MAAzB,CAAvB;AACD,aAFD,MAEO;AACLpxB,cAAAA,YAAY,CAACtJ,MAAD,EAASlB,IAAI,CAACzV,SAAd,EAAyBqxC,MAAzB,CAAZ;AACD;AACF,WAND,MAMO;AACL,gBAAID,WAAJ,EAAiB;AACf1xB,cAAAA,sBAAsB,CAAC/I,MAAD,EAASlB,IAAI,CAACzV,SAAd,CAAtB;AACD,aAFD,MAEO;AACLqf,cAAAA,WAAW,CAAC1I,MAAD,EAASlB,IAAI,CAACzV,SAAd,CAAX;AACD;AACF;AACF,SAdD,MAcO,IAAIyV,IAAI,CAAC/V,GAAL,KAAauB,UAAjB,EAA6B,CAInC,CAJM,MAIA,IAAIwU,IAAI,CAACa,KAAL,KAAe,IAAnB,EAAyB;AAC9Bb,UAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,UAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;;AACD,YAAIb,IAAI,KAAKya,YAAb,EAA2B;AACzB;AACD;;AACD,eAAOza,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,cAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC5T,MAAL,KAAgBquB,YAA5C,EAA0D;AACxD;AACD;;AACDza,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD4T,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;AACF;;AAED,aAASg6B,qBAAT,CAA+BnO,UAA/B,EAA2C;AAEzC,UAAI3sB,IAAI,GAAG2sB,UAAX;AAIA,UAAIkP,oBAAoB,GAAG,KAA3B;AAGA,UAAI16B,aAAa,GAAG,KAAK,CAAzB;AACA,UAAI26B,wBAAwB,GAAG,KAAK,CAApC;;AAEA,aAAO,IAAP,EAAa;AACX,YAAI,CAACD,oBAAL,EAA2B;AACzB,cAAI36B,MAAM,GAAGlB,IAAI,CAAC5T,MAAlB;;AACA2vC,UAAAA,UAAU,EAAE,OAAO,IAAP,EAAa;AACvBz7C,YAAAA,SAAS,CACP4gB,MAAM,KAAK,IADJ,EAEP,oEACE,uCAHK,CAAT;;AAKA,oBAAQA,MAAM,CAACjX,GAAf;AACE,mBAAKwB,aAAL;AACE0V,gBAAAA,aAAa,GAAGD,MAAM,CAAC3W,SAAvB;AACAuxC,gBAAAA,wBAAwB,GAAG,KAA3B;AACA,sBAAMC,UAAN;;AACF,mBAAKxwC,QAAL;AACE4V,gBAAAA,aAAa,GAAGD,MAAM,CAAC3W,SAAP,CAAiBue,aAAjC;AACAgzB,gBAAAA,wBAAwB,GAAG,IAA3B;AACA,sBAAMC,UAAN;;AACF,mBAAKvwC,UAAL;AACE2V,gBAAAA,aAAa,GAAGD,MAAM,CAAC3W,SAAP,CAAiBue,aAAjC;AACAgzB,gBAAAA,wBAAwB,GAAG,IAA3B;AACA,sBAAMC,UAAN;AAZJ;;AAcA76B,YAAAA,MAAM,GAAGA,MAAM,CAAC9U,MAAhB;AACD;;AACDyvC,UAAAA,oBAAoB,GAAG,IAAvB;AACD;;AAED,YAAI77B,IAAI,CAAC/V,GAAL,KAAawB,aAAb,IAA8BuU,IAAI,CAAC/V,GAAL,KAAayB,QAA/C,EAAyD;AACvDsvC,UAAAA,oBAAoB,CAACh7B,IAAD,CAApB;;AAGA,cAAI87B,wBAAJ,EAA8B;AAC5BhxB,YAAAA,wBAAwB,CAAC3J,aAAD,EAAgBnB,IAAI,CAACzV,SAArB,CAAxB;AACD,WAFD,MAEO;AACLsgB,YAAAA,WAAW,CAAC1J,aAAD,EAAgBnB,IAAI,CAACzV,SAArB,CAAX;AACD;AAEF,SAVD,MAUO,IAAIyV,IAAI,CAAC/V,GAAL,KAAauB,UAAjB,EAA6B;AAGlC2V,UAAAA,aAAa,GAAGnB,IAAI,CAACzV,SAAL,CAAeue,aAA/B;AACAgzB,UAAAA,wBAAwB,GAAG,IAA3B;;AAEA,cAAI97B,IAAI,CAACa,KAAL,KAAe,IAAnB,EAAyB;AACvBb,YAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,YAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;AACF,SAXM,MAWA;AACLg6B,UAAAA,aAAa,CAAC76B,IAAD,CAAb;;AAEA,cAAIA,IAAI,CAACa,KAAL,KAAe,IAAnB,EAAyB;AACvBb,YAAAA,IAAI,CAACa,KAAL,CAAWzU,MAAX,GAAoB4T,IAApB;AACAA,YAAAA,IAAI,GAAGA,IAAI,CAACa,KAAZ;AACA;AACD;AACF;;AACD,YAAIb,IAAI,KAAK2sB,UAAb,EAAyB;AACvB;AACD;;AACD,eAAO3sB,IAAI,CAACc,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,cAAId,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC5T,MAAL,KAAgBugC,UAA5C,EAAwD;AACtD;AACD;;AACD3sB,UAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;;AACA,cAAI4T,IAAI,CAAC/V,GAAL,KAAauB,UAAjB,EAA6B;AAG3BqwC,YAAAA,oBAAoB,GAAG,KAAvB;AACD;AACF;;AACD77B,QAAAA,IAAI,CAACc,OAAL,CAAa1U,MAAb,GAAsB4T,IAAI,CAAC5T,MAA3B;AACA4T,QAAAA,IAAI,GAAGA,IAAI,CAACc,OAAZ;AACD;AACF;;AAED,aAASk7B,cAAT,CAAwBrP,UAAxB,EAAoC;AAClC,UAAIhjB,gBAAJ,EAAsB;AAGpBmxB,QAAAA,qBAAqB,CAACnO,UAAD,CAArB;AACD,OAJD,MAIO;AAELqO,QAAAA,oBAAoB,CAACrO,UAAD,CAApB;AACD;;AACDsO,MAAAA,WAAW,CAACtO,UAAD,CAAX;AACD;;AAED,aAASsP,UAAT,CAAoBtP,UAApB,EAAgClS,YAAhC,EAA8C;AAC5C,UAAI,CAAC9Q,gBAAL,EAAuB;AACrBwxB,QAAAA,eAAe,CAAC1gB,YAAD,CAAf;AACA;AACD;;AAED,cAAQA,YAAY,CAACxwB,GAArB;AACE,aAAKmB,cAAL;AACA,aAAKC,kBAAL;AAAyB;AACvB;AACD;;AACD,aAAKI,aAAL;AAAoB;AAClB,gBAAIuF,QAAQ,GAAGypB,YAAY,CAAClwB,SAA5B;;AACA,gBAAIyG,QAAQ,IAAI,IAAhB,EAAsB;AAEpB,kBAAIiY,QAAQ,GAAGwR,YAAY,CAAC/C,aAA5B;AAIA,kBAAI1O,QAAQ,GACV2jB,UAAU,KAAK,IAAf,GAAsBA,UAAU,CAACjV,aAAjC,GAAiDzO,QADnD;AAEA,kBAAI9gB,IAAI,GAAGsyB,YAAY,CAACtyB,IAAxB;AAEA,kBAAIwZ,aAAa,GAAG8Y,YAAY,CAAC9C,WAAjC;AACA8C,cAAAA,YAAY,CAAC9C,WAAb,GAA2B,IAA3B;;AACA,kBAAIhW,aAAa,KAAK,IAAtB,EAA4B;AAC1B2I,gBAAAA,YAAY,CACVtZ,QADU,EAEV2Q,aAFU,EAGVxZ,IAHU,EAIV6gB,QAJU,EAKVC,QALU,EAMVwR,YANU,CAAZ;AAQD;AACF;;AACD;AACD;;AACD,aAAK/uB,QAAL;AAAe;AACbpL,YAAAA,SAAS,CACPm6B,YAAY,CAAClwB,SAAb,KAA2B,IADpB,EAEP,oEACE,iDAHK,CAAT;AAKA,gBAAI4f,YAAY,GAAGsQ,YAAY,CAAClwB,SAAhC;AACA,gBAAI8f,OAAO,GAAGoQ,YAAY,CAAC/C,aAA3B;AAIA,gBAAItN,OAAO,GAAGuiB,UAAU,KAAK,IAAf,GAAsBA,UAAU,CAACjV,aAAjC,GAAiDrN,OAA/D;AACAH,YAAAA,gBAAgB,CAACC,YAAD,EAAeC,OAAf,EAAwBC,OAAxB,CAAhB;AACA;AACD;;AACD,aAAK9e,QAAL;AAAe;AACb;AACD;;AACD,aAAKU,QAAL;AAAe;AACb;AACD;;AACD,aAAKC,oBAAL;AAA2B;AACzB;AACD;;AACD;AAAS;AACP5L,YAAAA,SAAS,CACP,KADO,EAEP,uEACE,wDAHK,CAAT;AAKD;AA9DH;AAgED;;AAED,aAAS47C,sBAAT,CAAgCvP,UAAhC,EAA4C;AAC1C,UAAI,CAAChjB,gBAAL,EAAuB;AACrB;AACD;;AACDoB,MAAAA,gBAAgB,CAAC4hB,UAAU,CAACpiC,SAAZ,CAAhB;AACD;;AAED,aAAS4xC,aAAT,GAAyB;AACvB,aAAO,IAAP;AACD;;AAED,aAASC,qBAAT,CAA+Br8B,KAA/B,EAAsCu5B,SAAtC,EAAiDhpB,cAAjD,EAAiE;AAC/D,UAAI8Q,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AAEA8Q,MAAAA,MAAM,CAACn3B,GAAP,GAAag2B,aAAb;AAGAmB,MAAAA,MAAM,CAACF,OAAP,GAAiB;AAAEpI,QAAAA,OAAO,EAAE;AAAX,OAAjB;AACA,UAAIh4B,KAAK,GAAGw4C,SAAS,CAACl9B,KAAtB;;AACAglB,MAAAA,MAAM,CAAChe,QAAP,GAAkB,YAAW;AAC3Bi5B,QAAAA,eAAe,CAACv7C,KAAD,CAAf;AACA83C,QAAAA,QAAQ,CAAC74B,KAAD,EAAQu5B,SAAR,CAAR;AACD,OAHD;;AAIA,aAAOlY,MAAP;AACD;;AAED,aAASkb,sBAAT,CAAgCv8B,KAAhC,EAAuCu5B,SAAvC,EAAkDhpB,cAAlD,EAAkE;AAChE,UAAI8Q,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AACA8Q,MAAAA,MAAM,CAACn3B,GAAP,GAAag2B,aAAb;AACA,UAAIwK,wBAAwB,GAAG1qB,KAAK,CAAC5X,IAAN,CAAWsiC,wBAA1C;;AACA,UACE9d,8BAA8B,IAC9B,OAAO8d,wBAAP,KAAoC,UAFtC,EAGE;AACA,YAAI3pC,KAAK,GAAGw4C,SAAS,CAACl9B,KAAtB;;AACAglB,QAAAA,MAAM,CAACF,OAAP,GAAiB,YAAW;AAC1B,iBAAOuJ,wBAAwB,CAAC3pC,KAAD,CAA/B;AACD,SAFD;AAGD;;AAED,UAAIoH,IAAI,GAAG6X,KAAK,CAACxV,SAAjB;;AACA,UAAIrC,IAAI,KAAK,IAAT,IAAiB,OAAOA,IAAI,CAACq0C,iBAAZ,KAAkC,UAAvD,EAAmE;AACjEnb,QAAAA,MAAM,CAAChe,QAAP,GAAkB,SAASA,QAAT,GAAoB;AACpC,cACE,CAACuJ,8BAAD,IACA8d,wBAAwB,KAAK,UAF/B,EAGE;AAMA+R,YAAAA,+BAA+B,CAAC,IAAD,CAA/B;AACD;;AACD,cAAI17C,KAAK,GAAGw4C,SAAS,CAACl9B,KAAtB;AACA,cAAI8mB,KAAK,GAAGoW,SAAS,CAACpW,KAAtB;AACA0V,UAAAA,QAAQ,CAAC74B,KAAD,EAAQu5B,SAAR,CAAR;AACA,eAAKiD,iBAAL,CAAuBz7C,KAAvB,EAA8B;AAC5By3C,YAAAA,cAAc,EAAErV,KAAK,KAAK,IAAV,GAAiBA,KAAjB,GAAyB;AADb,WAA9B;AAGD,SAlBD;AAmBD;;AACD,aAAO9B,MAAP;AACD;;AAED,aAASqb,cAAT,CACEvnB,IADF,EAEEwX,WAFF,EAGEgQ,WAHF,EAIEtgC,KAJF,EAKEsjB,oBALF,EAME;AAEAgd,MAAAA,WAAW,CAACz8B,SAAZ,IAAyBV,UAAzB;AAEAm9B,MAAAA,WAAW,CAAC3kB,WAAZ,GAA0B2kB,WAAW,CAAC1kB,UAAZ,GAAyB,IAAnD;;AAEA,UACEpL,cAAc,IACdxQ,KAAK,KAAK,IADV,IAEA,OAAOA,KAAP,KAAiB,QAFjB,IAGA,OAAOA,KAAK,CAACoC,IAAb,KAAsB,UAJxB,EAKE;AAEA,YAAIV,QAAQ,GAAG1B,KAAf;AAOA,YAAIugC,eAAe,GAAGjQ,WAAtB;AACA,YAAIkQ,iBAAiB,GAAG,CAAC,CAAzB;AACA,YAAIC,WAAW,GAAG,CAAC,CAAnB;;AACA,WAAG;AACD,cAAIF,eAAe,CAAC1yC,GAAhB,KAAwBiC,oBAA5B,EAAkD;AAChD,gBAAIjD,OAAO,GAAG0zC,eAAe,CAAC9vC,SAA9B;;AACA,gBACE5D,OAAO,KAAK,IAAZ,IACAA,OAAO,CAAC2uB,aAAR,KAA0B,IAD1B,IAEA3uB,OAAO,CAACsB,SAAR,KAAsB,IAHxB,EAIE;AAMA,kBAAIkwC,UAAU,GAAGxxC,OAAO,CAACsB,SAAR,CAAkBkwC,UAAnC;AACAoC,cAAAA,WAAW,GAAGhnB,kBAAkB,CAAC4kB,UAAD,CAAhC;AAGA;AACD;;AACD,gBAAIqC,aAAa,GAAGH,eAAe,CAACplB,YAAhB,CAA6BwlB,OAAjD;;AACA,gBAAI,OAAOD,aAAP,KAAyB,QAA7B,EAAuC;AACrC,kBAAIA,aAAa,IAAI,CAArB,EAAwB;AACtBF,gBAAAA,iBAAiB,GAAG,CAApB;AACD,eAFD,MAEO,IACLA,iBAAiB,KAAK,CAAC,CAAvB,IACAE,aAAa,GAAGF,iBAFX,EAGL;AACAA,gBAAAA,iBAAiB,GAAGE,aAApB;AACD;AACF;AACF;;AACDH,UAAAA,eAAe,GAAGA,eAAe,CAACvwC,MAAlC;AACD,SAhCD,QAgCSuwC,eAAe,KAAK,IAhC7B;;AAmCAA,QAAAA,eAAe,GAAGjQ,WAAlB;;AACA,WAAG;AACD,cAAIiQ,eAAe,CAAC1yC,GAAhB,KAAwBiC,oBAA5B,EAAkD;AAChD,gBAAIqZ,UAAU,GAAGo3B,eAAe,CAAC/kB,aAAjC;;AACA,gBAAI,CAACrS,UAAL,EAAiB;AAKf,kBAAIy3B,QAAQ,GACV,CAACL,eAAe,CAACnlB,IAAhB,GAAuBZ,SAAxB,MAAuClY,QAAvC,GACI6W,IADJ,GAEImK,oBAHN;AAMA,kBAAIud,iBAAiB,GAAGC,kBAAkB,CAACC,IAAnB,CACtB,IADsB,EAEtBjoB,IAFsB,EAGtBynB,eAHsB,EAItBK,QAJsB,CAAxB;AAMAl/B,cAAAA,QAAQ,CAACU,IAAT,CAAcy+B,iBAAd,EAAiCA,iBAAjC;;AAUA,kBAAI,CAACN,eAAe,CAACnlB,IAAhB,GAAuBX,UAAxB,MAAwCnY,QAA5C,EAAsD;AACpDi+B,gBAAAA,eAAe,CAAC18B,SAAhB,IAA6BpB,MAA7B;AAGA,oBAAI40B,YAAY,GAAG,IAAnB;AACAD,gBAAAA,iBAAiB,CACfkJ,WAAW,CAAC7vC,SADG,EAEf6vC,WAFe,EAGfjJ,YAHe,EAIf/T,oBAJe,CAAjB;AAMAgd,gBAAAA,WAAW,CAACz8B,SAAZ,IAAyB,CAACV,UAA1B;;AACA,oBAAIm9B,WAAW,CAACzyC,GAAZ,KAAoBqB,sBAAxB,EAAgD;AAG9CoxC,kBAAAA,WAAW,CAACzyC,GAAZ,GAAkBiB,mBAAlB;AACD;;AAED,oBACEwxC,WAAW,CAACzyC,GAAZ,KAAoBmB,cAApB,IACAsxC,WAAW,CAACzyC,GAAZ,KAAoBoB,kBAFtB,EAGE;AAIAqxC,kBAAAA,WAAW,CAACz8B,SAAZ,IAAyB,CAACZ,mBAA1B;;AACA,sBAAIq9B,WAAW,CAAC7vC,SAAZ,KAA0B,IAA9B,EAAoC;AAMlC6vC,oBAAAA,WAAW,CAACzyC,GAAZ,GAAkBiB,mBAAlB;AACAwxC,oBAAAA,WAAW,CAACv0C,IAAZ,GAAmBg0C,aAAnB;AACD;AACF;;AAGD;AACD;;AAKD,kBAAIiB,iBAAiB,GAAG,KAAK,CAA7B;;AACA,kBAAIR,iBAAiB,KAAK,CAAC,CAA3B,EAA8B;AAI5BQ,gBAAAA,iBAAiB,GAAG/nB,iBAApB;AACD,eALD,MAKO;AACL,oBAAIwnB,WAAW,KAAK,CAAC,CAArB,EAAwB;AAUtB,sBAAIld,sBAAsB,GAAGF,oCAAoC,CAC/DvK,IAD+D,EAE/DwK,oBAF+D,CAAjE;AAIA,sBAAI2d,wBAAwB,GAAGxnB,kBAAkB,CAC/C8J,sBAD+C,CAAjD;AAGAkd,kBAAAA,WAAW,GAAGQ,wBAAwB,GAAGhnB,uBAAzC;AACD;;AACD+mB,gBAAAA,iBAAiB,GAAGP,WAAW,GAAGD,iBAAlC;AACD;;AAMDU,cAAAA,gBAAgB,CAACpoB,IAAD,EAAOkoB,iBAAP,EAA0B1d,oBAA1B,CAAhB;AAEAid,cAAAA,eAAe,CAAC18B,SAAhB,IAA6BT,aAA7B;AACAm9B,cAAAA,eAAe,CAACrsB,cAAhB,GAAiCoP,oBAAjC;AACA;AACD;AAGF;;AACDid,UAAAA,eAAe,GAAGA,eAAe,CAACvwC,MAAlC;AACD,SArHD,QAqHSuwC,eAAe,KAAK,IArH7B;;AAuHAvgC,QAAAA,KAAK,GAAG,IAAI/b,KAAJ,CACN,8DADM,CAAR;AAGD;;AAKDk9C,MAAAA,cAAc;AACdnhC,MAAAA,KAAK,GAAG6mB,mBAAmB,CAAC7mB,KAAD,EAAQsgC,WAAR,CAA3B;AACA,UAAI1wB,cAAc,GAAG0gB,WAArB;;AACA,SAAG;AACD,gBAAQ1gB,cAAc,CAAC/hB,GAAvB;AACE,eAAKsB,QAAL;AAAe;AACb,kBAAIiyC,UAAU,GAAGphC,KAAjB;AACA4P,cAAAA,cAAc,CAAC/L,SAAf,IAA4BT,aAA5B;AACAwM,cAAAA,cAAc,CAACsE,cAAf,GAAgCoP,oBAAhC;AACA,kBAAI0B,MAAM,GAAGgb,qBAAqB,CAChCpwB,cADgC,EAEhCwxB,UAFgC,EAGhC9d,oBAHgC,CAAlC;AAKA8B,cAAAA,qBAAqB,CAACxV,cAAD,EAAiBoV,MAAjB,CAArB;AACA;AACD;;AACD,eAAKh2B,cAAL;AACA,eAAKC,kBAAL;AAEE,gBAAIiuC,SAAS,GAAGl9B,KAAhB;AACA,gBAAI2rB,IAAI,GAAG/b,cAAc,CAAC7jB,IAA1B;AACA,gBAAI6I,QAAQ,GAAGgb,cAAc,CAACzhB,SAA9B;;AACA,gBACE,CAACyhB,cAAc,CAAC/L,SAAf,GAA2Bf,UAA5B,MAA4CR,QAA5C,KACE,OAAOqpB,IAAI,CAAC0C,wBAAZ,KAAyC,UAAzC,IACA9d,8BADD,IAEE3b,QAAQ,KAAK,IAAb,IACC,OAAOA,QAAQ,CAACurC,iBAAhB,KAAsC,UADvC,IAEC,CAACkB,kCAAkC,CAACzsC,QAAD,CALvC,CADF,EAOE;AACAgb,cAAAA,cAAc,CAAC/L,SAAf,IAA4BT,aAA5B;AACAwM,cAAAA,cAAc,CAACsE,cAAf,GAAgCoP,oBAAhC;;AAEA,kBAAIge,OAAO,GAAGpB,sBAAsB,CAClCtwB,cADkC,EAElCstB,SAFkC,EAGlC5Z,oBAHkC,CAApC;;AAKA8B,cAAAA,qBAAqB,CAACxV,cAAD,EAAiB0xB,OAAjB,CAArB;AACA;AACD;;AACD;;AACF;AACE;AAxCJ;;AA0CA1xB,QAAAA,cAAc,GAAGA,cAAc,CAAC5f,MAAhC;AACD,OA5CD,QA4CS4f,cAAc,KAAK,IA5C5B;AA6CD;;AAED,aAAS2xB,UAAT,CAAoB3xB,cAApB,EAAoC0T,oBAApC,EAA0D;AACxD,cAAQ1T,cAAc,CAAC/hB,GAAvB;AACE,aAAKmB,cAAL;AAAqB;AACnB,gBAAIqnB,SAAS,GAAGzG,cAAc,CAAC7jB,IAA/B;;AACA,gBAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChCY,cAAAA,UAAU,CAACrH,cAAD,CAAV;AACD;;AACD,gBAAI/L,SAAS,GAAG+L,cAAc,CAAC/L,SAA/B;;AACA,gBAAIA,SAAS,GAAGT,aAAhB,EAA+B;AAC7BwM,cAAAA,cAAc,CAAC/L,SAAf,GAA4BA,SAAS,GAAG,CAACT,aAAd,GAA+BN,UAA1D;AACA,qBAAO8M,cAAP;AACD;;AACD,mBAAO,IAAP;AACD;;AACD,aAAK3gB,kBAAL;AAAyB;AACvB,gBAAI+oB,UAAU,GAAGpI,cAAc,CAAC7jB,IAAf,CAAoB4V,YAArC;;AACA,gBAAI4U,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjCf,cAAAA,UAAU,CAACrH,cAAD,CAAV;AACD;;AACD,gBAAI4xB,UAAU,GAAG5xB,cAAc,CAAC/L,SAAhC;;AACA,gBAAI29B,UAAU,GAAGp+B,aAAjB,EAAgC;AAC9BwM,cAAAA,cAAc,CAAC/L,SAAf,GAA4B29B,UAAU,GAAG,CAACp+B,aAAf,GAAgCN,UAA3D;AACA,qBAAO8M,cAAP;AACD;;AACD,mBAAO,IAAP;AACD;;AACD,aAAKzgB,QAAL;AAAe;AACbo6B,YAAAA,gBAAgB,CAAC3Z,cAAD,CAAhB;AACAsH,YAAAA,wBAAwB,CAACtH,cAAD,CAAxB;AACA,gBAAI6xB,WAAW,GAAG7xB,cAAc,CAAC/L,SAAjC;AACA3f,YAAAA,SAAS,CACP,CAACu9C,WAAW,GAAG3+B,UAAf,MAA+BR,QADxB,EAEP,wEACE,8BAHK,CAAT;AAKAsN,YAAAA,cAAc,CAAC/L,SAAf,GAA4B49B,WAAW,GAAG,CAACr+B,aAAhB,GAAiCN,UAA5D;AACA,mBAAO8M,cAAP;AACD;;AACD,aAAKvgB,aAAL;AAAoB;AAClBs6B,YAAAA,cAAc,CAAC/Z,cAAD,CAAd;AACA,mBAAO,IAAP;AACD;;AACD,aAAK9f,oBAAL;AAA2B;AACzB,gBAAI4xC,WAAW,GAAG9xB,cAAc,CAAC/L,SAAjC;;AACA,gBAAI69B,WAAW,GAAGt+B,aAAlB,EAAiC;AAC/BwM,cAAAA,cAAc,CAAC/L,SAAf,GAA4B69B,WAAW,GAAG,CAACt+B,aAAhB,GAAiCN,UAA5D;AACA,qBAAO8M,cAAP;AACD;;AACD,mBAAO,IAAP;AACD;;AACD,aAAKxgB,UAAL;AACEm6B,UAAAA,gBAAgB,CAAC3Z,cAAD,CAAhB;AACA,iBAAO,IAAP;;AACF,aAAKlgB,eAAL;AACEo4B,UAAAA,WAAW,CAAClY,cAAD,CAAX;AACA,iBAAO,IAAP;;AACF;AACE,iBAAO,IAAP;AAxDJ;AA0DD;;AAED,aAAS+xB,qBAAT,CAA+BC,eAA/B,EAAgD;AAC9C,cAAQA,eAAe,CAAC/zC,GAAxB;AACE,aAAKmB,cAAL;AAAqB;AACnB,gBAAIgoB,iBAAiB,GAAG4qB,eAAe,CAAC71C,IAAhB,CAAqBirB,iBAA7C;;AACA,gBAAIA,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAKhzB,SAAxD,EAAmE;AACjEizB,cAAAA,UAAU,CAAC2qB,eAAD,CAAV;AACD;;AACD;AACD;;AACD,aAAK3yC,kBAAL;AAAyB;AACvB,gBAAI4yC,kBAAkB,GACpBD,eAAe,CAAC71C,IAAhB,CAAqB4V,YAArB,CAAkCqV,iBADpC;;AAEA,gBAAI6qB,kBAAkB,KAAK,IAAvB,IAA+BA,kBAAkB,KAAK79C,SAA1D,EAAqE;AACnEizB,cAAAA,UAAU,CAAC2qB,eAAD,CAAV;AACD;;AACD;AACD;;AACD,aAAKzyC,QAAL;AAAe;AACbo6B,YAAAA,gBAAgB,CAACqY,eAAD,CAAhB;AACA1qB,YAAAA,wBAAwB,CAAC0qB,eAAD,CAAxB;AACA;AACD;;AACD,aAAKvyC,aAAL;AAAoB;AAClBs6B,YAAAA,cAAc,CAACiY,eAAD,CAAd;AACA;AACD;;AACD,aAAKxyC,UAAL;AACEm6B,UAAAA,gBAAgB,CAACqY,eAAD,CAAhB;AACA;;AACF,aAAKlyC,eAAL;AACEo4B,UAAAA,WAAW,CAAC8Z,eAAD,CAAX;AACA;;AACF;AACE;AAhCJ;AAkCD;;AAED,QAAIE,UAAU,GAAG;AACfpZ,MAAAA,WAAW,EAAEA;AADE,KAAjB;AAIA,QAAIqZ,mBAAmB,GAAG9hC,oBAAoB,CAACqD,iBAA/C;AAEA,QAAI0+B,2BAA2B,GAAG,KAAK,CAAvC;AACA,QAAIC,2BAA2B,GAAG,KAAK,CAAvC;AACA,QAAIC,0BAA0B,GAAG,KAAK,CAAtC;AACA,QAAIC,uBAAuB,GAAG,KAAK,CAAnC;;AAEA,QAAIrxB,uBAAJ,EAA6B;AAG3B5sB,MAAAA,SAAS,CACPN,QAAQ,CAACw+C,iBAAT,IAA8B,IAA9B,IACEx+C,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,IAAsC,IAFjC,EAGP,yGACE,4FADF,GAEE,+DAFF,GAGE,4CANK,CAAT;AAQD;;AAED;AACEm1C,MAAAA,2BAA2B,GAAG,KAA9B;AACAC,MAAAA,2BAA2B,GAAG,KAA9B;AACA,UAAII,uCAAuC,GAAG,EAA9C;;AAEAH,MAAAA,0BAA0B,GAAG,oCAASv+B,KAAT,EAAgB;AAG3C,YAAIqP,aAAa,GAAGlR,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CAAhB,IAAgC,YAApD;;AACA,YAAIs2C,uCAAuC,CAACrvB,aAAD,CAA3C,EAA4D;AAC1D;AACD;;AACDvoB,QAAAA,qBAAqB,CACnB,KADmB,EAEnB,0EACE,qEADF,GAEE,8DAFF,GAGE,gCALiB,EAMnBklB,2BAA2B,CAAChM,KAAD,CANR,CAArB;AAQA0+B,QAAAA,uCAAuC,CAACrvB,aAAD,CAAvC,GAAyD,IAAzD;AACD,OAhBD;;AAkBAmvB,MAAAA,uBAAuB,GAAG,iCAASvtC,QAAT,EAAmB;AAC3C,gBAAQzD,KAAR;AACE,eAAK,iBAAL;AACE,gBAAI8wC,2BAAJ,EAAiC;AAC/B;AACD;;AACDx3C,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,gEAFmB,CAArB;AAIAw3C,YAAAA,2BAA2B,GAAG,IAA9B;AACA;;AACF,eAAK,QAAL;AACE,gBAAID,2BAAJ,EAAiC;AAC/B;AACD;;AACDv3C,YAAAA,qBAAqB,CACnB,KADmB,EAEnB,uEACE,yEAHiB,CAArB;AAKAu3C,YAAAA,2BAA2B,GAAG,IAA9B;AACA;AArBJ;AAuBD,OAxBD;AAyBD;AAKD,QAAIM,iBAAiB,GAAGppB,MAAxB;AAEA,QAAIqpB,SAAS,GAAG,KAAhB;AAGA,QAAI7tB,cAAc,GAAG,IAArB;AACA,QAAI8tB,QAAQ,GAAG,IAAf;AAEA,QAAIC,wBAAwB,GAAGvpB,MAA/B;AACA,QAAIwpB,2BAA2B,GAAG,CAAC,CAAnC;AACA,QAAIC,kBAAkB,GAAG,KAAzB;AAGA,QAAIjnB,UAAU,GAAG,IAAjB;AAEA,QAAIknB,cAAc,GAAG,KAArB;AAEA,QAAIC,sCAAsC,GAAG,IAA7C;AAGA,QAAIjuB,aAAa,GAAG,IAApB;AAIA,QAAIkuB,kBAAkB,GAAG,KAAzB;AAEA,QAAIC,+BAA+B,GAAG,KAAK,CAA3C;AACA,QAAIC,gBAAgB,GAAG,KAAK,CAA5B;AACA,QAAIC,2BAA2B,GAAG,KAAK,CAAvC;AACA,QAAIC,mBAAmB,GAAG,KAAK,CAA/B;AACA,QAAIC,oBAAoB,GAAG,KAAK,CAAhC;;AACA,QAAI,QAAQzyB,+CAAZ,EAA6D;AAC3DqyB,MAAAA,+BAA+B,GAAG,IAAlC;AACAE,MAAAA,2BAA2B,GAAG,KAA9B;AACAC,MAAAA,mBAAmB,GAAG,IAAtB;;AACAF,MAAAA,gBAAgB,GAAG,0BAASI,gBAAT,EAA2BC,WAA3B,EAAwCC,QAAxC,EAAkD;AACnE,YACED,WAAW,KAAK,IAAhB,IACA,OAAOA,WAAP,KAAuB,QADvB,IAEA,OAAOA,WAAW,CAACjhC,IAAnB,KAA4B,UAH9B,EAIE;AAIA;AACD;;AAGD,YAAI2gC,+BAA+B,KAAK,IAAxC,EAA8C;AAE5Ct4C,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,+EACE,uBAHiB,CAArB;AAKA;AACD;;AACDkzB,QAAAA,0BAA0B,CACxBylB,gBADwB,EAExBL,+BAFwB,CAA1B;;AAKA,gBAAQK,gBAAgB,CAACv1C,GAAzB;AACE,eAAKsB,QAAL;AACEo6B,YAAAA,gBAAgB,CAAC6Z,gBAAD,CAAhB;AACAlsB,YAAAA,wBAAwB,CAACksB,gBAAD,CAAxB;AACA;;AACF,eAAK/zC,aAAL;AACEs6B,YAAAA,cAAc,CAACyZ,gBAAD,CAAd;AACA;;AACF,eAAKp0C,cAAL;AAAqB;AACnB,kBAAIqnB,SAAS,GAAG+sB,gBAAgB,CAACr3C,IAAjC;;AACA,kBAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChCY,gBAAAA,UAAU,CAACmsB,gBAAD,CAAV;AACD;;AACD;AACD;;AACD,eAAKn0C,kBAAL;AAAyB;AACvB,kBAAI+oB,UAAU,GAAGvW,6BAA6B,CAAC2hC,gBAAgB,CAACr3C,IAAlB,CAA9C;;AACA,kBAAIwqB,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjCf,gBAAAA,UAAU,CAACmsB,gBAAD,CAAV;AACD;;AACD;AACD;;AACD,eAAKh0C,UAAL;AACEm6B,YAAAA,gBAAgB,CAAC6Z,gBAAD,CAAhB;AACA;;AACF,eAAK1zC,eAAL;AACEo4B,YAAAA,WAAW,CAACsb,gBAAD,CAAX;AACA;AA3BJ;;AA8BAH,QAAAA,2BAA2B,GAAG,IAA9B;AACAC,QAAAA,mBAAmB,GAAGG,WAAtB;AACA37C,QAAAA,qBAAqB,CAAC,IAAD,EAAO67C,QAAP,EAAiB,IAAjB,EAAuBD,QAAvB,CAArB;AACAL,QAAAA,2BAA2B,GAAG,KAA9B;AACAC,QAAAA,mBAAmB,GAAG,IAAtB;;AACA,YAAIp7C,cAAc,EAAlB,EAAsB;AACpB,cAAI07C,WAAW,GAAG57C,gBAAgB,EAAlC;;AACA,cAAI47C,WAAW,IAAI,IAAf,IAAuBH,WAAW,IAAI,IAA1C,EAAgD;AAC9C,gBAAI;AAGF,kBAAIG,WAAW,CAACx8C,gBAAhB,EAAkC;AAEhCq8C,gBAAAA,WAAW,CAACr8C,gBAAZ,GAA+B,IAA/B;AACD;AACF,aAPD,CAOE,OAAOC,KAAP,EAAc,CAEf;AACF;AACF,SAdD,MAcO;AAGLytB,UAAAA,cAAc,GAAG0uB,gBAAjB;AACD;AACF,OAjFD;;AAkFAD,MAAAA,oBAAoB,GAAG,gCAAW;AAChC,cAAMD,mBAAN;AACD,OAFD;AAGD;;AAED,aAASO,UAAT,GAAsB;AACpB,UAAI/uB,cAAc,KAAK,IAAvB,EAA6B;AAC3B,YAAIktB,eAAe,GAAGltB,cAAc,CAAC1kB,MAArC;;AACA,eAAO4xC,eAAe,KAAK,IAA3B,EAAiC;AAC/BD,UAAAA,qBAAqB,CAACC,eAAD,CAArB;AACAA,UAAAA,eAAe,GAAGA,eAAe,CAAC5xC,MAAlC;AACD;AACF;;AAED;AACEovB,QAAAA,uBAAuB,CAACC,sBAAxB;AACAxJ,QAAAA,qBAAqB;AACtB;AAED2sB,MAAAA,QAAQ,GAAG,IAAX;AACAC,MAAAA,wBAAwB,GAAGvpB,MAA3B;AACAwpB,MAAAA,2BAA2B,GAAG,CAAC,CAA/B;AACAC,MAAAA,kBAAkB,GAAG,KAArB;AACAjuB,MAAAA,cAAc,GAAG,IAAjB;AACD;;AAED,aAASgvB,oBAAT,GAAgC;AAC9B,aAAOhoB,UAAU,KAAK,IAAtB,EAA4B;AAC1B;AACExL,UAAAA,eAAe,CAACwL,UAAD,CAAf;AACD;AACD7H,QAAAA,YAAY;AAEZ,YAAIhQ,SAAS,GAAG6X,UAAU,CAAC7X,SAA3B;;AAEA,YAAIA,SAAS,GAAGjB,YAAhB,EAA8B;AAC5Bk9B,UAAAA,sBAAsB,CAACpkB,UAAD,CAAtB;AACD;;AAED,YAAI7X,SAAS,GAAGd,GAAhB,EAAqB;AACnB,cAAIwtB,UAAU,GAAG7U,UAAU,CAACjrB,SAA5B;;AACA,cAAI8/B,UAAU,KAAK,IAAnB,EAAyB;AACvBiO,YAAAA,eAAe,CAACjO,UAAD,CAAf;AACD;AACF;;AAMD,YAAIoT,gBAAgB,GAAG9/B,SAAS,IAAIrB,SAAS,GAAGC,MAAZ,GAAqBE,QAAzB,CAAhC;;AACA,gBAAQghC,gBAAR;AACE,eAAKnhC,SAAL;AAAgB;AACd68B,cAAAA,eAAe,CAAC3jB,UAAD,CAAf;AAMAA,cAAAA,UAAU,CAAC7X,SAAX,IAAwB,CAACrB,SAAzB;AACA;AACD;;AACD,eAAKE,kBAAL;AAAyB;AAEvB28B,cAAAA,eAAe,CAAC3jB,UAAD,CAAf;AAGAA,cAAAA,UAAU,CAAC7X,SAAX,IAAwB,CAACrB,SAAzB;AAGA,kBAAIohC,QAAQ,GAAGloB,UAAU,CAACjrB,SAA1B;AACAovC,cAAAA,UAAU,CAAC+D,QAAD,EAAWloB,UAAX,CAAV;AACA;AACD;;AACD,eAAKjZ,MAAL;AAAa;AACX,kBAAIohC,SAAS,GAAGnoB,UAAU,CAACjrB,SAA3B;AACAovC,cAAAA,UAAU,CAACgE,SAAD,EAAYnoB,UAAZ,CAAV;AACA;AACD;;AACD,eAAK/Y,QAAL;AAAe;AACbi9B,cAAAA,cAAc,CAAClkB,UAAD,CAAd;AACA;AACD;AA/BH;;AAiCAA,QAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;;AAED;AACE1L,QAAAA,iBAAiB;AAClB;AACF;;AAED,aAAS8zB,8BAAT,GAA0C;AACxC,aAAOpoB,UAAU,KAAK,IAAtB,EAA4B;AAC1B;AACExL,UAAAA,eAAe,CAACwL,UAAD,CAAf;AACD;AAED,YAAI7X,SAAS,GAAG6X,UAAU,CAAC7X,SAA3B;;AACA,YAAIA,SAAS,GAAGb,QAAhB,EAA0B;AACxB6Q,UAAAA,YAAY;AACZ,cAAI0c,UAAU,GAAG7U,UAAU,CAACjrB,SAA5B;AACAktC,UAAAA,8BAA8B,CAACpN,UAAD,EAAa7U,UAAb,CAA9B;AACD;;AAIDA,QAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;;AAED;AACE1L,QAAAA,iBAAiB;AAClB;AACF;;AAED,aAAS+zB,mBAAT,CAA6B/F,YAA7B,EAA2CC,uBAA3C,EAAoE;AAClE;AACE7e,QAAAA,uBAAuB,CAACG,mCAAxB;;AAEA,YAAI5O,6BAAJ,EAAmC;AACjCyO,UAAAA,uBAAuB,CAACE,+BAAxB;AACD;;AAED,YAAI1O,yBAAJ,EAA+B;AAC7BwO,UAAAA,uBAAuB,CAACO,yBAAxB;AACD;AACF;;AACD,aAAOjE,UAAU,KAAK,IAAtB,EAA4B;AAC1B,YAAI7X,SAAS,GAAG6X,UAAU,CAAC7X,SAA3B;;AAEA,YAAIA,SAAS,IAAIpB,MAAM,GAAGI,QAAb,CAAb,EAAqC;AACnCgR,UAAAA,YAAY;AACZ,cAAI0c,UAAU,GAAG7U,UAAU,CAACjrB,SAA5B;AACAstC,UAAAA,gBAAgB,CACdC,YADc,EAEdzN,UAFc,EAGd7U,UAHc,EAIduiB,uBAJc,CAAhB;AAMD;;AAED,YAAIp6B,SAAS,GAAGd,GAAhB,EAAqB;AACnB8Q,UAAAA,YAAY;AACZyqB,UAAAA,eAAe,CAAC5iB,UAAD,CAAf;AACD;;AAED,YAAI5uB,IAAI,GAAG4uB,UAAU,CAACA,UAAtB;AAKAA,QAAAA,UAAU,CAACA,UAAX,GAAwB,IAAxB;AAGAA,QAAAA,UAAU,GAAG5uB,IAAb;AACD;AACF;;AAED,aAASu0C,kCAAT,CAA4CzsC,QAA5C,EAAsD;AACpD,aACEiuC,sCAAsC,KAAK,IAA3C,IACAA,sCAAsC,CAAC1vB,GAAvC,CAA2Cve,QAA3C,CAFF;AAID;;AAED,aAASwrC,+BAAT,CAAyCxrC,QAAzC,EAAmD;AACjD,UAAIiuC,sCAAsC,KAAK,IAA/C,EAAqD;AACnDA,QAAAA,sCAAsC,GAAG,IAAI9wB,GAAJ,CAAQ,CAACnd,QAAD,CAAR,CAAzC;AACD,OAFD,MAEO;AACLiuC,QAAAA,sCAAsC,CAACzvB,GAAvC,CAA2Cxe,QAA3C;AACD;AACF;;AAED,aAASovC,UAAT,CAAoBlrB,IAApB,EAA0BuF,YAA1B,EAAwC;AACtCkkB,MAAAA,SAAS,GAAG,IAAZ;AACAK,MAAAA,cAAc,GAAG,IAAjB;AACA9tB,MAAAA,gBAAgB;AAEhB5wB,MAAAA,SAAS,CACP40B,IAAI,CAACjsB,OAAL,KAAiBwxB,YADV,EAEP,mEACE,oEADF,GAEE,iCAJK,CAAT;AAMA,UAAI4f,uBAAuB,GAAGnlB,IAAI,CAACsF,2BAAnC;AACAl6B,MAAAA,SAAS,CACP+5C,uBAAuB,KAAK/kB,MADrB,EAEP,wEACE,qCAHK,CAAT;AAKAJ,MAAAA,IAAI,CAACsF,2BAAL,GAAmClF,MAAnC;AAKA,UAAI+qB,gCAAgC,GAAG5lB,YAAY,CAACnK,cAApD;AACA,UAAIgwB,+BAA+B,GAAG7lB,YAAY,CAACxC,mBAAnD;AACA,UAAIsoB,iCAAiC,GACnCF,gCAAgC,KAAK/qB,MAArC,IACCgrB,+BAA+B,KAAKhrB,MAApC,IACCgrB,+BAA+B,GAAGD,gCAFpC,GAGIC,+BAHJ,GAIID,gCALN;AAMAvhB,MAAAA,2BAA2B,CAAC5J,IAAD,EAAOqrB,iCAAP,CAA3B;AAEA,UAAIC,gBAAgB,GAAG,IAAvB;AACA,UAAIC,qBAAqB,GAAGvzB,uBAAuB,GAAG,EAAH,GAAQ,IAA3D;;AACA,UAAIA,uBAAJ,EAA6B;AAG3BszB,QAAAA,gBAAgB,GAAGxgD,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA9C;AACAjJ,QAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCisB,IAAI,CAAC+F,oBAA1C;AAUA/F,QAAAA,IAAI,CAACgG,qBAAL,CAA2B1xB,OAA3B,CAAmC,UACjCk3C,qBADiC,EAEjCC,uBAFiC,EAGjC;AACA,cAAIA,uBAAuB,IAAItG,uBAA/B,EAAwD;AACtDoG,YAAAA,qBAAqB,CAACt3C,IAAtB,CAA2BtH,KAA3B,CACE4+C,qBADF,EAEEj/C,KAAK,CAACma,IAAN,CAAW+kC,qBAAX,CAFF;AAIAxrB,YAAAA,IAAI,CAACgG,qBAAL,CAA2BiV,MAA3B,CAAkCwQ,uBAAlC;AACD;AACF,SAXD;AAYD;;AAGDxC,MAAAA,mBAAmB,CAACl1C,OAApB,GAA8B,IAA9B;AAEA,UAAI8uB,WAAW,GAAG,KAAK,CAAvB;;AACA,UAAI0C,YAAY,CAACxa,SAAb,GAAyBtB,aAA7B,EAA4C;AAK1C,YAAI8b,YAAY,CAACzC,UAAb,KAA4B,IAAhC,EAAsC;AACpCyC,UAAAA,YAAY,CAACzC,UAAb,CAAwBF,UAAxB,GAAqC2C,YAArC;AACA1C,UAAAA,WAAW,GAAG0C,YAAY,CAAC1C,WAA3B;AACD,SAHD,MAGO;AACLA,UAAAA,WAAW,GAAG0C,YAAd;AACD;AACF,OAXD,MAWO;AAEL1C,QAAAA,WAAW,GAAG0C,YAAY,CAAC1C,WAA3B;AACD;;AAEDlP,MAAAA,gBAAgB,CAACqM,IAAI,CAACpM,aAAN,CAAhB;AAGAgP,MAAAA,UAAU,GAAGC,WAAb;AACA1G,MAAAA,+BAA+B;;AAC/B,aAAOyG,UAAU,KAAK,IAAtB,EAA4B;AAC1B,YAAIv1B,QAAQ,GAAG,KAAf;AACA,YAAIzB,KAAK,GAAG,KAAK,CAAjB;AACA;AACEgD,UAAAA,qBAAqB,CAAC,IAAD,EAAOo8C,8BAAP,EAAuC,IAAvC,CAArB;;AACA,cAAIh8C,cAAc,EAAlB,EAAsB;AACpB3B,YAAAA,QAAQ,GAAG,IAAX;AACAzB,YAAAA,KAAK,GAAGkD,gBAAgB,EAAxB;AACD;AACF;;AACD,YAAIzB,QAAJ,EAAc;AACZjC,UAAAA,SAAS,CACPw3B,UAAU,KAAK,IADR,EAEP,mEACE,iCAHK,CAAT;AAKA8hB,UAAAA,uBAAuB,CAAC9hB,UAAD,EAAah3B,KAAb,CAAvB;;AAEA,cAAIg3B,UAAU,KAAK,IAAnB,EAAyB;AACvBA,YAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF;;AACDxG,MAAAA,8BAA8B;;AAE9B,UAAIrE,mBAAJ,EAAyB;AAGvBkZ,QAAAA,gBAAgB;AACjB;;AAKDrO,MAAAA,UAAU,GAAGC,WAAb;AACAvG,MAAAA,2BAA2B;;AAC3B,aAAOsG,UAAU,KAAK,IAAtB,EAA4B;AAC1B,YAAI8oB,SAAS,GAAG,KAAhB;;AACA,YAAIC,MAAM,GAAG,KAAK,CAAlB;;AACA;AACE/8C,UAAAA,qBAAqB,CAAC,IAAD,EAAOg8C,oBAAP,EAA6B,IAA7B,CAArB;;AACA,cAAI57C,cAAc,EAAlB,EAAsB;AACpB08C,YAAAA,SAAS,GAAG,IAAZ;AACAC,YAAAA,MAAM,GAAG78C,gBAAgB,EAAzB;AACD;AACF;;AACD,YAAI48C,SAAJ,EAAe;AACbtgD,UAAAA,SAAS,CACPw3B,UAAU,KAAK,IADR,EAEP,mEACE,iCAHK,CAAT;AAKA8hB,UAAAA,uBAAuB,CAAC9hB,UAAD,EAAa+oB,MAAb,CAAvB;;AAEA,cAAI/oB,UAAU,KAAK,IAAnB,EAAyB;AACvBA,YAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF;;AACDrG,MAAAA,0BAA0B;AAE1BvI,MAAAA,gBAAgB,CAACgM,IAAI,CAACpM,aAAN,CAAhB;AAMAoM,MAAAA,IAAI,CAACjsB,OAAL,GAAewxB,YAAf;AAMA3C,MAAAA,UAAU,GAAGC,WAAb;AACArG,MAAAA,0BAA0B;;AAC1B,aAAOoG,UAAU,KAAK,IAAtB,EAA4B;AAC1B,YAAIgpB,UAAU,GAAG,KAAjB;;AACA,YAAIC,OAAO,GAAG,KAAK,CAAnB;;AACA;AACEj9C,UAAAA,qBAAqB,CACnB,IADmB,EAEnBq8C,mBAFmB,EAGnB,IAHmB,EAInBjrB,IAJmB,EAKnBmlB,uBALmB,CAArB;;AAOA,cAAIn2C,cAAc,EAAlB,EAAsB;AACpB48C,YAAAA,UAAU,GAAG,IAAb;AACAC,YAAAA,OAAO,GAAG/8C,gBAAgB,EAA1B;AACD;AACF;;AACD,YAAI88C,UAAJ,EAAgB;AACdxgD,UAAAA,SAAS,CACPw3B,UAAU,KAAK,IADR,EAEP,mEACE,iCAHK,CAAT;AAKA8hB,UAAAA,uBAAuB,CAAC9hB,UAAD,EAAaipB,OAAb,CAAvB;;AACA,cAAIjpB,UAAU,KAAK,IAAnB,EAAyB;AACvBA,YAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF;;AAEDknB,MAAAA,cAAc,GAAG,KAAjB;AACAL,MAAAA,SAAS,GAAG,KAAZ;AACAhtB,MAAAA,yBAAyB;AACzBP,MAAAA,eAAe;AACf+D,MAAAA,YAAY,CAACsF,YAAY,CAAClwB,SAAd,CAAZ;;AACA,UAAI,QAAQo0B,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,QAAAA,2BAA2B,CAACD,SAA5B,CAAsCsiB,YAAtC,CAAmDvmB,YAAnD;AACD;;AAED,UAAIwmB,+BAA+B,GAAGxmB,YAAY,CAACnK,cAAnD;AACA,UAAI4wB,8BAA8B,GAAGzmB,YAAY,CAACxC,mBAAlD;AACA,UAAIkpB,gCAAgC,GAClCF,+BAA+B,KAAK3rB,MAApC,IACC4rB,8BAA8B,KAAK5rB,MAAnC,IACC4rB,8BAA8B,GAAGD,+BAFnC,GAGIC,8BAHJ,GAIID,+BALN;;AAMA,UAAIE,gCAAgC,KAAK7rB,MAAzC,EAAiD;AAG/C2pB,QAAAA,sCAAsC,GAAG,IAAzC;AACD;;AACDmC,MAAAA,QAAQ,CAAClsB,IAAD,EAAOisB,gCAAP,CAAR;;AAEA,UAAIj0B,uBAAJ,EAA6B;AAC3BltB,QAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCu3C,gBAArC;AAEA,YAAIa,UAAU,GAAG,KAAK,CAAtB;;AAEA,YAAI;AACFA,UAAAA,UAAU,GAAGrhD,QAAQ,CAACshD,eAAT,CAAyBr4C,OAAtC;;AACA,cAAIo4C,UAAU,KAAK,IAAf,IAAuBnsB,IAAI,CAAC+F,oBAAL,CAA0BsmB,IAA1B,GAAiC,CAA5D,EAA+D;AAC7D,gBAAIC,QAAQ,GAAGC,eAAe,CAC5BpH,uBAD4B,EAE5BnlB,IAAI,CAAC6F,mBAFuB,CAA9B;AAIAsmB,YAAAA,UAAU,CAACK,aAAX,CAAyBxsB,IAAI,CAAC+F,oBAA9B,EAAoDumB,QAApD;AACD;AACF,SATD,CASE,OAAO1gD,KAAP,EAAc;AAGd,cAAI,CAAC6gD,iBAAL,EAAwB;AACtBA,YAAAA,iBAAiB,GAAG,IAApB;AACAC,YAAAA,cAAc,GAAG9gD,KAAjB;AACD;AACF,SAhBD,SAgBU;AAGR,cAAI,CAACo+C,kBAAL,EAAyB;AAIvBuB,YAAAA,qBAAqB,CAACj3C,OAAtB,CAA8B,UAASq4C,WAAT,EAAsB;AAClDA,cAAAA,WAAW,CAACC,OAAZ;;AACA,kBAAIT,UAAU,KAAK,IAAf,IAAuBQ,WAAW,CAACC,OAAZ,KAAwB,CAAnD,EAAsD;AACpD,oBAAI;AACFT,kBAAAA,UAAU,CAACU,mCAAX,CAA+CF,WAA/C;AACD,iBAFD,CAEE,OAAO/gD,KAAP,EAAc;AAGd,sBAAI,CAAC6gD,iBAAL,EAAwB;AACtBA,oBAAAA,iBAAiB,GAAG,IAApB;AACAC,oBAAAA,cAAc,GAAG9gD,KAAjB;AACD;AACF;AACF;AACF,aAdD;AAeD;AACF;AACF;AACF;;AAED,aAASkhD,wBAAT,CAAkCh2B,cAAlC,EAAkDi2B,UAAlD,EAA8D;AAC5D,UAAIA,UAAU,KAAKzsB,KAAf,IAAwBxJ,cAAc,CAACiM,mBAAf,KAAuCzC,KAAnE,EAA0E;AAGxE;AACD;;AAED,UAAI0sB,sBAAsB,GAAG5sB,MAA7B;;AAGA,UAAIrI,mBAAmB,IAAIjB,cAAc,CAACwL,IAAf,GAAsBV,WAAjD,EAA8D;AAG5D,YAAIoB,cAAc,GAAGlM,cAAc,CAACkM,cAApC;AACA,YAAIG,gBAAgB,GAAGrM,cAAc,CAACoM,gBAAtC;AASA,YAAI+pB,2BAA2B,GAC7Bn2B,cAAc,CAACnf,SAAf,KAA6B,IAA7B,IACAmf,cAAc,CAACnL,KAAf,KAAyBmL,cAAc,CAACnf,SAAf,CAAyBgU,KAFpD;AAIA,YAAIA,KAAK,GAAGmL,cAAc,CAACnL,KAA3B;;AACA,eAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrB,cAAIuhC,yBAAyB,GAAGvhC,KAAK,CAACyP,cAAtC;AACA,cAAI+xB,wBAAwB,GAAGxhC,KAAK,CAACoX,mBAArC;;AACA,cACEiqB,sBAAsB,KAAK5sB,MAA3B,IACC8sB,yBAAyB,KAAK9sB,MAA9B,IACC8sB,yBAAyB,GAAGF,sBAHhC,EAIE;AACAA,YAAAA,sBAAsB,GAAGE,yBAAzB;AACD;;AACD,cACEF,sBAAsB,KAAK5sB,MAA3B,IACC+sB,wBAAwB,KAAK/sB,MAA7B,IACC+sB,wBAAwB,GAAGH,sBAH/B,EAIE;AACAA,YAAAA,sBAAsB,GAAGG,wBAAzB;AACD;;AACD,cAAIF,2BAAJ,EAAiC;AAC/BjqB,YAAAA,cAAc,IAAIrX,KAAK,CAACqX,cAAxB;AACD;;AACDG,UAAAA,gBAAgB,IAAIxX,KAAK,CAACwX,gBAA1B;AACAxX,UAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AACDkL,QAAAA,cAAc,CAACkM,cAAf,GAAgCA,cAAhC;AACAlM,QAAAA,cAAc,CAACqM,gBAAf,GAAkCA,gBAAlC;AACD,OA3CD,MA2CO;AACL,YAAIrX,MAAM,GAAGgL,cAAc,CAACnL,KAA5B;;AACA,eAAOG,MAAM,KAAK,IAAlB,EAAwB;AACtB,cAAIshC,0BAA0B,GAAGthC,MAAM,CAACsP,cAAxC;AACA,cAAIiyB,yBAAyB,GAAGvhC,MAAM,CAACiX,mBAAvC;;AACA,cACEiqB,sBAAsB,KAAK5sB,MAA3B,IACCgtB,0BAA0B,KAAKhtB,MAA/B,IACCgtB,0BAA0B,GAAGJ,sBAHjC,EAIE;AACAA,YAAAA,sBAAsB,GAAGI,0BAAzB;AACD;;AACD,cACEJ,sBAAsB,KAAK5sB,MAA3B,IACCitB,yBAAyB,KAAKjtB,MAA9B,IACCitB,yBAAyB,GAAGL,sBAHhC,EAIE;AACAA,YAAAA,sBAAsB,GAAGK,yBAAzB;AACD;;AACDvhC,UAAAA,MAAM,GAAGA,MAAM,CAACF,OAAhB;AACD;AACF;;AAEDkL,MAAAA,cAAc,CAACiM,mBAAf,GAAqCiqB,sBAArC;AACD;;AAED,aAASM,kBAAT,CAA4Bx2B,cAA5B,EAA4C;AAI1C,aAAO,IAAP,EAAa;AAKX,YAAI2gB,UAAU,GAAG3gB,cAAc,CAACnf,SAAhC;AACA;AACEyf,UAAAA,eAAe,CAACN,cAAD,CAAf;AACD;AAED,YAAI0gB,WAAW,GAAG1gB,cAAc,CAAC5f,MAAjC;AACA,YAAIq2C,YAAY,GAAGz2B,cAAc,CAAClL,OAAlC;;AAEA,YAAI,CAACkL,cAAc,CAAC/L,SAAf,GAA2BV,UAA5B,MAA4Cb,QAAhD,EAA0D;AAExD,cAAIuO,mBAAJ,EAAyB;AACvB,gBAAIjB,cAAc,CAACwL,IAAf,GAAsBV,WAA1B,EAAuC;AACrCsP,cAAAA,kBAAkB,CAACpa,cAAD,CAAlB;AACD;;AAED8E,YAAAA,cAAc,GAAGinB,YAAY,CAC3BpL,UAD2B,EAE3B3gB,cAF2B,EAG3B6yB,wBAH2B,CAA7B;;AAMA,gBAAI7yB,cAAc,CAACwL,IAAf,GAAsBV,WAA1B,EAAuC;AAErCwP,cAAAA,wCAAwC,CAACta,cAAD,EAAiB,KAAjB,CAAxC;AACD;AACF,WAfD,MAeO;AACL8E,YAAAA,cAAc,GAAGinB,YAAY,CAC3BpL,UAD2B,EAE3B3gB,cAF2B,EAG3B6yB,wBAH2B,CAA7B;AAKD;;AACD,cAAI31C,IAAI,GAAG4nB,cAAX;AACAL,UAAAA,aAAa,CAACzE,cAAD,CAAb;AACAg2B,UAAAA,wBAAwB,CAACh2B,cAAD,EAAiB6yB,wBAAjB,CAAxB;AACA;AACEzyB,YAAAA,iBAAiB;AAClB;;AAED,cAAIljB,IAAI,KAAK,IAAb,EAAmB;AACjBunB,YAAAA,aAAa,CAACzE,cAAD,CAAb;;AACA,gBAAI,QAAQ2S,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,cAAAA,2BAA2B,CAACD,SAA5B,CAAsCgkB,cAAtC,CAAqD12B,cAArD;AACD;;AAGD,mBAAO9iB,IAAP;AACD;;AAED,cACEwjC,WAAW,KAAK,IAAhB,IAEA,CAACA,WAAW,CAACzsB,SAAZ,GAAwBV,UAAzB,MAAyCb,QAH3C,EAIE;AAIA,gBAAIguB,WAAW,CAAC3U,WAAZ,KAA4B,IAAhC,EAAsC;AACpC2U,cAAAA,WAAW,CAAC3U,WAAZ,GAA0B/L,cAAc,CAAC+L,WAAzC;AACD;;AACD,gBAAI/L,cAAc,CAACgM,UAAf,KAA8B,IAAlC,EAAwC;AACtC,kBAAI0U,WAAW,CAAC1U,UAAZ,KAA2B,IAA/B,EAAqC;AACnC0U,gBAAAA,WAAW,CAAC1U,UAAZ,CAAuBF,UAAvB,GAAoC9L,cAAc,CAAC+L,WAAnD;AACD;;AACD2U,cAAAA,WAAW,CAAC1U,UAAZ,GAAyBhM,cAAc,CAACgM,UAAxC;AACD;;AAQD,gBAAI/X,SAAS,GAAG+L,cAAc,CAAC/L,SAA/B;;AAGA,gBAAIA,SAAS,GAAGtB,aAAhB,EAA+B;AAC7B,kBAAI+tB,WAAW,CAAC1U,UAAZ,KAA2B,IAA/B,EAAqC;AACnC0U,gBAAAA,WAAW,CAAC1U,UAAZ,CAAuBF,UAAvB,GAAoC9L,cAApC;AACD,eAFD,MAEO;AACL0gB,gBAAAA,WAAW,CAAC3U,WAAZ,GAA0B/L,cAA1B;AACD;;AACD0gB,cAAAA,WAAW,CAAC1U,UAAZ,GAAyBhM,cAAzB;AACD;AACF;;AAED,cAAI,QAAQ2S,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,YAAAA,2BAA2B,CAACD,SAA5B,CAAsCgkB,cAAtC,CAAqD12B,cAArD;AACD;;AAED,cAAIy2B,YAAY,KAAK,IAArB,EAA2B;AAEzB,mBAAOA,YAAP;AACD,WAHD,MAGO,IAAI/V,WAAW,KAAK,IAApB,EAA0B;AAE/B1gB,YAAAA,cAAc,GAAG0gB,WAAjB;AACA;AACD,WAJM,MAIA;AAEL,mBAAO,IAAP;AACD;AACF,SA7FD,MA6FO;AACL,cAAI1gB,cAAc,CAACwL,IAAf,GAAsBV,WAA1B,EAAuC;AAErCwP,YAAAA,wCAAwC,CAACta,cAAD,EAAiB,KAAjB,CAAxC;AACD;;AAKD,cAAI22B,KAAK,GAAGhF,UAAU,CAAC3xB,cAAD,EAAiB6yB,wBAAjB,CAAtB;;AAEA,cAAI7yB,cAAc,CAAC/L,SAAf,GAA2Bf,UAA/B,EAA2C;AAEzCwR,YAAAA,mBAAmB,CAAC1E,cAAD,CAAnB;AACD,WAHD,MAGO;AACLyE,YAAAA,aAAa,CAACzE,cAAD,CAAb;AACD;;AAED;AACEI,YAAAA,iBAAiB;AAClB;;AAED,cAAIu2B,KAAK,KAAK,IAAd,EAAoB;AAClBlyB,YAAAA,aAAa,CAACzE,cAAD,CAAb;;AACA,gBAAI,QAAQ2S,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,cAAAA,2BAA2B,CAACD,SAA5B,CAAsCgkB,cAAtC,CAAqD12B,cAArD;AACD;;AAED,gBAAIiB,mBAAJ,EAAyB;AAEvB,kBAAI01B,KAAK,CAACnrB,IAAN,GAAaV,WAAjB,EAA8B;AAC5B,oBAAIoB,cAAc,GAAGyqB,KAAK,CAACzqB,cAA3B;AACA,oBAAIrX,KAAK,GAAG8hC,KAAK,CAAC9hC,KAAlB;;AACA,uBAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrBqX,kBAAAA,cAAc,IAAIrX,KAAK,CAACqX,cAAxB;AACArX,kBAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AACD6hC,gBAAAA,KAAK,CAACzqB,cAAN,GAAuBA,cAAvB;AACD;AACF;;AAMDyqB,YAAAA,KAAK,CAAC1iC,SAAN,IAAmBX,cAAnB;AACA,mBAAOqjC,KAAP;AACD;;AAED,cAAIjW,WAAW,KAAK,IAApB,EAA0B;AAExBA,YAAAA,WAAW,CAAC3U,WAAZ,GAA0B2U,WAAW,CAAC1U,UAAZ,GAAyB,IAAnD;AACA0U,YAAAA,WAAW,CAACzsB,SAAZ,IAAyBV,UAAzB;AACD;;AAED,cAAI,QAAQof,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,YAAAA,2BAA2B,CAACD,SAA5B,CAAsCgkB,cAAtC,CAAqD12B,cAArD;AACD;;AAED,cAAIy2B,YAAY,KAAK,IAArB,EAA2B;AAEzB,mBAAOA,YAAP;AACD,WAHD,MAGO,IAAI/V,WAAW,KAAK,IAApB,EAA0B;AAE/B1gB,YAAAA,cAAc,GAAG0gB,WAAjB;AACA;AACD,WAJM,MAIA;AACL,mBAAO,IAAP;AACD;AACF;AACF;;AAKD,aAAO,IAAP;AACD;;AAED,aAASkW,iBAAT,CAA2B52B,cAA3B,EAA2C;AAKzC,UAAI2gB,UAAU,GAAG3gB,cAAc,CAACnf,SAAhC;AAGA0jB,MAAAA,cAAc,CAACvE,cAAD,CAAd;AACA;AACEM,QAAAA,eAAe,CAACN,cAAD,CAAf;AACD;;AAED,UAAI,QAAQc,+CAAZ,EAA6D;AAC3DqyB,QAAAA,+BAA+B,GAAGplB,0BAA0B,CAC1DolB,+BAD0D,EAE1DnzB,cAF0D,CAA5D;AAID;;AAED,UAAI9iB,IAAI,GAAG,KAAK,CAAhB;;AACA,UAAI+jB,mBAAJ,EAAyB;AACvB,YAAIjB,cAAc,CAACwL,IAAf,GAAsBV,WAA1B,EAAuC;AACrCsP,UAAAA,kBAAkB,CAACpa,cAAD,CAAlB;AACD;;AAED9iB,QAAAA,IAAI,GAAG6sC,SAAS,CAACpJ,UAAD,EAAa3gB,cAAb,EAA6B6yB,wBAA7B,CAAhB;;AAEA,YAAI7yB,cAAc,CAACwL,IAAf,GAAsBV,WAA1B,EAAuC;AAErCwP,UAAAA,wCAAwC,CAACta,cAAD,EAAiB,IAAjB,CAAxC;AACD;AACF,OAXD,MAWO;AACL9iB,QAAAA,IAAI,GAAG6sC,SAAS,CAACpJ,UAAD,EAAa3gB,cAAb,EAA6B6yB,wBAA7B,CAAhB;AACD;;AAED;AACEzyB,QAAAA,iBAAiB;;AACjB,YAAIizB,2BAAJ,EAAiC;AAK/BE,UAAAA,oBAAoB;AACrB;AACF;;AACD,UAAI,QAAQ5gB,2BAA2B,CAACD,SAAxC,EAAmD;AACjDC,QAAAA,2BAA2B,CAACD,SAA5B,CAAsCmkB,WAAtC,CAAkD72B,cAAlD;AACD;;AAED,UAAI9iB,IAAI,KAAK,IAAb,EAAmB;AAEjBA,QAAAA,IAAI,GAAGs5C,kBAAkB,CAACx2B,cAAD,CAAzB;AACD;;AAEDmyB,MAAAA,mBAAmB,CAACl1C,OAApB,GAA8B,IAA9B;AAEA,aAAOC,IAAP;AACD;;AAED,aAASy2C,QAAT,CAAkBD,QAAlB,EAA4B;AAC1B,UAAI,CAACA,QAAL,EAAe;AAEb,eAAO5uB,cAAc,KAAK,IAA1B,EAAgC;AAC9BA,UAAAA,cAAc,GAAG8xB,iBAAiB,CAAC9xB,cAAD,CAAlC;AACD;AACF,OALD,MAKO;AAEL,eAAOA,cAAc,KAAK,IAAnB,IAA2B,CAACgyB,WAAW,EAA9C,EAAkD;AAChDhyB,UAAAA,cAAc,GAAG8xB,iBAAiB,CAAC9xB,cAAD,CAAlC;AACD;AACF;AACF;;AAED,aAASiyB,UAAT,CAAoB7tB,IAApB,EAA0BwqB,QAA1B,EAAoCsD,SAApC,EAA+C;AAC7C1iD,MAAAA,SAAS,CACP,CAACq+C,SADM,EAEP,oEACE,0CAHK,CAAT;AAKAA,MAAAA,SAAS,GAAG,IAAZ;AACAR,MAAAA,mBAAmB,CAAC8E,iBAApB,GAAwC/E,UAAxC;AAEA,UAAI5tB,cAAc,GAAG4E,IAAI,CAAC0F,0BAA1B;AAEA,UAAI4lB,gBAAgB,GAAG,IAAvB;;AACA,UAAItzB,uBAAJ,EAA6B;AAG3BszB,QAAAA,gBAAgB,GAAGxgD,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA9C;AACAjJ,QAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCisB,IAAI,CAAC+F,oBAA1C;AACD;;AAID,UACE3K,cAAc,KAAKuuB,wBAAnB,IACA3pB,IAAI,KAAK0pB,QADT,IAEA9tB,cAAc,KAAK,IAHrB,EAIE;AAEA+uB,QAAAA,UAAU;AACVjB,QAAAA,QAAQ,GAAG1pB,IAAX;AACA2pB,QAAAA,wBAAwB,GAAGvuB,cAA3B;AACAQ,QAAAA,cAAc,GAAG4H,oBAAoB,CACnCkmB,QAAQ,CAAC31C,OAD0B,EAEnC,IAFmC,EAGnC41C,wBAHmC,CAArC;AAKA3pB,QAAAA,IAAI,CAACsF,2BAAL,GAAmClF,MAAnC;;AAEA,YAAIpI,uBAAJ,EAA6B;AAG3B,cAAIg2B,YAAY,GAAG,IAAI/0B,GAAJ,EAAnB;AACA+G,UAAAA,IAAI,CAACgG,qBAAL,CAA2B1xB,OAA3B,CAAmC,UACjCk3C,qBADiC,EAEjCC,uBAFiC,EAGjC;AACA,gBAAIA,uBAAuB,IAAIrwB,cAA/B,EAA+C;AAC7CowB,cAAAA,qBAAqB,CAACl3C,OAAtB,CAA8B,UAASq4C,WAAT,EAAsB;AAClD,uBAAOqB,YAAY,CAAC1zB,GAAb,CAAiBqyB,WAAjB,CAAP;AACD,eAFD;AAGD;AACF,WATD;AAeA3sB,UAAAA,IAAI,CAAC+F,oBAAL,GAA4BioB,YAA5B;;AAEA,cAAIA,YAAY,CAAC3B,IAAb,GAAoB,CAAxB,EAA2B;AACzB,gBAAIF,UAAU,GAAGrhD,QAAQ,CAACshD,eAAT,CAAyBr4C,OAA1C;;AACA,gBAAIo4C,UAAU,KAAK,IAAnB,EAAyB;AACvB,kBAAIG,QAAQ,GAAGC,eAAe,CAC5BnxB,cAD4B,EAE5B4E,IAAI,CAAC6F,mBAFuB,CAA9B;;AAIA,kBAAI;AACFsmB,gBAAAA,UAAU,CAAC8B,aAAX,CAAyBD,YAAzB,EAAuC1B,QAAvC;AACD,eAFD,CAEE,OAAO1gD,KAAP,EAAc;AAId,oBAAI,CAAC6gD,iBAAL,EAAwB;AACtBA,kBAAAA,iBAAiB,GAAG,IAApB;AACAC,kBAAAA,cAAc,GAAG9gD,KAAjB;AACD;AACF;AACF;AACF;AACF;AACF;;AAED,UAAIsiD,QAAQ,GAAG,KAAf;AAEAvyB,MAAAA,kBAAkB,CAACC,cAAD,CAAlB;;AAEA,SAAG;AACD,YAAI;AACF6uB,UAAAA,QAAQ,CAACD,QAAD,CAAR;AACD,SAFD,CAEE,OAAOD,WAAP,EAAoB;AACpB,cAAI3uB,cAAc,KAAK,IAAvB,EAA6B;AAE3BsyB,YAAAA,QAAQ,GAAG,IAAX;AACA/G,YAAAA,eAAe,CAACoD,WAAD,CAAf;AACD,WAJD,MAIO;AACL;AAGEpf,cAAAA,6BAA6B;AAC9B;AAED,gBAAImf,gBAAgB,GAAG1uB,cAAvB;;AACA,gBAAI,QAAQhE,+CAAZ,EAA6D;AAC3DsyB,cAAAA,gBAAgB,CAACI,gBAAD,EAAmBC,WAAnB,EAAgCC,QAAhC,CAAhB;AACD;;AAKDp/C,YAAAA,SAAS,CACPwwB,cAAc,KAAK,IADZ,EAEP,qDACE,2DADF,GAEE,6CAJK,CAAT;AAOA,gBAAI4rB,WAAW,GAAG5rB,cAAlB;AACA,gBAAI4b,WAAW,GAAGgQ,WAAW,CAACtwC,MAA9B;;AACA,gBAAIsgC,WAAW,KAAK,IAApB,EAA0B;AAOxB0W,cAAAA,QAAQ,GAAG,IAAX;AACA/G,cAAAA,eAAe,CAACoD,WAAD,CAAf;AACD,aATD,MASO;AACLhD,cAAAA,cAAc,CACZvnB,IADY,EAEZwX,WAFY,EAGZgQ,WAHY,EAIZ+C,WAJY,EAKZZ,wBALY,CAAd;AAOA/tB,cAAAA,cAAc,GAAG0xB,kBAAkB,CAAC9F,WAAD,CAAnC;AACA;AACD;AACF;AACF;;AACD;AACD,OAvDD,QAuDS,IAvDT;;AAyDA,UAAIxvB,uBAAJ,EAA6B;AAE3BltB,QAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCu3C,gBAArC;AACD;;AAGD7B,MAAAA,SAAS,GAAG,KAAZ;AACAR,MAAAA,mBAAmB,CAAC8E,iBAApB,GAAwC,IAAxC;AACAvf,MAAAA,uBAAuB;;AAGvB,UAAI0f,QAAJ,EAAc;AACZ,YAAIC,gBAAgB,GAAG,KAAvB;AACAtyB,QAAAA,iBAAiB,CAACC,aAAD,EAAgBqyB,gBAAhB,CAAjB;AACAryB,QAAAA,aAAa,GAAG,IAAhB;AAEA;AACEkB,UAAAA,8BAA8B;AAC/B;AAID0sB,QAAAA,QAAQ,GAAG,IAAX;AACA0E,QAAAA,OAAO,CAACpuB,IAAD,CAAP;AACA;AACD;;AAED,UAAIpE,cAAc,KAAK,IAAvB,EAA6B;AAK3B,YAAIyyB,iBAAiB,GAAG,KAAxB;AACAxyB,QAAAA,iBAAiB,CAACC,aAAD,EAAgBuyB,iBAAhB,CAAjB;AACAvyB,QAAAA,aAAa,GAAG,IAAhB;AACAwyB,QAAAA,OAAO,CAACtuB,IAAD,CAAP;AACA;AACD;;AAGD,UAAIjE,eAAe,GAAG,IAAtB;AACAF,MAAAA,iBAAiB,CAACC,aAAD,EAAgBC,eAAhB,CAAjB;AACA,UAAIwyB,kBAAkB,GAAGvuB,IAAI,CAACjsB,OAAL,CAAa4D,SAAtC;AACAvM,MAAAA,SAAS,CACPmjD,kBAAkB,KAAK,IADhB,EAEP,wEACE,iDAHK,CAAT;AASA7E,MAAAA,QAAQ,GAAG,IAAX;AACA5tB,MAAAA,aAAa,GAAG,IAAhB;;AAEA,UAAI+tB,kBAAJ,EAAwB;AAEtB,YAAI/f,oBAAoB,CAAC9J,IAAD,EAAO5E,cAAP,CAAxB,EAAgD;AAM9C6O,UAAAA,0BAA0B,CAACjK,IAAD,EAAO5E,cAAP,CAA1B;AACA,cAAIozB,uBAAuB,GAAGpzB,cAA9B;AACA,cAAIqzB,kBAAkB,GAAGzuB,IAAI,CAAC5E,cAA9B;AACAszB,UAAAA,SAAS,CACP1uB,IADO,EAEPuuB,kBAFO,EAGPC,uBAHO,EAIPC,kBAJO,EAKP,CAAC,CALM,CAAT;AAOA;AACD,SAjBD,MAiBO,IAKL,CAACzuB,IAAI,CAAC3yB,QAAN,IACA,CAACygD,SANI,EAOL;AACA9tB,UAAAA,IAAI,CAAC3yB,QAAL,GAAgB,IAAhB;;AACA,cAAIshD,wBAAwB,GAAI3uB,IAAI,CAAC0F,0BAAL,GAAkCtK,cAAlE;;AACA,cAAIwzB,mBAAmB,GAAI5uB,IAAI,CAAC5E,cAAL,GAAsBiF,IAAjD;;AACAquB,UAAAA,SAAS,CACP1uB,IADO,EAEPuuB,kBAFO,EAGPI,wBAHO,EAIPC,mBAJO,EAKP,CAAC,CALM,CAAT;AAOA;AACD;AACF;;AAED,UAAIl3B,cAAc,IAAI,CAACo2B,SAAnB,IAAgClE,2BAA2B,KAAK,CAAC,CAArE,EAAwE;AAEtE,YAAIiF,yBAAyB,GAAGzzB,cAAhC;AACA6O,QAAAA,0BAA0B,CAACjK,IAAD,EAAO6uB,yBAAP,CAA1B;AAKA,YAAIpkB,sBAAsB,GAAGF,oCAAoC,CAC/DvK,IAD+D,EAE/D5E,cAF+D,CAAjE;AAIA,YAAI+sB,wBAAwB,GAAGxnB,kBAAkB,CAAC8J,sBAAD,CAAjD;;AACA,YAAI0d,wBAAwB,GAAGyB,2BAA/B,EAA4D;AAC1DA,UAAAA,2BAA2B,GAAGzB,wBAA9B;AACD;;AAMD,YAAI2G,aAAa,GAAGnuB,kBAAkB,CAACsS,kBAAkB,EAAnB,CAAtC;AACA,YAAI8b,cAAc,GAAGnF,2BAA2B,GAAGkF,aAAnD;AACAC,QAAAA,cAAc,GAAGA,cAAc,GAAG,CAAjB,GAAqB,CAArB,GAAyBA,cAA1C;AAIA,YAAIC,oBAAoB,GAAGhvB,IAAI,CAAC5E,cAAhC;AACAszB,QAAAA,SAAS,CACP1uB,IADO,EAEPuuB,kBAFO,EAGPM,yBAHO,EAIPG,oBAJO,EAKPD,cALO,CAAT;AAOA;AACD;;AAGDE,MAAAA,UAAU,CAACjvB,IAAD,EAAOuuB,kBAAP,EAA2BnzB,cAA3B,CAAV;AACD;;AAED,aAAS8zB,QAAT,CAAkB1H,WAAlB,EAA+BtgC,KAA/B,EAAsCkU,cAAtC,EAAsD;AACpDhwB,MAAAA,SAAS,CACP,CAACq+C,SAAD,IAAcK,cADP,EAEP,oDAFO,CAAT;AAKA,UAAIj/B,KAAK,GAAG28B,WAAW,CAACtwC,MAAxB;;AACA,aAAO2T,KAAK,KAAK,IAAjB,EAAuB;AACrB,gBAAQA,KAAK,CAAC9V,GAAd;AACE,eAAKmB,cAAL;AACA,eAAKC,kBAAL;AACE,gBAAI08B,IAAI,GAAGhoB,KAAK,CAAC5X,IAAjB;AACA,gBAAI6I,QAAQ,GAAG+O,KAAK,CAACxV,SAArB;;AACA,gBACE,OAAOw9B,IAAI,CAAC0C,wBAAZ,KAAyC,UAAzC,IACC,OAAOz5B,QAAQ,CAACurC,iBAAhB,KAAsC,UAAtC,IACC,CAACkB,kCAAkC,CAACzsC,QAAD,CAHvC,EAIE;AACA,kBAAIsoC,SAAS,GAAGrW,mBAAmB,CAAC7mB,KAAD,EAAQsgC,WAAR,CAAnC;AACA,kBAAItb,MAAM,GAAGkb,sBAAsB,CAACv8B,KAAD,EAAQu5B,SAAR,EAAmBhpB,cAAnB,CAAnC;AACA+Q,cAAAA,aAAa,CAACthB,KAAD,EAAQqhB,MAAR,CAAb;AACAiH,cAAAA,YAAY,CAACtoB,KAAD,EAAQuQ,cAAR,CAAZ;AACA;AACD;;AACD;;AACF,eAAK/kB,QAAL;AAAe;AACb,kBAAIiyC,UAAU,GAAGva,mBAAmB,CAAC7mB,KAAD,EAAQsgC,WAAR,CAApC;;AACA,kBAAIgB,OAAO,GAAGtB,qBAAqB,CAACr8B,KAAD,EAAQy9B,UAAR,EAAoBltB,cAApB,CAAnC;;AACA+Q,cAAAA,aAAa,CAACthB,KAAD,EAAQ29B,OAAR,CAAb;AACArV,cAAAA,YAAY,CAACtoB,KAAD,EAAQuQ,cAAR,CAAZ;AACA;AACD;AAvBH;;AAyBAvQ,QAAAA,KAAK,GAAGA,KAAK,CAAC3T,MAAd;AACD;;AAED,UAAIswC,WAAW,CAACzyC,GAAZ,KAAoBsB,QAAxB,EAAkC;AAGhC,YAAI84C,SAAS,GAAG3H,WAAhB;;AACA,YAAI4H,WAAW,GAAGrhB,mBAAmB,CAAC7mB,KAAD,EAAQioC,SAAR,CAArC;;AACA,YAAIE,QAAQ,GAAGnI,qBAAqB,CAClCiI,SADkC,EAElCC,WAFkC,EAGlCh0B,cAHkC,CAApC;;AAKA+Q,QAAAA,aAAa,CAACgjB,SAAD,EAAYE,QAAZ,CAAb;AACAlc,QAAAA,YAAY,CAACgc,SAAD,EAAY/zB,cAAZ,CAAZ;AACD;AACF;;AAED,aAASspB,uBAAT,CAAiC75B,KAAjC,EAAwCjf,KAAxC,EAA+C;AAC7C,aAAOsjD,QAAQ,CAACrkC,KAAD,EAAQjf,KAAR,EAAey0B,IAAf,CAAf;AACD;;AAED,aAASksB,eAAT,CAAyBnxB,cAAzB,EAAyCyK,mBAAzC,EAA8D;AAE5D,aAAOzK,cAAc,GAAG,IAAjB,GAAwByK,mBAA/B;AACD;;AAED,aAASqN,yBAAT,CAAmClS,WAAnC,EAAgDnW,KAAhD,EAAuD;AACrD,UAAIuQ,cAAc,GAAG,KAAK,CAA1B;;AACA,UAAIouB,iBAAiB,KAAKppB,MAA1B,EAAkC;AAEhChF,QAAAA,cAAc,GAAGouB,iBAAjB;AACD,OAHD,MAGO,IAAIC,SAAJ,EAAe;AACpB,YAAIK,cAAJ,EAAoB;AAGlB1uB,UAAAA,cAAc,GAAGiF,IAAjB;AACD,SAJD,MAIO;AAGLjF,UAAAA,cAAc,GAAGuuB,wBAAjB;AACD;AACF,OAVM,MAUA;AAGL,YAAI9+B,KAAK,CAACyX,IAAN,GAAaZ,SAAjB,EAA4B;AAC1B,cAAI4tB,4BAAJ,EAAkC;AAEhCl0B,YAAAA,cAAc,GAAGoG,4BAA4B,CAACR,WAAD,CAA7C;AACD,WAHD,MAGO;AAEL5F,YAAAA,cAAc,GAAGiG,sBAAsB,CAACL,WAAD,CAAvC;AACD;;AAGD,cAAI0oB,QAAQ,KAAK,IAAb,IAAqBtuB,cAAc,KAAKuuB,wBAA5C,EAAsE;AACpEvuB,YAAAA,cAAc,IAAI,CAAlB;AACD;AACF,SAbD,MAaO;AAELA,UAAAA,cAAc,GAAGiF,IAAjB;AACD;AACF;;AACD,UAAIivB,4BAAJ,EAAkC;AAIhC,YACEC,8CAA8C,KAAKnvB,MAAnD,IACAhF,cAAc,GAAGm0B,8CAFnB,EAGE;AACAA,UAAAA,8CAA8C,GAAGn0B,cAAjD;AACD;AACF;;AACD,aAAOA,cAAP;AACD;;AAED,aAASgtB,gBAAT,CAA0BpoB,IAA1B,EAAgCkoB,iBAAhC,EAAmDhe,aAAnD,EAAkE;AAEhE,UACEge,iBAAiB,IAAI,CAArB,IACA0B,2BAA2B,GAAG1B,iBAFhC,EAGE;AACA0B,QAAAA,2BAA2B,GAAG1B,iBAA9B;AACD;AACF;;AAED,aAASG,cAAT,GAA0B;AACxBwB,MAAAA,kBAAkB,GAAG,IAArB;AACD;;AAED,aAAS7B,kBAAT,CAA4BhoB,IAA5B,EAAkCnV,KAAlC,EAAyCqf,aAAzC,EAAwD;AACtD,UAAIxS,cAAJ,EAAoB;AAClB,YAAI83B,SAAS,GAAG,KAAK,CAArB;;AAEA,YAAIxlB,wBAAwB,CAAChK,IAAD,EAAOkK,aAAP,CAA5B,EAAmD;AAEjDslB,UAAAA,SAAS,GAAGtlB,aAAZ;AACAE,UAAAA,uBAAuB,CAACpK,IAAD,EAAOwvB,SAAP,CAAvB;AACD,SAJD,MAIO;AAEL,cAAIxuB,WAAW,GAAGiS,kBAAkB,EAApC;AACAuc,UAAAA,SAAS,GAAGtc,yBAAyB,CAAClS,WAAD,EAAcnW,KAAd,CAArC;AACA6e,UAAAA,wBAAwB,CAAC1J,IAAD,EAAOwvB,SAAP,CAAxB;AACD;;AAEDC,QAAAA,kBAAkB,CAAC5kC,KAAD,EAAQ2kC,SAAR,CAAlB;AACA,YAAIf,kBAAkB,GAAGzuB,IAAI,CAAC5E,cAA9B;;AACA,YAAIqzB,kBAAkB,KAAKruB,MAA3B,EAAmC;AACjC,cAAIpI,uBAAJ,EAA6B;AAE3B,gBAAIszB,gBAAgB,GAAGxgD,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAAlD;AACAjJ,YAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCisB,IAAI,CAAC+F,oBAA1C;AAGA2pB,YAAAA,kCAAkC,CAAC1vB,IAAD,EAAOyuB,kBAAP,EAA2B,KAA3B,CAAlC;AACAkB,YAAAA,WAAW,CAAC3vB,IAAD,EAAOyuB,kBAAP,CAAX;AACA3jD,YAAAA,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA3B,GAAqCu3C,gBAArC;AACD,WATD,MASO;AACLqE,YAAAA,WAAW,CAAC3vB,IAAD,EAAOyuB,kBAAP,CAAX;AACD;AACF;AACF;AACF;;AAED,aAASgB,kBAAT,CAA4B5kC,KAA5B,EAAmCuQ,cAAnC,EAAmD;AAEjD,UACEvQ,KAAK,CAACuQ,cAAN,KAAyBgF,MAAzB,IACAvV,KAAK,CAACuQ,cAAN,GAAuBA,cAFzB,EAGE;AACAvQ,QAAAA,KAAK,CAACuQ,cAAN,GAAuBA,cAAvB;AACD;;AACD,UAAIzjB,SAAS,GAAGkT,KAAK,CAAClT,SAAtB;;AACA,UACEA,SAAS,KAAK,IAAd,KACCA,SAAS,CAACyjB,cAAV,KAA6BgF,MAA7B,IACCzoB,SAAS,CAACyjB,cAAV,GAA2BA,cAF7B,CADF,EAIE;AACAzjB,QAAAA,SAAS,CAACyjB,cAAV,GAA2BA,cAA3B;AACD;;AAED,UAAItQ,IAAI,GAAGD,KAAK,CAAC3T,MAAjB;;AACA,UAAI4T,IAAI,KAAK,IAAT,IAAiBD,KAAK,CAAC9V,GAAN,KAAcsB,QAAnC,EAA6C;AAC3C,eAAOwU,KAAK,CAACxV,SAAb;AACD;;AACD,aAAOyV,IAAI,KAAK,IAAhB,EAAsB;AACpBnT,QAAAA,SAAS,GAAGmT,IAAI,CAACnT,SAAjB;;AACA,YACEmT,IAAI,CAACiY,mBAAL,KAA6B3C,MAA7B,IACAtV,IAAI,CAACiY,mBAAL,GAA2B3H,cAF7B,EAGE;AACAtQ,UAAAA,IAAI,CAACiY,mBAAL,GAA2B3H,cAA3B;;AACA,cACEzjB,SAAS,KAAK,IAAd,KACCA,SAAS,CAACorB,mBAAV,KAAkC3C,MAAlC,IACCzoB,SAAS,CAACorB,mBAAV,GAAgC3H,cAFlC,CADF,EAIE;AACAzjB,YAAAA,SAAS,CAACorB,mBAAV,GAAgC3H,cAAhC;AACD;AACF,SAZD,MAYO,IACLzjB,SAAS,KAAK,IAAd,KACCA,SAAS,CAACorB,mBAAV,KAAkC3C,MAAlC,IACCzoB,SAAS,CAACorB,mBAAV,GAAgC3H,cAFlC,CADK,EAIL;AACAzjB,UAAAA,SAAS,CAACorB,mBAAV,GAAgC3H,cAAhC;AACD;;AACD,YAAItQ,IAAI,CAAC5T,MAAL,KAAgB,IAAhB,IAAwB4T,IAAI,CAAC/V,GAAL,KAAasB,QAAzC,EAAmD;AACjD,iBAAOyU,IAAI,CAACzV,SAAZ;AACD;;AACDyV,QAAAA,IAAI,GAAGA,IAAI,CAAC5T,MAAZ;AACD;;AACD,aAAO,IAAP;AACD;;AAED,aAASw4C,kCAAT,CACE1vB,IADF,EAEE5E,cAFF,EAGEw0B,uBAHF,EAIE;AACA,UAAI,CAAC53B,uBAAL,EAA8B;AAC5B;AACD;;AAED,UAAIg2B,YAAY,GAAGljD,QAAQ,CAACw+C,iBAAT,CAA2Bv1C,OAA9C;;AACA,UAAIi6C,YAAY,CAAC3B,IAAb,GAAoB,CAAxB,EAA2B;AACzB,YAAIwD,mBAAmB,GAAG7vB,IAAI,CAACgG,qBAAL,CAA2B7qB,GAA3B,CAA+BigB,cAA/B,CAA1B;;AACA,YAAIy0B,mBAAmB,IAAI,IAA3B,EAAiC;AAC/B7B,UAAAA,YAAY,CAAC15C,OAAb,CAAqB,UAASq4C,WAAT,EAAsB;AACzC,gBAAIiD,uBAAuB,IAAI,CAACC,mBAAmB,CAACx1B,GAApB,CAAwBsyB,WAAxB,CAAhC,EAAsE;AAEpEA,cAAAA,WAAW,CAACC,OAAZ;AACD;;AAEDiD,YAAAA,mBAAmB,CAACv1B,GAApB,CAAwBqyB,WAAxB;AACD,WAPD;AAQD,SATD,MASO;AACL3sB,UAAAA,IAAI,CAACgG,qBAAL,CAA2B9qB,GAA3B,CAA+BkgB,cAA/B,EAA+C,IAAInC,GAAJ,CAAQ+0B,YAAR,CAA/C;;AAGA,cAAI4B,uBAAJ,EAA6B;AAC3B5B,YAAAA,YAAY,CAAC15C,OAAb,CAAqB,UAASq4C,WAAT,EAAsB;AACzCA,cAAAA,WAAW,CAACC,OAAZ;AACD,aAFD;AAGD;AACF;;AAED,YAAIT,UAAU,GAAGrhD,QAAQ,CAACshD,eAAT,CAAyBr4C,OAA1C;;AACA,YAAIo4C,UAAU,KAAK,IAAnB,EAAyB;AACvB,cAAIG,QAAQ,GAAGC,eAAe,CAACnxB,cAAD,EAAiB4E,IAAI,CAAC6F,mBAAtB,CAA9B;AACAsmB,UAAAA,UAAU,CAAC2D,eAAX,CAA2B9B,YAA3B,EAAyC1B,QAAzC;AACD;AACF;AACF;;AAED,aAASnZ,YAAT,CAAsBtoB,KAAtB,EAA6BuQ,cAA7B,EAA6C;AAC3CJ,MAAAA,oBAAoB;AAEpB;AACE,YAAInQ,KAAK,CAAC9V,GAAN,KAAcmB,cAAd,IAAgC2U,KAAK,CAAC9V,GAAN,KAAcoB,kBAAlD,EAAsE;AACpE,cAAI2F,QAAQ,GAAG+O,KAAK,CAACxV,SAArB;AACAg0C,UAAAA,uBAAuB,CAACvtC,QAAD,CAAvB;AACD;AACF;AAED,UAAIkkB,IAAI,GAAGyvB,kBAAkB,CAAC5kC,KAAD,EAAQuQ,cAAR,CAA7B;;AACA,UAAI4E,IAAI,KAAK,IAAb,EAAmB;AACjB,YACE,SACCnV,KAAK,CAAC9V,GAAN,KAAcmB,cAAd,IAAgC2U,KAAK,CAAC9V,GAAN,KAAcoB,kBAD/C,CADF,EAGE;AACAizC,UAAAA,0BAA0B,CAACv+B,KAAD,CAA1B;AACD;;AACD;AACD;;AAED,UAAImN,uBAAJ,EAA6B;AAC3B03B,QAAAA,kCAAkC,CAAC1vB,IAAD,EAAO5E,cAAP,EAAuB,IAAvB,CAAlC;AACD;;AAED,UACE,CAACquB,SAAD,IACAE,wBAAwB,KAAKvpB,MAD7B,IAEAhF,cAAc,GAAGuuB,wBAHnB,EAIE;AAEA7tB,QAAAA,aAAa,GAAGjR,KAAhB;AACA8/B,QAAAA,UAAU;AACX;;AACDjhB,MAAAA,wBAAwB,CAAC1J,IAAD,EAAO5E,cAAP,CAAxB;;AACA,UAGE,CAACquB,SAAD,IACAK,cADA,IAGAJ,QAAQ,KAAK1pB,IANf,EAOE;AACA,YAAIyuB,kBAAkB,GAAGzuB,IAAI,CAAC5E,cAA9B;AACAu0B,QAAAA,WAAW,CAAC3vB,IAAD,EAAOyuB,kBAAP,CAAX;AACD;;AACD,UAAIsB,iBAAiB,GAAGC,mBAAxB,EAA6C;AAE3CD,QAAAA,iBAAiB,GAAG,CAApB;AACA3kD,QAAAA,SAAS,CACP,KADO,EAEP,2DACE,6CADF,GAEE,0DAFF,GAGE,yDALK,CAAT;AAOD;AACF;;AAMD,QAAI6kD,kBAAkB,GAAG,IAAzB;AACA,QAAIC,iBAAiB,GAAG,IAAxB;AAEA,QAAIC,sBAAsB,GAAG/vB,MAA7B;AACA,QAAIxP,UAAU,GAAG,KAAK,CAAtB;AACA,QAAIw/B,WAAW,GAAG,KAAlB;AACA,QAAIC,eAAe,GAAG,IAAtB;AACA,QAAIC,yBAAyB,GAAGlwB,MAAhC;AACA,QAAImvB,8CAA8C,GAAGnvB,MAArD;AACA,QAAImwB,iBAAiB,GAAG,KAAxB;AACA,QAAI9D,iBAAiB,GAAG,KAAxB;AACA,QAAIC,cAAc,GAAG,IAArB;AACA,QAAI8D,QAAQ,GAAG,IAAf;AAEA,QAAIC,iBAAiB,GAAG,KAAxB;AACA,QAAIC,mBAAmB,GAAG,KAA1B;AACA,QAAIpB,4BAA4B,GAAG,KAAnC;AAEA,QAAIqB,gBAAgB,GAAG,IAAvB;AAEA,QAAIC,mBAAmB,GAAGp3C,GAAG,EAA7B;AACA,QAAIq3C,mBAAmB,GAAGpwB,kBAAkB,CAACmwB,mBAAD,CAA5C;AACA,QAAIE,oBAAoB,GAAGD,mBAA3B;AAGA,QAAIb,mBAAmB,GAAG,EAA1B;AACA,QAAID,iBAAiB,GAAG,CAAxB;AACA,QAAIgB,gCAAgC,GAAG,IAAvC;AAEA,QAAIC,0BAA0B,GAAG,CAAjC;;AAEA,aAASC,4BAAT,GAAwC;AACtC,UAAInC,aAAa,GAAGt1C,GAAG,KAAKo3C,mBAA5B;AACAC,MAAAA,mBAAmB,GAAGpwB,kBAAkB,CAACquB,aAAD,CAAxC;AACD;;AAED,aAASoC,kCAAT,CAA4ClxB,IAA5C,EAAkD5E,cAAlD,EAAkE;AAChE,UAAI+0B,sBAAsB,KAAK/vB,MAA/B,EAAuC;AAErC,YAAIhF,cAAc,GAAG+0B,sBAArB,EAA6C;AAE3C;AACD,SAHD,MAGO;AACL,cAAIv/B,UAAU,KAAK,IAAnB,EAAyB;AAGvBuD,YAAAA,sBAAsB,CAACvD,UAAD,CAAtB;AACD;AACF;AAEF,OAbD,MAaO;AACLqK,QAAAA,yBAAyB;AAC1B;;AAEDk1B,MAAAA,sBAAsB,GAAG/0B,cAAzB;AACA,UAAI+1B,SAAS,GAAG33C,GAAG,KAAKo3C,mBAAxB;AACA,UAAIQ,gBAAgB,GAAGzwB,kBAAkB,CAACvF,cAAD,CAAzC;AACA,UAAIi2B,OAAO,GAAGD,gBAAgB,GAAGD,SAAjC;AACAvgC,MAAAA,UAAU,GAAGsD,wBAAwB,CAACo9B,gBAAD,EAAmB;AAAED,QAAAA,OAAO,EAAEA;AAAX,OAAnB,CAArC;AACD;;AAMD,aAASjD,OAAT,CAAiBpuB,IAAjB,EAAuB;AACrBA,MAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;AACD;;AAED,aAAS0pB,UAAT,CAAoBjvB,IAApB,EAA0BuF,YAA1B,EAAwCnK,cAAxC,EAAwD;AACtD4E,MAAAA,IAAI,CAACsF,2BAAL,GAAmClK,cAAnC;AACA4E,MAAAA,IAAI,CAACuF,YAAL,GAAoBA,YAApB;AACD;;AAED,aAASmpB,SAAT,CACE1uB,IADF,EAEEuF,YAFF,EAGEipB,uBAHF,EAIEC,kBAJF,EAKEM,cALF,EAME;AACA/uB,MAAAA,IAAI,CAAC5E,cAAL,GAAsBqzB,kBAAtB;;AACA,UAAI/2B,cAAc,IAAIq3B,cAAc,KAAK,CAArC,IAA0C,CAACnB,WAAW,EAA1D,EAA8D;AAE5D5tB,QAAAA,IAAI,CAACsF,2BAAL,GAAmCkpB,uBAAnC;AACAxuB,QAAAA,IAAI,CAACuF,YAAL,GAAoBA,YAApB;AACD,OAJD,MAIO,IAAIwpB,cAAc,GAAG,CAArB,EAAwB;AAE7B/uB,QAAAA,IAAI,CAACwF,aAAL,GAAqBpR,eAAe,CAClCm9B,SAAS,CAACtJ,IAAV,CAAe,IAAf,EAAqBjoB,IAArB,EAA2BuF,YAA3B,EAAyCipB,uBAAzC,CADkC,EAElCO,cAFkC,CAApC;AAID;AACF;;AAED,aAAST,OAAT,CAAiBtuB,IAAjB,EAAuB;AACrBA,MAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;AACD;;AAED,aAASgsB,SAAT,CAAmBvxB,IAAnB,EAAyBuF,YAAzB,EAAuCipB,uBAAvC,EAAgE;AAC9D,UAAI92B,cAAJ,EAAoB;AAElBsI,QAAAA,IAAI,CAACsF,2BAAL,GAAmCkpB,uBAAnC;AACAxuB,QAAAA,IAAI,CAACuF,YAAL,GAAoBA,YAApB;AAIA0rB,QAAAA,4BAA4B;AAC5BH,QAAAA,oBAAoB,GAAGD,mBAAvB;;AAEA,YAAI74B,uBAAJ,EAA6B;AAG3BgyB,UAAAA,kBAAkB,GAAG,IAArB;AACAwH,UAAAA,SAAS,CAACxxB,IAAD,EAAOwuB,uBAAP,CAAT;AACAxE,UAAAA,kBAAkB,GAAG,KAArB;AACD,SAND,MAMO;AACLwH,UAAAA,SAAS,CAACxxB,IAAD,EAAOwuB,uBAAP,CAAT;AACD;AACF;AACF;;AAED,aAAStC,QAAT,CAAkBlsB,IAAlB,EAAwB5E,cAAxB,EAAwC;AACtC4E,MAAAA,IAAI,CAAC5E,cAAL,GAAsBA,cAAtB;AACA4E,MAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;AACD;;AAED,aAAS0N,kBAAT,GAA8B;AAoB5B,UAAImd,WAAJ,EAAiB;AAEf,eAAOU,oBAAP;AACD;;AAEDW,MAAAA,uBAAuB;;AACvB,UACEnB,yBAAyB,KAAKlwB,MAA9B,IACAkwB,yBAAyB,KAAKhwB,KAFhC,EAGE;AAGA2wB,QAAAA,4BAA4B;AAC5BH,QAAAA,oBAAoB,GAAGD,mBAAvB;AACA,eAAOC,oBAAP;AACD;;AAMD,aAAOA,oBAAP;AACD;;AAID,aAASnB,WAAT,CAAqB3vB,IAArB,EAA2B5E,cAA3B,EAA2C;AACzCs2B,MAAAA,iBAAiB,CAAC1xB,IAAD,EAAO5E,cAAP,CAAjB;;AACA,UAAIg1B,WAAJ,EAAiB;AAGf;AACD;;AAED,UAAIK,iBAAJ,EAAuB;AAErB,YAAIC,mBAAJ,EAAyB;AAGvBL,UAAAA,eAAe,GAAGrwB,IAAlB;AACAswB,UAAAA,yBAAyB,GAAGjwB,IAA5B;AACAsxB,UAAAA,iBAAiB,CAAC3xB,IAAD,EAAOK,IAAP,EAAa,IAAb,CAAjB;AACD;;AACD;AACD;;AAGD,UAAIjF,cAAc,KAAKiF,IAAvB,EAA6B;AAC3BuxB,QAAAA,eAAe;AAChB,OAFD,MAEO;AACLV,QAAAA,kCAAkC,CAAClxB,IAAD,EAAO5E,cAAP,CAAlC;AACD;AACF;;AAED,aAASs2B,iBAAT,CAA2B1xB,IAA3B,EAAiC5E,cAAjC,EAAiD;AAG/C,UAAI4E,IAAI,CAAC4F,iBAAL,KAA2B,IAA/B,EAAqC;AAEnC5F,QAAAA,IAAI,CAAC5E,cAAL,GAAsBA,cAAtB;;AACA,YAAI80B,iBAAiB,KAAK,IAA1B,EAAgC;AAC9BD,UAAAA,kBAAkB,GAAGC,iBAAiB,GAAGlwB,IAAzC;AACAA,UAAAA,IAAI,CAAC4F,iBAAL,GAAyB5F,IAAzB;AACD,SAHD,MAGO;AACLkwB,UAAAA,iBAAiB,CAACtqB,iBAAlB,GAAsC5F,IAAtC;AACAkwB,UAAAA,iBAAiB,GAAGlwB,IAApB;AACAkwB,UAAAA,iBAAiB,CAACtqB,iBAAlB,GAAsCqqB,kBAAtC;AACD;AACF,OAXD,MAWO;AAEL,YAAI4B,uBAAuB,GAAG7xB,IAAI,CAAC5E,cAAnC;;AACA,YACEy2B,uBAAuB,KAAKzxB,MAA5B,IACAhF,cAAc,GAAGy2B,uBAFnB,EAGE;AAEA7xB,UAAAA,IAAI,CAAC5E,cAAL,GAAsBA,cAAtB;AACD;AACF;AACF;;AAED,aAASq2B,uBAAT,GAAmC;AACjC,UAAIK,mBAAmB,GAAG1xB,MAA1B;AACA,UAAI2xB,mBAAmB,GAAG,IAA1B;;AACA,UAAI7B,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,YAAI8B,qBAAqB,GAAG9B,iBAA5B;AACA,YAAIlwB,IAAI,GAAGiwB,kBAAX;;AACA,eAAOjwB,IAAI,KAAK,IAAhB,EAAsB;AACpB,cAAI6xB,uBAAuB,GAAG7xB,IAAI,CAAC5E,cAAnC;;AACA,cAAIy2B,uBAAuB,KAAKzxB,MAAhC,EAAwC;AAMtCh1B,YAAAA,SAAS,CACP4mD,qBAAqB,KAAK,IAA1B,IAAkC9B,iBAAiB,KAAK,IADjD,EAEP,gEACE,iDAHK,CAAT;;AAKA,gBAAIlwB,IAAI,KAAKA,IAAI,CAAC4F,iBAAlB,EAAqC;AAEnC5F,cAAAA,IAAI,CAAC4F,iBAAL,GAAyB,IAAzB;AACAqqB,cAAAA,kBAAkB,GAAGC,iBAAiB,GAAG,IAAzC;AACA;AACD,aALD,MAKO,IAAIlwB,IAAI,KAAKiwB,kBAAb,EAAiC;AAEtC,kBAAIj8C,IAAI,GAAGgsB,IAAI,CAAC4F,iBAAhB;AACAqqB,cAAAA,kBAAkB,GAAGj8C,IAArB;AACAk8C,cAAAA,iBAAiB,CAACtqB,iBAAlB,GAAsC5xB,IAAtC;AACAgsB,cAAAA,IAAI,CAAC4F,iBAAL,GAAyB,IAAzB;AACD,aANM,MAMA,IAAI5F,IAAI,KAAKkwB,iBAAb,EAAgC;AAErCA,cAAAA,iBAAiB,GAAG8B,qBAApB;AACA9B,cAAAA,iBAAiB,CAACtqB,iBAAlB,GAAsCqqB,kBAAtC;AACAjwB,cAAAA,IAAI,CAAC4F,iBAAL,GAAyB,IAAzB;AACA;AACD,aANM,MAMA;AACLosB,cAAAA,qBAAqB,CAACpsB,iBAAtB,GAA0C5F,IAAI,CAAC4F,iBAA/C;AACA5F,cAAAA,IAAI,CAAC4F,iBAAL,GAAyB,IAAzB;AACD;;AACD5F,YAAAA,IAAI,GAAGgyB,qBAAqB,CAACpsB,iBAA7B;AACD,WAjCD,MAiCO;AACL,gBACEksB,mBAAmB,KAAK1xB,MAAxB,IACAyxB,uBAAuB,GAAGC,mBAF5B,EAGE;AAEAA,cAAAA,mBAAmB,GAAGD,uBAAtB;AACAE,cAAAA,mBAAmB,GAAG/xB,IAAtB;AACD;;AACD,gBAAIA,IAAI,KAAKkwB,iBAAb,EAAgC;AAC9B;AACD;;AACD,gBAAI4B,mBAAmB,KAAKzxB,IAA5B,EAAkC;AAGhC;AACD;;AACD2xB,YAAAA,qBAAqB,GAAGhyB,IAAxB;AACAA,YAAAA,IAAI,GAAGA,IAAI,CAAC4F,iBAAZ;AACD;AACF;AACF;;AAEDyqB,MAAAA,eAAe,GAAG0B,mBAAlB;AACAzB,MAAAA,yBAAyB,GAAGwB,mBAA5B;AACD;;AAED,aAASR,gBAAT,CAA0BW,EAA1B,EAA8B;AAC5B,UAAIA,EAAE,CAAC5hC,UAAP,EAAmB;AAMjB,YAAI4/B,kBAAkB,KAAK,IAA3B,EAAiC;AAC/BgB,UAAAA,4BAA4B;AAC5B,cAAIjxB,IAAI,GAAGiwB,kBAAX;;AACA,aAAG;AACDvlB,YAAAA,yBAAyB,CAAC1K,IAAD,EAAO6wB,mBAAP,CAAzB;AAEA7wB,YAAAA,IAAI,GAAGA,IAAI,CAAC4F,iBAAZ;AACD,WAJD,QAIS5F,IAAI,KAAKiwB,kBAJlB;AAKD;AACF;;AACDiC,MAAAA,WAAW,CAAC9xB,MAAD,EAAS6xB,EAAT,CAAX;AACD;;AAED,aAASL,eAAT,GAA2B;AACzBM,MAAAA,WAAW,CAAC7xB,IAAD,EAAO,IAAP,CAAX;AACD;;AAED,aAAS6xB,WAAT,CAAqBC,iBAArB,EAAwCF,EAAxC,EAA4C;AAC1CzB,MAAAA,QAAQ,GAAGyB,EAAX;AAIAR,MAAAA,uBAAuB;;AAEvB,UAAIjB,QAAQ,KAAK,IAAjB,EAAuB;AACrBS,QAAAA,4BAA4B;AAC5BH,QAAAA,oBAAoB,GAAGD,mBAAvB;;AAEA,YAAIl5B,mBAAJ,EAAyB;AACvB,cAAIwD,SAAS,GAAGm1B,yBAAyB,GAAGO,mBAA5C;AACA,cAAIQ,OAAO,GAAG1wB,kBAAkB,CAAC2vB,yBAAD,CAAhC;AACAp1B,UAAAA,wBAAwB,CAACC,SAAD,EAAYk2B,OAAZ,CAAxB;AACD;;AAED,eACEhB,eAAe,KAAK,IAApB,IACAC,yBAAyB,KAAKlwB,MAD9B,KAEC+xB,iBAAiB,KAAK/xB,MAAtB,IACC+xB,iBAAiB,IAAI7B,yBAHvB,MAIC,CAACC,iBAAD,IAAsBM,mBAAmB,IAAIP,yBAJ9C,CADF,EAME;AACAqB,UAAAA,iBAAiB,CACftB,eADe,EAEfC,yBAFe,EAGfO,mBAAmB,IAAIP,yBAHR,CAAjB;AAKAmB,UAAAA,uBAAuB;AACvBR,UAAAA,4BAA4B;AAC5BH,UAAAA,oBAAoB,GAAGD,mBAAvB;AACD;AACF,OA1BD,MA0BO;AACL,eACER,eAAe,KAAK,IAApB,IACAC,yBAAyB,KAAKlwB,MAD9B,KAEC+xB,iBAAiB,KAAK/xB,MAAtB,IACC+xB,iBAAiB,IAAI7B,yBAHvB,CADF,EAKE;AACAqB,UAAAA,iBAAiB,CAACtB,eAAD,EAAkBC,yBAAlB,EAA6C,IAA7C,CAAjB;AACAmB,UAAAA,uBAAuB;AACxB;AACF;;AAMD,UAAIjB,QAAQ,KAAK,IAAjB,EAAuB;AACrBL,QAAAA,sBAAsB,GAAG/vB,MAAzB;AACAxP,QAAAA,UAAU,GAAG,IAAb;AACD;;AAED,UAAI0/B,yBAAyB,KAAKlwB,MAAlC,EAA0C;AACxC8wB,QAAAA,kCAAkC,CAChCb,eADgC,EAEhCC,yBAFgC,CAAlC;AAID;;AAGDE,MAAAA,QAAQ,GAAG,IAAX;AACAD,MAAAA,iBAAiB,GAAG,KAApB;AAEA6B,MAAAA,eAAe;AAChB;;AAED,aAASZ,SAAT,CAAmBxxB,IAAnB,EAAyB5E,cAAzB,EAAyC;AACvChwB,MAAAA,SAAS,CACP,CAACglD,WADM,EAEP,uEACE,+DAHK,CAAT;AAQAC,MAAAA,eAAe,GAAGrwB,IAAlB;AACAswB,MAAAA,yBAAyB,GAAGl1B,cAA5B;AACAu2B,MAAAA,iBAAiB,CAAC3xB,IAAD,EAAO5E,cAAP,EAAuB,IAAvB,CAAjB;AAEAw2B,MAAAA,eAAe;AAChB;;AAED,aAASQ,eAAT,GAA2B;AACzBrC,MAAAA,iBAAiB,GAAG,CAApB;AACAgB,MAAAA,gCAAgC,GAAG,IAAnC;;AAEA,UAAIJ,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,YAAI0B,OAAO,GAAG1B,gBAAd;AACAA,QAAAA,gBAAgB,GAAG,IAAnB;;AACA,aAAK,IAAIv9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGi/C,OAAO,CAACphD,MAA5B,EAAoCmC,CAAC,EAArC,EAAyC;AACvC,cAAIk/C,KAAK,GAAGD,OAAO,CAACj/C,CAAD,CAAnB;;AACA,cAAI;AACFk/C,YAAAA,KAAK,CAACC,WAAN;AACD,WAFD,CAEE,OAAO3mD,KAAP,EAAc;AACd,gBAAI,CAAC6gD,iBAAL,EAAwB;AACtBA,cAAAA,iBAAiB,GAAG,IAApB;AACAC,cAAAA,cAAc,GAAG9gD,KAAjB;AACD;AACF;AACF;AACF;;AAED,UAAI6gD,iBAAJ,EAAuB;AACrB,YAAI7gD,KAAK,GAAG8gD,cAAZ;AACAA,QAAAA,cAAc,GAAG,IAAjB;AACAD,QAAAA,iBAAiB,GAAG,KAApB;AACA,cAAM7gD,KAAN;AACD;AACF;;AAED,aAAS+lD,iBAAT,CAA2B3xB,IAA3B,EAAiC5E,cAAjC,EAAiD0yB,SAAjD,EAA4D;AAC1D1iD,MAAAA,SAAS,CACP,CAACglD,WADM,EAEP,2EACE,0CAHK,CAAT;AAMAA,MAAAA,WAAW,GAAG,IAAd;;AAGA,UAAII,QAAQ,KAAK,IAAb,IAAqB1C,SAAzB,EAAoC;AAMlC,YAAIvoB,YAAY,GAAGvF,IAAI,CAACuF,YAAxB;;AACA,YAAIA,YAAY,KAAK,IAArB,EAA2B;AAEzBitB,UAAAA,YAAY,CAACxyB,IAAD,EAAOuF,YAAP,EAAqBnK,cAArB,CAAZ;AACD,SAHD,MAGO;AACL4E,UAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;AAGA,cAAIC,aAAa,GAAGxF,IAAI,CAACwF,aAAzB;;AACA,cAAI9N,cAAc,IAAI8N,aAAa,KAAKlR,SAAxC,EAAmD;AACjD0L,YAAAA,IAAI,CAACwF,aAAL,GAAqBlR,SAArB;AAEAD,YAAAA,aAAa,CAACmR,aAAD,CAAb;AACD;;AACD,cAAIglB,QAAQ,GAAG,KAAf;AACAqD,UAAAA,UAAU,CAAC7tB,IAAD,EAAOwqB,QAAP,EAAiBsD,SAAjB,CAAV;AACAvoB,UAAAA,YAAY,GAAGvF,IAAI,CAACuF,YAApB;;AACA,cAAIA,YAAY,KAAK,IAArB,EAA2B;AAEzBitB,YAAAA,YAAY,CAACxyB,IAAD,EAAOuF,YAAP,EAAqBnK,cAArB,CAAZ;AACD;AACF;AACF,OA5BD,MA4BO;AAEL,YAAIq3B,aAAa,GAAGzyB,IAAI,CAACuF,YAAzB;;AACA,YAAIktB,aAAa,KAAK,IAAtB,EAA4B;AAE1BD,UAAAA,YAAY,CAACxyB,IAAD,EAAOyyB,aAAP,EAAsBr3B,cAAtB,CAAZ;AACD,SAHD,MAGO;AACL4E,UAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;AAGA,cAAImtB,cAAc,GAAG1yB,IAAI,CAACwF,aAA1B;;AACA,cAAI9N,cAAc,IAAIg7B,cAAc,KAAKp+B,SAAzC,EAAoD;AAClD0L,YAAAA,IAAI,CAACwF,aAAL,GAAqBlR,SAArB;AAEAD,YAAAA,aAAa,CAACq+B,cAAD,CAAb;AACD;;AACD,cAAIC,SAAS,GAAG,IAAhB;AACA9E,UAAAA,UAAU,CAAC7tB,IAAD,EAAO2yB,SAAP,EAAkB7E,SAAlB,CAAV;AACA2E,UAAAA,aAAa,GAAGzyB,IAAI,CAACuF,YAArB;;AACA,cAAIktB,aAAa,KAAK,IAAtB,EAA4B;AAG1B,gBAAI,CAAC7E,WAAW,EAAhB,EAAoB;AAElB4E,cAAAA,YAAY,CAACxyB,IAAD,EAAOyyB,aAAP,EAAsBr3B,cAAtB,CAAZ;AACD,aAHD,MAGO;AAGL4E,cAAAA,IAAI,CAACuF,YAAL,GAAoBktB,aAApB;AACD;AACF;AACF;AACF;;AAEDrC,MAAAA,WAAW,GAAG,KAAd;AACD;;AAED,aAASoC,YAAT,CAAsBxyB,IAAtB,EAA4BuF,YAA5B,EAA0CnK,cAA1C,EAA0D;AAExD,UAAIuK,UAAU,GAAG3F,IAAI,CAAC2F,UAAtB;;AACA,UAAIA,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAACitB,eAAX,IAA8Bx3B,cAAzD,EAAyE;AACvE,YAAIu1B,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BA,UAAAA,gBAAgB,GAAG,CAAChrB,UAAD,CAAnB;AACD,SAFD,MAEO;AACLgrB,UAAAA,gBAAgB,CAAC18C,IAAjB,CAAsB0xB,UAAtB;AACD;;AACD,YAAIA,UAAU,CAACktB,MAAf,EAAuB;AAGrB7yB,UAAAA,IAAI,CAACuF,YAAL,GAAoBA,YAApB;AACAvF,UAAAA,IAAI,CAAC5E,cAAL,GAAsBgF,MAAtB;AACA;AACD;AACF;;AAGDJ,MAAAA,IAAI,CAACuF,YAAL,GAAoB,IAApB;;AAIA,UAAIvF,IAAI,KAAK+wB,gCAAb,EAA+C;AAG7ChB,QAAAA,iBAAiB;AAClB,OAJD,MAIO;AAELgB,QAAAA,gCAAgC,GAAG/wB,IAAnC;AACA+vB,QAAAA,iBAAiB,GAAG,CAApB;AACD;;AACD7E,MAAAA,UAAU,CAAClrB,IAAD,EAAOuF,YAAP,CAAV;AACD;;AAID,aAASqoB,WAAT,GAAuB;AACrB,UAAI2C,iBAAJ,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UACEC,QAAQ,KAAK,IAAb,IACAA,QAAQ,CAACpgC,aAAT,KAA2B4gC,0BAF7B,EAGE;AAGA,eAAO,KAAP;AACD;;AACDT,MAAAA,iBAAiB,GAAG,IAApB;AACA,aAAO,IAAP;AACD;;AAED,aAASpJ,eAAT,CAAyBv7C,KAAzB,EAAgC;AAC9BR,MAAAA,SAAS,CACPilD,eAAe,KAAK,IADb,EAEP,0EACE,8BAHK,CAAT;AAOAA,MAAAA,eAAe,CAACj1B,cAAhB,GAAiCgF,MAAjC;;AACA,UAAI,CAACqsB,iBAAL,EAAwB;AACtBA,QAAAA,iBAAiB,GAAG,IAApB;AACAC,QAAAA,cAAc,GAAG9gD,KAAjB;AACD;AACF;;AAID,aAASknD,gBAAT,CAA0B/6C,EAA1B,EAA8BzM,CAA9B,EAAiC;AAC/B,UAAIynD,yBAAyB,GAAGtC,iBAAhC;AACAA,MAAAA,iBAAiB,GAAG,IAApB;;AACA,UAAI;AACF,eAAO14C,EAAE,CAACzM,CAAD,CAAT;AACD,OAFD,SAEU;AACRmlD,QAAAA,iBAAiB,GAAGsC,yBAApB;;AACA,YAAI,CAACtC,iBAAD,IAAsB,CAACL,WAA3B,EAAwC;AACtCwB,UAAAA,eAAe;AAChB;AACF;AACF;;AAED,aAASoB,oBAAT,CAA8Bj7C,EAA9B,EAAkCzM,CAAlC,EAAqCC,CAArC,EAAwC;AACtC,UAAI+jD,4BAAJ,EAAkC;AAChC,eAAOv3C,EAAE,CAACzM,CAAD,EAAIC,CAAJ,CAAT;AACD;;AAKD,UACE,CAACklD,iBAAD,IACA,CAACL,WADD,IAEAb,8CAA8C,KAAKnvB,MAHrD,EAIE;AAEA8xB,QAAAA,WAAW,CAAC3C,8CAAD,EAAiD,IAAjD,CAAX;AACAA,QAAAA,8CAA8C,GAAGnvB,MAAjD;AACD;;AACD,UAAI6yB,oCAAoC,GAAG3D,4BAA3C;AACA,UAAIyD,yBAAyB,GAAGtC,iBAAhC;AACAnB,MAAAA,4BAA4B,GAAG,IAA/B;AACAmB,MAAAA,iBAAiB,GAAG,IAApB;;AACA,UAAI;AACF,eAAO14C,EAAE,CAACzM,CAAD,EAAIC,CAAJ,CAAT;AACD,OAFD,SAEU;AACR+jD,QAAAA,4BAA4B,GAAG2D,oCAA/B;AACAxC,QAAAA,iBAAiB,GAAGsC,yBAApB;;AACA,YAAI,CAACtC,iBAAD,IAAsB,CAACL,WAA3B,EAAwC;AACtCwB,UAAAA,eAAe;AAChB;AACF;AACF;;AAED,aAASsB,yBAAT,GAAqC;AACnC,UACE,CAAC9C,WAAD,IACAb,8CAA8C,KAAKnvB,MAFrD,EAGE;AAEA8xB,QAAAA,WAAW,CAAC3C,8CAAD,EAAiD,IAAjD,CAAX;AACAA,QAAAA,8CAA8C,GAAGnvB,MAAjD;AACD;AACF;;AAKD,QAAI+yB,yBAAyB,GAAG,KAAK,CAArC;AAEA;AACEA,MAAAA,yBAAyB,GAAG,KAA5B;AACD;;AAED,aAASC,oBAAT,CAA8BC,eAA9B,EAA+C;AAC7C,UAAI,CAACA,eAAL,EAAsB;AACpB,eAAOn2B,kBAAP;AACD;;AAED,UAAIrS,KAAK,GAAG9D,KAAK,CAACssC,eAAD,CAAjB;AACA,UAAI70B,aAAa,GAAGS,0BAA0B,CAACpU,KAAD,CAA9C;;AAEA,UAAIA,KAAK,CAAC9V,GAAN,KAAcmB,cAAlB,EAAkC;AAChC,YAAIqnB,SAAS,GAAG1S,KAAK,CAAC5X,IAAtB;;AACA,YAAIwqB,iBAAiB,CAACF,SAAD,CAArB,EAAkC;AAChC,iBAAOgB,mBAAmB,CAAC1T,KAAD,EAAQ0S,SAAR,EAAmBiB,aAAnB,CAA1B;AACD;AACF,OALD,MAKO,IAAI3T,KAAK,CAAC9V,GAAN,KAAcoB,kBAAlB,EAAsC;AAC3C,YAAI+oB,UAAU,GAAGvW,6BAA6B,CAACkC,KAAK,CAAC5X,IAAP,CAA9C;;AACA,YAAIwqB,iBAAiB,CAACyB,UAAD,CAArB,EAAmC;AACjC,iBAAOX,mBAAmB,CAAC1T,KAAD,EAAQqU,UAAR,EAAoBV,aAApB,CAA1B;AACD;AACF;;AAED,aAAOA,aAAP;AACD;;AAED,aAAS80B,kBAAT,CAA4B7b,UAA5B,EAAwC7T,OAAxC,EAAiDxI,cAAjD,EAAiElN,QAAjE,EAA2E;AACzE;AACE,YAAI7V,KAAK,KAAK,QAAV,IAAsBtE,OAAO,KAAK,IAAlC,IAA0C,CAACo/C,yBAA/C,EAA0E;AACxEA,UAAAA,yBAAyB,GAAG,IAA5B;AACAxhD,UAAAA,qBAAqB,CACnB,KADmB,EAEnB,kEACE,kEADF,GAEE,iEAFF,GAGE,gCALiB,EAMnBqX,gBAAgB,CAACjV,OAAO,CAACd,IAAT,CAAhB,IAAkC,SANf,CAArB;AAQD;AACF;AAED,UAAIi5B,MAAM,GAAGH,YAAY,CAAC3Q,cAAD,CAAzB;AAGA8Q,MAAAA,MAAM,CAACF,OAAP,GAAiB;AAAEpI,QAAAA,OAAO,EAAEA;AAAX,OAAjB;AAEA1V,MAAAA,QAAQ,GAAGA,QAAQ,KAAKhjB,SAAb,GAAyB,IAAzB,GAAgCgjB,QAA3C;;AACA,UAAIA,QAAQ,KAAK,IAAjB,EAAuB;AACrB,UAAE,OAAOA,QAAP,KAAoB,UAAtB,IACIvc,qBAAqB,CACnB,KADmB,EAEnB,yEACE,iCAHiB,EAInBuc,QAJmB,CADzB,GAOI,KAAK,CAPT;AAQAge,QAAAA,MAAM,CAAChe,QAAP,GAAkBA,QAAlB;AACD;;AACDie,MAAAA,aAAa,CAACsL,UAAD,EAAavL,MAAb,CAAb;AAEAiH,MAAAA,YAAY,CAACsE,UAAD,EAAarc,cAAb,CAAZ;AACA,aAAOA,cAAP;AACD;;AAED,aAASm4B,+BAAT,CACE3vB,OADF,EAEE4e,SAFF,EAGE6Q,eAHF,EAIEj4B,cAJF,EAKElN,QALF,EAME;AAEA,UAAIupB,UAAU,GAAG+K,SAAS,CAACzuC,OAA3B;AAEA;AACE,YAAI01B,2BAA2B,CAACD,SAAhC,EAA2C;AACzC,cAAIiO,UAAU,CAAC9/B,SAAX,KAAyB,IAA7B,EAAmC;AACjC8xB,YAAAA,2BAA2B,CAACD,SAA5B,CAAsCgqB,gBAAtC,CAAuDhR,SAAvD;AACD,WAFD,MAEO,IAAI5e,OAAO,KAAK,IAAhB,EAAsB;AAC3B6F,YAAAA,2BAA2B,CAACD,SAA5B,CAAsCiqB,kBAAtC,CAAyDjR,SAAzD;AACD,WAFM,MAEA;AACL/Y,YAAAA,2BAA2B,CAACD,SAA5B,CAAsCkqB,iBAAtC,CAAwDlR,SAAxD;AACD;AACF;AACF;AAED,UAAIp2C,OAAO,GAAGgnD,oBAAoB,CAACC,eAAD,CAAlC;;AACA,UAAI7Q,SAAS,CAACp2C,OAAV,KAAsB,IAA1B,EAAgC;AAC9Bo2C,QAAAA,SAAS,CAACp2C,OAAV,GAAoBA,OAApB;AACD,OAFD,MAEO;AACLo2C,QAAAA,SAAS,CAAC/c,cAAV,GAA2Br5B,OAA3B;AACD;;AAED,aAAOknD,kBAAkB,CAAC7b,UAAD,EAAa7T,OAAb,EAAsBxI,cAAtB,EAAsClN,QAAtC,CAAzB;AACD;;AAED,aAASylC,kBAAT,CAA4BzoC,SAA5B,EAAuC;AACrC,UAAIL,KAAK,GAAG9D,KAAK,CAACmE,SAAD,CAAjB;;AACA,UAAIL,KAAK,KAAK3f,SAAd,EAAyB;AACvB,YAAI,OAAOggB,SAAS,CAAC9B,MAAjB,KAA4B,UAAhC,EAA4C;AAC1Che,UAAAA,SAAS,CAAC,KAAD,EAAQ,gDAAR,CAAT;AACD,SAFD,MAEO;AACLA,UAAAA,SAAS,CACP,KADO,EAEP,uDAFO,EAGPmP,MAAM,CAAC0pB,IAAP,CAAY/Y,SAAZ,CAHO,CAAT;AAKD;AACF;;AACD,UAAI0oC,SAAS,GAAG7nC,oBAAoB,CAAClB,KAAD,CAApC;;AACA,UAAI+oC,SAAS,KAAK,IAAlB,EAAwB;AACtB,eAAO,IAAP;AACD;;AACD,aAAOA,SAAS,CAACv+C,SAAjB;AACD;;AAED,aAASw+C,eAAT,CAAyBjgC,aAAzB,EAAwC8P,OAAxC,EAAiDqB,OAAjD,EAA0D;AACxD,aAAOD,eAAe,CAAClR,aAAD,EAAgB8P,OAAhB,EAAyBqB,OAAzB,CAAtB;AACD;;AAED,aAAS+uB,eAAT,CAAyBlwB,OAAzB,EAAkC4e,SAAlC,EAA6C6Q,eAA7C,EAA8DnlC,QAA9D,EAAwE;AACtE,UAAIupB,UAAU,GAAG+K,SAAS,CAACzuC,OAA3B;AACA,UAAIitB,WAAW,GAAGiS,kBAAkB,EAApC;AACA,UAAI7X,cAAc,GAAG8X,yBAAyB,CAAClS,WAAD,EAAcyW,UAAd,CAA9C;AACA,aAAO8b,+BAA+B,CACpC3vB,OADoC,EAEpC4e,SAFoC,EAGpC6Q,eAHoC,EAIpCj4B,cAJoC,EAKpClN,QALoC,CAAtC;AAOD;;AAED,aAAS6lC,qBAAT,CAA+BvR,SAA/B,EAA0C;AACxC,UAAIwR,cAAc,GAAGxR,SAAS,CAACzuC,OAA/B;;AACA,UAAI,CAACigD,cAAc,CAACroC,KAApB,EAA2B;AACzB,eAAO,IAAP;AACD;;AACD,cAAQqoC,cAAc,CAACroC,KAAf,CAAqB5W,GAA7B;AACE,aAAKwB,aAAL;AACE,iBAAOmd,iBAAiB,CAACsgC,cAAc,CAACroC,KAAf,CAAqBtW,SAAtB,CAAxB;;AACF;AACE,iBAAO2+C,cAAc,CAACroC,KAAf,CAAqBtW,SAA5B;AAJJ;AAMD;;AAED,aAAS4+C,kBAAT,CAA4BC,cAA5B,EAA4C;AAC1C,UAAIC,wBAAuB,GAAGD,cAAc,CAACC,uBAA7C;AAEA,aAAO10B,eAAe,CACpB,SAAc,EAAd,EAAkBy0B,cAAlB,EAAkC;AAChCE,QAAAA,uBAAuB,EAAE,iCAASvpC,KAAT,EAAgB;AACvC,cAAI+oC,SAAS,GAAG7nC,oBAAoB,CAAClB,KAAD,CAApC;;AACA,cAAI+oC,SAAS,KAAK,IAAlB,EAAwB;AACtB,mBAAO,IAAP;AACD;;AACD,iBAAOA,SAAS,CAACv+C,SAAjB;AACD,SAP+B;AAQhC8+C,QAAAA,uBAAuB,EAAE,iCAASr4C,QAAT,EAAmB;AAC1C,cAAI,CAACq4C,wBAAL,EAA8B;AAE5B,mBAAO,IAAP;AACD;;AACD,iBAAOA,wBAAuB,CAACr4C,QAAD,CAA9B;AACD;AAd+B,OAAlC,CADoB,CAAtB;AAkBD;;AAKD,aAASu4C,aAAT,CACEz/B,QADF,EAEEhB,aAFF,EAIEgR,cAJF,EAKE;AACA,UAAI5d,GAAG,GACLta,SAAS,CAACuE,MAAV,GAAmB,CAAnB,IAAwBvE,SAAS,CAAC,CAAD,CAAT,KAAiBxB,SAAzC,GAAqDwB,SAAS,CAAC,CAAD,CAA9D,GAAoE,IADtE;AAGA,aAAO;AAELwc,QAAAA,QAAQ,EAAEzB,iBAFL;AAGLT,QAAAA,GAAG,EAAEA,GAAG,IAAI,IAAP,GAAc,IAAd,GAAqB,KAAKA,GAH1B;AAIL4N,QAAAA,QAAQ,EAAEA,QAJL;AAKLhB,QAAAA,aAAa,EAAEA,aALV;AAMLgR,QAAAA,cAAc,EAAEA;AANX,OAAP;AAQD;;AAID,QAAI0vB,YAAY,GAAG,QAAnB;;AAGA,QAAIC,kBAAkB,GAAG,4BAASC,cAAT,EAAyBC,gBAAzB,EAA2C;AAgBlE,UAAIF,kBAAkB,GAAG;AAkBvBnlC,QAAAA,OAAO,EAAE,iBAASlB,QAAT,EAAmB;AAC1B5jB,UAAAA,SAAS,CAAC8kB,OAAV,CACEolC,cAAc,CAAC,IAAD,CADhB,EAEEvmC,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,SAvBsB;AAwCvBmB,QAAAA,eAAe,EAAE,yBAASnB,QAAT,EAAmB;AAClC5jB,UAAAA,SAAS,CAAC+kB,eAAV,CACEmlC,cAAc,CAAC,IAAD,CADhB,EAEEvmC,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,SA7CsB;AAuDvBoB,QAAAA,aAAa,EAAE,uBACbC,oBADa,EAEbC,SAFa,EAGbC,MAHa,EAIb;AACAnlB,UAAAA,SAAS,CAACglB,aAAV,CACEklC,cAAc,CAAC,IAAD,CADhB,EAEEjlC,oBAFF,EAGEtB,iCAAiC,CAAC,IAAD,EAAOwB,MAAP,CAHnC,EAIExB,iCAAiC,CAAC,IAAD,EAAOuB,SAAP,CAJnC;AAMD,SAlEsB;AA0EvBE,QAAAA,cAAc,EAAE,wBAASC,WAAT,EAAsB;AAMpC,cAAI+kC,aAAa,GAAG,KAAK,CAAzB;;AAMA,cAAI;AACFA,YAAAA,aAAa,GAAGD,gBAAgB,CAAC,IAAD,CAAhC;AACD,WAFD,CAEE,OAAO7oD,KAAP,EAAc,CAAE;;AAIlB,cAAI8oD,aAAa,IAAI,IAArB,EAA2B;AACzB;AACD;;AAED,cAAI5lC,UAAU,GAAG4lC,aAAa,CAAC5lC,UAA/B;AAEA;AACEN,YAAAA,iBAAiB,CAACmB,WAAD,EAAcb,UAAU,CAACpC,eAAzB,CAAjB;AACD;AAED,cAAID,aAAa,GAAGuB,MAAM,CAAC2B,WAAD,EAAcb,UAAU,CAACpC,eAAzB,CAA1B;;AAKA,cAAID,aAAa,IAAI,IAArB,EAA2B;AACzBniB,YAAAA,SAAS,CAACslB,UAAV,CACE8kC,aAAa,CAAC7wC,UADhB,EAEEiL,UAAU,CAACe,eAFb,EAGEpD,aAHF;AAKD;AACF,SAlHsB;AAwHvByC,QAAAA,KAAK,EAAE,iBAAW;AAChBtkB,UAAAA,cAAc,CAACukB,cAAf,CAA8BqlC,cAAc,CAAC,IAAD,CAA5C;AACD,SA1HsB;AA+HvBxlC,QAAAA,IAAI,EAAE,gBAAW;AACfpkB,UAAAA,cAAc,CAACqkB,aAAf,CAA6BulC,cAAc,CAAC,IAAD,CAA3C;AACD;AAjIsB,OAAzB;AAoIA;AAIE,YAAIG,sBAAsB,GAAGJ,kBAA7B;AACAnpD,QAAAA,SAAS,CACP,CAACupD,sBAAsB,CAAC3rB,kBAAxB,IACE,CAAC2rB,sBAAsB,CAACzrB,yBAD1B,IAEE,CAACyrB,sBAAsB,CAAC5tB,yBAF1B,IAGE,CAAC4tB,sBAAsB,CAAC3tB,gCAJnB,EAKP,qCALO,CAAT;;AASA2tB,QAAAA,sBAAsB,CAAC3rB,kBAAvB,GAA4C,YAAW;AACrD5a,UAAAA,iBAAiB,CAAC,IAAD,EAAO,KAAKnZ,KAAZ,CAAjB;AACD,SAFD;;AAGA0/C,QAAAA,sBAAsB,CAACzrB,yBAAvB,GAAmD,UAASnV,QAAT,EAAmB;AACpE3F,UAAAA,iBAAiB,CAAC,IAAD,EAAO2F,QAAP,CAAjB;AACD,SAFD;;AAGA4gC,QAAAA,sBAAsB,CAAC5tB,yBAAvB,GAAmD,YAAW;AAC5D3Y,UAAAA,iBAAiB,CAAC,IAAD,EAAO,KAAKnZ,KAAZ,CAAjB;AACD,SAFD;;AAGA0/C,QAAAA,sBAAsB,CAAC3tB,gCAAvB,GAA0D,UACxDjT,QADwD,EAExD;AACA3F,UAAAA,iBAAiB,CAAC,IAAD,EAAO2F,QAAP,CAAjB;AACD,SAJD;;AASA4gC,QAAAA,sBAAsB,CAAC3rB,kBAAvB,CAA0CC,4BAA1C,GAAyE,IAAzE;AACA0rB,QAAAA,sBAAsB,CAACzrB,yBAAvB,CAAiDD,4BAAjD,GAAgF,IAAhF;AACD;AAED,aAAOsrB,kBAAP;AACD,KAzLD;;AA2LA,aAASK,iBAAT,CAA2B94C,QAA3B,EAAqC6S,WAArC,EAAkD;AAChD,UAAI,EAAE7S,QAAQ,YAAY6S,WAAtB,CAAJ,EAAwC;AACtC,cAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AACD;AACF;;AAED,aAASimC,0BAAT,CAAoCC,IAApC,EAA0CroD,IAA1C,EAAgD;AAC9C,UAAI,CAACqoD,IAAL,EAAW;AACT,cAAM,IAAIC,cAAJ,CACJ,2DADI,CAAN;AAGD;;AACD,aAAOtoD,IAAI,KAAK,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,UAAjD,CAAJ,GACHA,IADG,GAEHqoD,IAFJ;AAGD;;AAED,aAASE,SAAT,CAAmBC,QAAnB,EAA6BC,UAA7B,EAAyC;AACvC,UAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAC3D,cAAM,IAAItmC,SAAJ,CACJ,6DACE,OAAOsmC,UAFL,CAAN;AAID;;AACDD,MAAAA,QAAQ,CAAC1oD,SAAT,GAAqBgO,MAAM,CAACyT,MAAP,CAAcknC,UAAU,IAAIA,UAAU,CAAC3oD,SAAvC,EAAkD;AACrEmI,QAAAA,WAAW,EAAE;AACXwS,UAAAA,KAAK,EAAE+tC,QADI;AAEXtiB,UAAAA,UAAU,EAAE,KAFD;AAGXwiB,UAAAA,QAAQ,EAAE,IAHC;AAIXl6C,UAAAA,YAAY,EAAE;AAJH;AADwD,OAAlD,CAArB;AAQA,UAAIi6C,UAAJ,EACE36C,MAAM,CAAC66C,cAAP,GACI76C,MAAM,CAAC66C,cAAP,CAAsBH,QAAtB,EAAgCC,UAAhC,CADJ,GAEKD,QAAQ,CAACI,SAAT,GAAqBH,UAF1B;AAGH;;AAGD,QAAII,oBAAoB,GAAG,8BAASd,cAAT,EAAyBC,gBAAzB,EAA2C;AAYpE,UAAIa,oBAAoB,GAAI,UAASC,gBAAT,EAA2B;AACrDP,QAAAA,SAAS,CAACM,oBAAD,EAAuBC,gBAAvB,CAAT;;AAEA,iBAASD,oBAAT,GAAgC;AAC9BV,UAAAA,iBAAiB,CAAC,IAAD,EAAOU,oBAAP,CAAjB;;AAEA,iBAAOT,0BAA0B,CAC/B,IAD+B,EAE/BU,gBAAgB,CAAC5oD,KAAjB,CAAuB,IAAvB,EAA6BD,SAA7B,CAF+B,CAAjC;AAID;;AAUD4oD,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+ByiB,IAA/B,GAAsC,SAASA,IAAT,GAAgB;AACpDpkB,UAAAA,cAAc,CAACqkB,aAAf,CAA6BulC,cAAc,CAAC,IAAD,CAA3C;AACD,SAFD;;AAQAc,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+B2iB,KAA/B,GAAuC,SAASA,KAAT,GAAiB;AACtDtkB,UAAAA,cAAc,CAACukB,cAAf,CAA8BqlC,cAAc,CAAC,IAAD,CAA5C;AACD,SAFD;;AAoBAc,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+B6iB,OAA/B,GAAyC,SAASA,OAAT,CAAiBlB,QAAjB,EAA2B;AAClE5jB,UAAAA,SAAS,CAAC8kB,OAAV,CACEolC,cAAc,CAAC,IAAD,CADhB,EAEEvmC,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,SALD;;AAqBAonC,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+B8iB,eAA/B,GAAiD,SAASA,eAAT,CAC/CnB,QAD+C,EAE/C;AACA5jB,UAAAA,SAAS,CAAC+kB,eAAV,CACEmlC,cAAc,CAAC,IAAD,CADhB,EAEEvmC,iCAAiC,CAAC,IAAD,EAAOC,QAAP,CAFnC;AAID,SAPD;;AAgBAonC,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+B+iB,aAA/B,GAA+C,SAASA,aAAT,CAC7CC,oBAD6C,EAE7CC,SAF6C,EAG7CC,MAH6C,EAI7C;AACAnlB,UAAAA,SAAS,CAACglB,aAAV,CACEklC,cAAc,CAAC,IAAD,CADhB,EAEEjlC,oBAFF,EAGEtB,iCAAiC,CAAC,IAAD,EAAOwB,MAAP,CAHnC,EAIExB,iCAAiC,CAAC,IAAD,EAAOuB,SAAP,CAJnC;AAMD,SAXD;;AAoBA8lC,QAAAA,oBAAoB,CAAC/oD,SAArB,CAA+BmjB,cAA/B,GAAgD,SAASA,cAAT,CAC9CC,WAD8C,EAE9C;AAMA,cAAI+kC,aAAa,GAAG,KAAK,CAAzB;;AAMA,cAAI;AACFA,YAAAA,aAAa,GAAGD,gBAAgB,CAAC,IAAD,CAAhC;AACD,WAFD,CAEE,OAAO7oD,KAAP,EAAc,CAAE;;AAIlB,cAAI8oD,aAAa,IAAI,IAArB,EAA2B;AACzB;AACD;;AAED,cAAI5lC,UAAU,GACZ4lC,aAAa,CAAC5lC,UAAd,IAA4B4lC,aAAa,CAAC5wC,SAAd,CAAwBgL,UADtD;AAGA,cAAIrC,aAAa,GAAGuB,MAAM,CAAC2B,WAAD,EAAcb,UAAU,CAACpC,eAAzB,CAA1B;;AAKA,cAAID,aAAa,IAAI,IAArB,EAA2B;AACzBniB,YAAAA,SAAS,CAACslB,UAAV,CACE8kC,aAAa,CAAC7wC,UADhB,EAEEiL,UAAU,CAACe,eAFb,EAGEpD,aAHF;AAKD;AACF,SAvCD;;AAyCA,eAAO6oC,oBAAP;AACD,OAnJ0B,CAmJxB9qD,KAAK,CAAC+yB,SAnJkB,CAA3B;;AAuJA,aAAO+3B,oBAAP;AACD,KApKD;;AAuKA,QAAIE,aAAa,GAAG,EAApB;AACA;AACEj7C,MAAAA,MAAM,CAAC+L,MAAP,CAAckvC,aAAd;AACD;AAED,QAAIC,0BAA0B,GAAG,KAAK,CAAtC;AAEA;AACE,UAAIC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAASC,SAAT,EAAoB75C,QAApB,EAA8B;AACtD,YAAIA,QAAJ,EAAc;AACZ65C,UAAAA,SAAS,CAACC,OAAV,CAAkB95C,QAAlB;AACA45C,UAAAA,mBAAmB,CAACC,SAAD,EAAY75C,QAAQ,CAAC6a,WAArB,CAAnB;AACD;AACF,OALD;;AAOA,UAAIk/B,iBAAiB,GAAG,SAApBA,iBAAoB,CAAS/5C,QAAT,EAAmB;AACzC,YAAI65C,SAAS,GAAG,EAAhB;AACAD,QAAAA,mBAAmB,CAACC,SAAD,EAAY75C,QAAZ,CAAnB;AACA,eAAO65C,SAAP;AACD,OAJD;;AAMA,UAAIG,mBAAmB,GAAG,SAAtBA,mBAAsB,CAASH,SAAT,EAAoB;AAC5C,aAAK,IAAIviD,CAAC,GAAGuiD,SAAS,CAAC1kD,MAAV,GAAmB,CAAhC,EAAmCmC,CAAC,GAAG,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC7C,cAAI0I,QAAQ,GAAG65C,SAAS,CAACviD,CAAD,CAAxB;;AAEA,cAAI0I,QAAQ,CAAC/G,GAAT,KAAiBwB,aAArB,EAAoC;AAClC,mBAAOuF,QAAP;AACD;AACF;;AACD,eAAO65C,SAAS,CAAC,CAAD,CAAhB;AACD,OATD;;AAWA,UAAII,YAAY,GAAG,SAAfA,YAAe,CAASlrC,KAAT,EAAgB;AACjC,YAAImrC,IAAI,GAAGjqC,oBAAoB,CAAClB,KAAD,CAA/B;;AACA,YAAImrC,IAAJ,EAAU;AACR,iBAAOA,IAAI,CAACxzB,aAAL,IAAsBgzB,aAA7B;AACD;;AACD,eAAOA,aAAP;AACD,OAND;;AAQA,UAAIS,WAAW,GAAG,SAAdA,WAAc,CAASprC,KAAT,EAAgB2pC,cAAhB,EAAgC;AAChD,YAAI0B,QAAQ,GAAG,KAAK,CAApB;;AAGA,eAAOrrC,KAAP,EAAc;AACZ,cAAIA,KAAK,CAACxV,SAAN,KAAoB,IAApB,IAA4BwV,KAAK,CAAC9V,GAAN,KAAcwB,aAA9C,EAA6D;AAC3D2/C,YAAAA,QAAQ,GAAG1B,cAAc,CAAC3pC,KAAK,CAACxV,SAAP,CAAzB;AACD;;AACD,cAAI6gD,QAAJ,EAAc;AACZ,mBAAOA,QAAP;AACD;;AACDrrC,UAAAA,KAAK,GAAGA,KAAK,CAACc,KAAd;AACD;;AACD,eAAO,IAAP;AACD,OAdD;;AAgBA,UAAIwqC,eAAe,GAAG,SAAlBA,eAAkB,CAASC,cAAT,EAAyB;AAC7C,eAAOA,cAAc,CAAC9kD,GAAf,CAAmB,UAASuZ,KAAT,EAAgB;AACxC,iBAAO;AACL7e,YAAAA,IAAI,EAAEgd,gBAAgB,CAAC6B,KAAK,CAAC5X,IAAP,CADjB;AAELojD,YAAAA,gBAAgB,EAAE,0BAAS7B,cAAT,EAAyB;AACzC,qBAAO;AACLplC,gBAAAA,OAAO,EAAE,iBAASlB,QAAT,EAAmB;AAC1B,yBAAO5jB,SAAS,CAAC8kB,OAAV,CACL6mC,WAAW,CAACprC,KAAD,EAAQ2pC,cAAR,CADN,EAELtmC,QAFK,CAAP;AAID,iBANI;AAOLjZ,gBAAAA,KAAK,EAAE8gD,YAAY,CAAClrC,KAAD,CAPd;AAQLmL,gBAAAA,MAAM,EAAEnL,KAAK,CAAC+L;AART,eAAP;AAUD;AAbI,WAAP;AAeD,SAhBM,CAAP;AAiBD,OAlBD;;AAoBA6+B,MAAAA,0BAA0B,GAAG,oCAASa,OAAT,EAAkB;AAC7C,YAAIC,eAAe,GAAG5yC,kBAAkB,CAAC2yC,OAAD,CAAxC;;AAGA,YAAI,CAACC,eAAL,EAAsB;AACpB,iBAAO;AACLZ,YAAAA,SAAS,EAAE,EADN;AAEL1gD,YAAAA,KAAK,EAAEugD,aAFF;AAGLgB,YAAAA,SAAS,EAAE,IAHN;AAILxgC,YAAAA,MAAM,EAAE;AAJH,WAAP;AAMD;;AAED,YAAInL,KAAK,GAAGU,6BAA6B,CAACgrC,eAAD,CAAzC;AACA,YAAIH,cAAc,GAAGP,iBAAiB,CAAChrC,KAAD,CAAtC;AACA,YAAI/O,QAAQ,GAAGg6C,mBAAmB,CAACM,cAAD,CAAlC;AACA,YAAIT,SAAS,GAAGQ,eAAe,CAACC,cAAD,CAA/B;AACA,YAAInhD,KAAK,GAAG8gD,YAAY,CAACj6C,QAAD,CAAxB;AACA,YAAIka,MAAM,GAAGla,QAAQ,CAAC8a,YAAtB;AACA,YAAI4/B,SAAS,GAAGJ,cAAc,CAAC7mD,OAAf,CAAuBuM,QAAvB,CAAhB;AAEA,eAAO;AACL65C,UAAAA,SAAS,EAAEA,SADN;AAEL1gD,UAAAA,KAAK,EAAEA,KAFF;AAGLuhD,UAAAA,SAAS,EAAEA,SAHN;AAILxgC,UAAAA,MAAM,EAAEA;AAJH,SAAP;AAMD,OA3BD;AA4BD;AAID,QAAIxL,iBAAiB,GAAGrD,oBAAoB,CAACqD,iBAA7C;AACA,QAAIiqC,gBAAgB,GAAGd,kBAAvB;;AAEA,aAASa,cAAT,CAAwBiC,iBAAxB,EAA2C;AACzC;AACE,YAAItrC,KAAK,GAAGX,iBAAiB,CAACzW,OAA9B;;AACA,YAAIoX,KAAK,KAAK,IAAV,IAAkBA,KAAK,CAAC9V,SAAN,KAAoB,IAA1C,EAAgD;AAC9C,WAAC8V,KAAK,CAAC9V,SAAN,CAAgBgW,wBAAjB,GACI1Z,qBAAqB,CACnB,KADmB,EAEnB,yDACE,mEADF,GAEE,oEAFF,GAGE,iEAHF,GAIE,6BANiB,EAOnBqX,gBAAgB,CAACmC,KAAK,CAAClY,IAAP,CAAhB,IAAgC,aAPb,CADzB,GAUI,KAAK,CAVT;AAYAkY,UAAAA,KAAK,CAAC9V,SAAN,CAAgBgW,wBAAhB,GAA2C,IAA3C;AACD;AACF;;AACD,UAAIorC,iBAAiB,IAAI,IAAzB,EAA+B;AAC7B,eAAO,IAAP;AACD;;AACD,UAAI,OAAOA,iBAAP,KAA6B,QAAjC,EAA2C;AAEzC,eAAOA,iBAAP;AACD;;AACD,UAAIA,iBAAiB,CAAC5yC,UAAtB,EAAkC;AAChC,eAAO4yC,iBAAiB,CAAC5yC,UAAzB;AACD;;AACD,UAAI4yC,iBAAiB,CAAC3yC,SAAlB,IAA+B2yC,iBAAiB,CAAC3yC,SAAlB,CAA4BD,UAA/D,EAA2E;AACzE,eAAO4yC,iBAAiB,CAAC3yC,SAAlB,CAA4BD,UAAnC;AACD;;AACD,UAAI6yC,YAAY,GAAGjC,gBAAgB,CAACgC,iBAAD,CAAnC;;AACA,UAAIC,YAAY,IAAI,IAApB,EAA0B;AACxB,eAAOA,YAAP;AACD;;AACD,UAAIA,YAAY,CAAC5yC,SAAjB,EAA4B;AAE1B,eAAO4yC,YAAY,CAAC5yC,SAAb,CAAuBD,UAA9B;AACD;;AACD,aAAO6yC,YAAY,CAAC7yC,UAApB;AACD;;AAEDkB,IAAAA,yBAAyB,CACvB+tC,gBADuB,EAEvBE,oBAFuB,EAGvBE,yBAHuB,CAAzB;;AAMA,aAASyD,sCAAT,CAAgDC,QAAhD,EAA0D;AACxD,UAAI/rC,KAAK,GAAGlH,kBAAkB,CAACizC,QAAD,CAA9B;;AACA,UAAI,CAAC/rC,KAAL,EAAY;AACV,eAAO,EAAP;AACD;;AACD,aAAOgM,2BAA2B,CAAChM,KAAD,CAAlC;AACD;;AAED,QAAIgsC,KAAK,GAAG,IAAI50B,GAAJ,EAAZ;AAEA,QAAI60B,mBAAmB,GAAG;AACxBC,MAAAA,eAAe,EAAEzB,oBAAoB,CAACd,cAAD,EAAiBC,gBAAjB,CADb;AAGxBD,MAAAA,cAAc,EAAEA,cAHQ;AAKxBprC,MAAAA,MAAM,EAAE,gBAASwa,OAAT,EAAkBozB,YAAlB,EAAgC9oC,QAAhC,EAA0C;AAChD,YAAI8R,IAAI,GAAG62B,KAAK,CAAC17C,GAAN,CAAU67C,YAAV,CAAX;;AAEA,YAAI,CAACh3B,IAAL,EAAW;AAGTA,UAAAA,IAAI,GAAG6zB,eAAe,CAACmD,YAAD,EAAe,KAAf,EAAsB,KAAtB,CAAtB;AACAH,UAAAA,KAAK,CAAC37C,GAAN,CAAU87C,YAAV,EAAwBh3B,IAAxB;AACD;;AACD8zB,QAAAA,eAAe,CAAClwB,OAAD,EAAU5D,IAAV,EAAgB,IAAhB,EAAsB9R,QAAtB,CAAf;AAEA,eAAO6lC,qBAAqB,CAAC/zB,IAAD,CAA5B;AACD,OAjBuB;AAkBxBi3B,MAAAA,sBAAsB,EAAE,gCAASD,YAAT,EAAuB;AAC7C,YAAIh3B,IAAI,GAAG62B,KAAK,CAAC17C,GAAN,CAAU67C,YAAV,CAAX;;AACA,YAAIh3B,IAAJ,EAAU;AAER8zB,UAAAA,eAAe,CAAC,IAAD,EAAO9zB,IAAP,EAAa,IAAb,EAAmB,YAAW;AAC3C62B,YAAAA,KAAK,CAAC5b,MAAN,CAAa+b,YAAb;AACD,WAFc,CAAf;AAGD;AACF,OA1BuB;AA2BxBE,MAAAA,wCAAwC,EAAE,kDAASF,YAAT,EAAuB;AAC/DF,QAAAA,mBAAmB,CAACG,sBAApB,CAA2CD,YAA3C;AAGA1sD,QAAAA,SAAS,CAAC6sD,cAAV,CAAyBH,YAAzB;AACD,OAhCuB;AAiCxB3C,MAAAA,YAAY,EAAE,sBAASz/B,QAAT,EAAmBoiC,YAAnB,EAAiC;AAC7C,YAAIhwC,GAAG,GACLta,SAAS,CAACuE,MAAV,GAAmB,CAAnB,IAAwBvE,SAAS,CAAC,CAAD,CAAT,KAAiBxB,SAAzC,GAAqDwB,SAAS,CAAC,CAAD,CAA9D,GAAoE,IADtE;AAGA,eAAO2nD,aAAY,CAACz/B,QAAD,EAAWoiC,YAAX,EAAyB,IAAzB,EAA+BhwC,GAA/B,CAAnB;AACD,OAtCuB;AAwCxBowC,MAAAA,uBAAuB,EAAEvyC,cAxCD;AA0CxBuC,MAAAA,kDAAkD,EAAE;AAElDmtC,QAAAA,kBAAkB,EAAEA,kBAAkB,CAACC,cAAD,EAAiBC,gBAAjB,CAFY;AAGlDkC,QAAAA,sCAAsC,EAAEA;AAHU;AA1C5B,KAA1B;AAiDA1C,IAAAA,kBAAkB,CAAC;AACjBE,MAAAA,uBAAuB,EAAExwC,kBADR;AAEjB8xC,MAAAA,0BAA0B,EAAEA,0BAFX;AAGjB4B,MAAAA,UAAU,EAAE,CAHK;AAIjBC,MAAAA,OAAO,EAAEhD,YAJQ;AAKjBiD,MAAAA,mBAAmB,EAAE;AALJ,KAAD,CAAlB;AAQA,QAAIC,qBAAqB,GAAGj9C,MAAM,CAAC+L,MAAP,CAAc;AACxC23B,MAAAA,OAAO,EAAE6Y;AAD+B,KAAd,CAA5B;AAIA,QAAIW,qBAAqB,GACtBD,qBAAqB,IAAIV,mBAA1B,IAAkDU,qBADpD;AAKA,QAAIE,mBAAmB,GACrBD,qBAAqB,CAACxZ,OAAtB,IAAiCwZ,qBADnC;AAGAE,IAAAA,MAAM,CAACC,OAAP,GAAiBF,mBAAjB;AAEG,GAvzfD;AAwzfD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n * @generated\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire('../../Core/InitializeCore');\nvar ReactNativeViewConfigRegistry = require('../shims/ReactNativeViewConfigRegistry');\nvar UIManager = require('../../ReactNative/UIManager');\nvar RCTEventEmitter = require('../../EventEmitter/RCTEventEmitter');\nvar React = require(\"react\");\nvar deepFreezeAndThrowOnMutationInDev = require('../../Utilities/deepFreezeAndThrowOnMutationInDev');\nvar deepDiffer = require('../../Utilities/differ/deepDiffer');\nvar flattenStyle = require('../../StyleSheet/flattenStyle');\nvar TextInputState = require('../../Components/TextInput/TextInputState');\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar tracking = require(\"schedule/tracking\");\nvar ExceptionsManager = require('../../Core/ExceptionsManager');\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function() {};\n\n{\n  validateFormat = function(format) {\n    if (format === undefined) {\n      throw new Error(\"invariant requires an error message argument\");\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error(\n        \"Minified exception occurred; use the non-minified dev environment \" +\n          \"for the full error message and additional helpful warnings.\"\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        })\n      );\n      error.name = \"Invariant Violation\";\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar invokeGuardedCallbackImpl = function(\n  name,\n  func,\n  context,\n  a,\n  b,\n  c,\n  d,\n  e,\n  f\n) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n      var windowEvent = window.event;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n\n        // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n        if (\n          typeof window.event !== \"undefined\" &&\n          window.hasOwnProperty(\"event\")\n        ) {\n          window.event = windowEvent;\n        }\n\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === \"object\") {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {\n              // Ignore.\n            }\n          }\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        this.onError(error);\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", handleWindowError);\n    };\n\n    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\n// Used by Fiber to simulate a try-catch.\nvar hasError = false;\nvar caughtError = null;\n\n// Used by event system to capture/rethrow the first error.\nvar hasRethrowError = false;\nvar rethrowError = null;\n\nvar reporter = {\n  onError: function(error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallbackAndCatchFirstError(\n  name,\n  func,\n  context,\n  a,\n  b,\n  c,\n  d,\n  e,\n  f\n) {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    var error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nfunction rethrowCaughtError() {\n  if (hasRethrowError) {\n    var error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nfunction hasCaughtError() {\n  return hasError;\n}\n\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(\n      false,\n      \"clearCaughtError was called but no error was captured. This error \" +\n        \"is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n}\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function() {};\n\n{\n  warningWithoutStack = function(condition, format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 2 ? _len - 2 : 0),\n        _key = 2;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error(\n        \"`warningWithoutStack(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== \"undefined\") {\n      var _console;\n\n      var stringArgs = args.map(function(item) {\n        return \"\" + item;\n      });\n      (_console = console).error.apply(\n        _console,\n        [\"Warning: \" + format].concat(stringArgs)\n      );\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message =\n        \"Warning: \" +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nfunction setComponentTree(\n  getFiberCurrentPropsFromNodeImpl,\n  getInstanceFromNodeImpl,\n  getNodeFromInstanceImpl\n) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n  {\n    !(getNodeFromInstance && getInstanceFromNode)\n      ? warningWithoutStack$1(\n          false,\n          \"EventPluginUtils.setComponentTree(...): Injected \" +\n            \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n        )\n      : void 0;\n  }\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners\n        ? 1\n        : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances\n        ? 1\n        : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen)\n      ? warningWithoutStack$1(false, \"EventPluginUtils: Invalid `event`.\")\n      : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventsInBatch(events, false);\n}\n\nvar FunctionalComponent = 0;\nvar FunctionalComponentLazy = 1;\nvar ClassComponent = 2;\nvar ClassComponentLazy = 3;\nvar IndeterminateComponent = 4; // Before we know whether it is functional or class\nvar HostRoot = 5; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 6; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 7;\nvar HostText = 8;\nvar Fragment = 9;\nvar Mode = 10;\nvar ContextConsumer = 11;\nvar ContextProvider = 12;\nvar ForwardRef = 13;\nvar ForwardRefLazy = 14;\nvar Profiler = 15;\nvar PlaceholderComponent = 16;\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst\n      ? warningWithoutStack$1(false, \"Dispatching inst must not be null\")\n      : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar EVENT_POOL_SIZE = 10;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function() {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"isDefaultPrevented\",\n        getPooledWarningPropertyDefinition(\n          \"isDefaultPrevented\",\n          functionThatReturnsFalse\n        )\n      );\n      Object.defineProperty(\n        this,\n        \"isPropagationStopped\",\n        getPooledWarningPropertyDefinition(\n          \"isPropagationStopped\",\n          functionThatReturnsFalse\n        )\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", function() {})\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", function() {})\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function(Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get$$1\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get$$1() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition\n      ? warningWithoutStack$1(\n          false,\n          \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n            \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n            \"If you must keep the original synthetic event around, use event.persist(). \" +\n            \"See https://fb.me/react-event-pooling for more information.\",\n          action,\n          propName,\n          result\n        )\n      : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderSyntheticEvent = SyntheticEvent.extend({\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n});\n\nvar TOP_TOUCH_START = \"topTouchStart\";\nvar TOP_TOUCH_MOVE = \"topTouchMove\";\nvar TOP_TOUCH_END = \"topTouchEnd\";\nvar TOP_TOUCH_CANCEL = \"topTouchCancel\";\nvar TOP_SCROLL = \"topScroll\";\nvar TOP_SELECTION_CHANGE = \"topSelectionChange\";\n\nfunction isStartish(topLevelType) {\n  return topLevelType === TOP_TOUCH_START;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === TOP_TOUCH_MOVE;\n}\n\nfunction isEndish(topLevelType) {\n  return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;\n}\n\nvar startDependencies = [TOP_TOUCH_START];\nvar moveDependencies = [TOP_TOUCH_MOVE];\nvar endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    !(identifier <= MAX_TOUCH_BANK)\n      ? warningWithoutStack$1(\n          false,\n          \"Touch identifier %s is greater than maximum supported %s which causes \" +\n            \"performance issues backfilling array locations for all of the indices.\",\n          identifier,\n          MAX_TOUCH_BANK\n        )\n      : void 0;\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          !(activeRecord != null && activeRecord.touchActive)\n            ? warningWithoutStack$1(false, \"Cannot find single active touch.\")\n            : void 0;\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes$1 = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    },\n    dependencies: startDependencies\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SCROLL]\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    },\n    dependencies: [TOP_SELECTION_CHANGE]\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    },\n    dependencies: moveDependencies\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: {\n    registrationName: \"onResponderStart\",\n    dependencies: startDependencies\n  },\n  responderMove: {\n    registrationName: \"onResponderMove\",\n    dependencies: moveDependencies\n  },\n  responderEnd: {\n    registrationName: \"onResponderEnd\",\n    dependencies: endDependencies\n  },\n  responderRelease: {\n    registrationName: \"onResponderRelease\",\n    dependencies: endDependencies\n  },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\",\n    dependencies: []\n  },\n  responderGrant: {\n    registrationName: \"onResponderGrant\",\n    dependencies: []\n  },\n  responderReject: {\n    registrationName: \"onResponderReject\",\n    dependencies: []\n  },\n  responderTerminate: {\n    registrationName: \"onResponderTerminate\",\n    dependencies: []\n  }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes$1.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes$1.moveShouldSetResponder\n      : topLevelType === TOP_SELECTION_CHANGE\n        ? eventTypes$1.selectionChangeShouldSetResponder\n        : eventTypes$1.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted = void 0;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes$1.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes$1.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes$1.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE) ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes$1,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes$1.responderStart\n      : isResponderTouchMove\n        ? eventTypes$1.responderMove\n        : isResponderTouchEnd\n          ? eventTypes$1.responderEnd\n          : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === TOP_TOUCH_CANCEL;\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes$1.responderTerminate\n      : isResponderRelease\n        ? eventTypes$1.responderRelease\n        : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes$1 =\n  ReactNativeViewConfigRegistry.customBubblingEventTypes;\nvar customDirectEventTypes$1 =\n  ReactNativeViewConfigRegistry.customDirectEventTypes;\nvar eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (targetInst == null) {\n      // Probably a node belonging to another renderer's tree.\n      return null;\n    }\n    var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];\n    var directDispatchConfig = customDirectEventTypes$1[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  }\n};\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  return instanceCache[tag] || null;\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  if (tag === undefined) {\n    tag = inst.stateNode.canonical._nativeTag;\n  }\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\n// Use to restore controlled state after a change event has fired.\n\nvar restoreImpl = null;\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    typeof restoreImpl === \"function\",\n    \"setRestoreImplementation() needs to be called to handle a target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  restoreImpl(internalInstance.stateNode, internalInstance.type, props);\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdatesImpl = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _flushInteractiveUpdatesImpl = function() {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdatesImpl();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction setBatchingImplementation(\n  batchedUpdatesImpl,\n  interactiveUpdatesImpl,\n  flushInteractiveUpdatesImpl\n) {\n  _batchedUpdatesImpl = batchedUpdatesImpl;\n  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\n}\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    runExtractedEventsInBatch(\n      topLevelType,\n      inst,\n      nativeEvent,\n      nativeEvent.target\n    );\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < 1) {\n        {\n          warningWithoutStack$1(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches\n});\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\nsetComponentTree(\n  getFiberCurrentPropsFromNode$1,\n  getInstanceFromTag,\n  getTagFromInstance\n);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get$1(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactSharedInternals =\n  React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol\n  ? Symbol.for(\"react.strict_mode\")\n  : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol\n  ? Symbol.for(\"react.forward_ref\")\n  : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol\n  ? Symbol.for(\"react.placeholder\")\n  : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction getResultFromResolvedThenable(thenable) {\n  return thenable._reactResult;\n}\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === \"number\") {\n      warningWithoutStack$1(\n        false,\n        \"Received an unexpected object in getComponentName(). \" +\n          \"This is likely a bug in React. Please file an issue.\"\n      );\n    }\n  }\n  if (typeof type === \"function\") {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === \"string\") {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return \"AsyncMode\";\n    case REACT_FRAGMENT_TYPE:\n      return \"Fragment\";\n    case REACT_PORTAL_TYPE:\n      return \"Portal\";\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n    case REACT_STRICT_MODE_TYPE:\n      return \"StrictMode\";\n    case REACT_PLACEHOLDER_TYPE:\n      return \"Placeholder\";\n  }\n  if (typeof type === \"object\") {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return \"Context.Consumer\";\n      case REACT_PROVIDER_TYPE:\n        return \"Context.Provider\";\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || \"\";\n        return functionName !== \"\"\n          ? \"ForwardRef(\" + functionName + \")\"\n          : \"ForwardRef\";\n    }\n    if (typeof type.then === \"function\") {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */ 0;\nvar PerformedWork = /*         */ 1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */ 2;\nvar Update = /*                */ 4;\nvar PlacementAndUpdate = /*    */ 6;\nvar Deletion = /*              */ 8;\nvar ContentReset = /*          */ 16;\nvar Callback = /*              */ 32;\nvar DidCapture = /*            */ 64;\nvar Ref = /*                   */ 128;\nvar Snapshot = /*              */ 256;\n\n// Update & Callback & Ref & Snapshot\nvar LifecycleEffectMask = /*   */ 420;\n\n// Union of all host effects\nvar HostEffectMask = /*        */ 511;\n\nvar Incomplete = /*            */ 512;\nvar ShouldCapture = /*         */ 1024;\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner$1.current;\n    if (\n      owner !== null &&\n      (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)\n    ) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender\n        ? warningWithoutStack$1(\n            false,\n            \"%s is accessing isMounted inside its render() function. \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(ownerFiber.type) || \"A component\"\n          )\n        : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get$1(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\n// Modules provided by RN:\nvar emptyObject = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = node;\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof nextProp === \"function\") {\n        nextProp = true;\n      }\n      if (typeof nextProp === \"undefined\") {\n        nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i = void 0;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(updatePayload, prevProp, nextProp, validAttributes);\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      nextProp,\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    prevProp,\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(updatePayload, nextProp, validAttributes);\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(updatePayload, prevProp, validAttributes);\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig = void 0;\n  var nextProp = void 0;\n  var prevProp = void 0;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        var _nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = _nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (var _propKey in prevProps) {\n    if (nextProps[_propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[_propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[_propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[_propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[_propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[_propKey]) {\n        removedKeys[_propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback_NOT_REALLY_SAFE(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    // This protects against createClass() components.\n    // We don't know if there is code depending on it.\n    // We intentionally don't use isMounted() because even accessing\n    // isMounted property on a React ES6 class will trigger a warning.\n    if (typeof context.__isMounted === \"boolean\") {\n      if (!context.__isMounted) {\n        return undefined;\n      }\n    }\n\n    // FIXME: there used to be other branches that protected\n    // against unmounted host components. But RN host components don't\n    // define isMounted() anymore, so those checks didn't do anything.\n\n    // They caused false positive warning noise so we removed them:\n    // https://github.com/facebook/react-native/issues/18868#issuecomment-413579095\n\n    // However, this means that the callback is NOT guaranteed to be safe\n    // for host components. The solution we should implement is to make\n    // UIManager.measure() and similar calls truly cancelable. Then we\n    // can change our own code calling them to cancel when something unmounts.\n\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(\n      this._nativeTag,\n      mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n      mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now$1 = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now$1();\n  },\n  didTimeout: false\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now$1() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback$1(callback, options) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  var timeoutId = setTimeout(setTimeoutCallback, 1);\n  return timeoutId; // Timeouts are always numbers on RN\n}\n\nfunction cancelDeferredCallback$1(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID); // Timeouts are always numbers on RN\n}\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(\n    false,\n    \"The current renderer does not support persistence. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\n// Renderers that don't support hydration\n// can re-export everything from this module.\n\nfunction shim$1() {\n  invariant(\n    false,\n    \"The current renderer does not support hyration. \" +\n      \"This error is likely caused by a bug in React. \" +\n      \"Please file an issue.\"\n  );\n}\n\n// Hydration (when unsupported)\nvar supportsHydration = false;\nvar canHydrateInstance = shim$1;\nvar canHydrateTextInstance = shim$1;\nvar getNextHydratableSibling = shim$1;\nvar getFirstHydratableChild = shim$1;\nvar hydrateInstance = shim$1;\nvar hydrateTextInstance = shim$1;\nvar didNotMatchHydratedContainerTextInstance = shim$1;\nvar didNotMatchHydratedTextInstance = shim$1;\nvar didNotHydrateContainerInstance = shim$1;\nvar didNotHydrateInstance = shim$1;\nvar didNotFindHydratableContainerInstance = shim$1;\nvar didNotFindHydratableContainerTextInstance = shim$1;\nvar didNotFindHydratableInstance = shim$1;\nvar didNotFindHydratableTextInstance = shim$1;\n\n// Modules provided by RN:\n// Unused\n\nvar UPDATE_SIGNAL = {};\n{\n  Object.freeze(UPDATE_SIGNAL);\n}\n\n// Counter for uniquely identifying views.\n// % 10 === 1 means it is a rootTag.\n// % 2 === 0 means it is a Fabric tag.\nvar nextReactTag = 3;\nfunction allocateTag() {\n  var tag = nextReactTag;\n  if (tag % 10 === 1) {\n    tag += 2;\n  }\n  nextReactTag = tag + 2;\n  return tag;\n}\n\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance._children.push(child);\n}\n\nfunction createInstance(\n  type,\n  props,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  var tag = allocateTag();\n  var viewConfig = ReactNativeViewConfigRegistry.get(type);\n\n  {\n    for (var key in viewConfig.validAttributes) {\n      if (props.hasOwnProperty(key)) {\n        deepFreezeAndThrowOnMutationInDev(props[key]);\n      }\n    }\n  }\n\n  invariant(\n    type !== \"RCTView\" || !hostContext.isInAParentText,\n    \"Nesting of <View> within <Text> is not currently supported.\"\n  );\n\n  var updatePayload = create(props, viewConfig.validAttributes);\n\n  UIManager.createView(\n    tag, // reactTag\n    viewConfig.uiViewClassName, // viewName\n    rootContainerInstance, // rootTag\n    updatePayload // props\n  );\n\n  var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n  precacheFiberNode(internalInstanceHandle, tag);\n  updateFiberProps(tag, props);\n\n  // Not sure how to avoid this cast. Flow is okay if the component is defined\n  // in the same file but if it's external it can't see the types.\n  return component;\n}\n\nfunction createTextInstance(\n  text,\n  rootContainerInstance,\n  hostContext,\n  internalInstanceHandle\n) {\n  invariant(\n    hostContext.isInAParentText,\n    \"Text strings must be rendered within a <Text> component.\"\n  );\n\n  var tag = allocateTag();\n\n  UIManager.createView(\n    tag, // reactTag\n    \"RCTRawText\", // viewName\n    rootContainerInstance, // rootTag\n    { text: text } // props\n  );\n\n  precacheFiberNode(internalInstanceHandle, tag);\n\n  return tag;\n}\n\nfunction finalizeInitialChildren(\n  parentInstance,\n  type,\n  props,\n  rootContainerInstance,\n  hostContext\n) {\n  // Don't send a no-op message over the bridge.\n  if (parentInstance._children.length === 0) {\n    return false;\n  }\n\n  // Map from child objects to native tags.\n  // Either way we need to pass a copy of the Array to prevent it from being frozen.\n  var nativeTags = parentInstance._children.map(function(child) {\n    return typeof child === \"number\"\n      ? child // Leaf node (eg text)\n      : child._nativeTag;\n  });\n\n  UIManager.setChildren(\n    parentInstance._nativeTag, // containerTag\n    nativeTags // reactTags\n  );\n\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  return { isInAParentText: false };\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  var prevIsInAParentText = parentHostContext.isInAParentText;\n  var isInAParentText =\n    type === \"AndroidTextInput\" || // Android\n    type === \"RCTMultilineTextInputView\" || // iOS\n    type === \"RCTSinglelineTextInputView\" || // iOS\n    type === \"RCTText\" ||\n    type === \"RCTVirtualText\";\n\n  if (prevIsInAParentText !== isInAParentText) {\n    return { isInAParentText: isInAParentText };\n  } else {\n    return parentHostContext;\n  }\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  // Noop\n}\n\nfunction prepareUpdate(\n  instance,\n  type,\n  oldProps,\n  newProps,\n  rootContainerInstance,\n  hostContext\n) {\n  return UPDATE_SIGNAL;\n}\n\nfunction resetAfterCommit(containerInfo) {\n  // Noop\n}\n\nvar now = now$1;\nvar isPrimaryRenderer = true;\nvar scheduleDeferredCallback = scheduleDeferredCallback$1;\nvar cancelDeferredCallback = cancelDeferredCallback$1;\n\nvar scheduleTimeout = setTimeout;\nvar cancelTimeout = clearTimeout;\nvar noTimeout = -1;\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return false;\n}\n\nfunction shouldSetTextContent(type, props) {\n  // TODO (bvaughn) Revisit this decision.\n  // Always returning false simplifies the createInstance() implementation,\n  // But creates an additional child Fiber for raw text children.\n  // No additional native views are created though.\n  // It's not clear to me which is better so I'm deferring for now.\n  // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n  return false;\n}\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction appendChild(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  if (index >= 0) {\n    children.splice(index, 1);\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [index], // moveFromIndices\n      [children.length - 1], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    children.push(child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerTag\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [children.length - 1], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction appendChildToContainer(parentInstance, child) {\n  var childTag = typeof child === \"number\" ? child : child._nativeTag;\n  UIManager.setChildren(\n    parentInstance, // containerTag\n    [childTag] // reactTags\n  );\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  UIManager.updateView(\n    textInstance, // reactTag\n    \"RCTRawText\", // viewName\n    { text: newText } // props\n  );\n}\n\nfunction commitUpdate(\n  instance,\n  updatePayloadTODO,\n  type,\n  oldProps,\n  newProps,\n  internalInstanceHandle\n) {\n  var viewConfig = instance.viewConfig;\n\n  updateFiberProps(instance._nativeTag, newProps);\n\n  var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n  // Avoid the overhead of bridge calls if there's no update.\n  // This is an expensive no-op for Android, and causes an unnecessary\n  // view invalidation for certain components (eg RCTTextInput) on iOS.\n  if (updatePayload != null) {\n    UIManager.updateView(\n      instance._nativeTag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      updatePayload // props\n    );\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  // Move existing child or add new child?\n  if (index >= 0) {\n    children.splice(index, 1);\n    var beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(beforeChildIndex, 0, child);\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [index], // moveFromIndices\n      [beforeChildIndex], // moveToIndices\n      [], // addChildReactTags\n      [], // addAtIndices\n      [] // removeAtIndices\n    );\n  } else {\n    var _beforeChildIndex = children.indexOf(beforeChild);\n    children.splice(_beforeChildIndex, 0, child);\n\n    var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n    UIManager.manageChildren(\n      parentInstance._nativeTag, // containerID\n      [], // moveFromIndices\n      [], // moveToIndices\n      [childTag], // addChildReactTags\n      [_beforeChildIndex], // addAtIndices\n      [] // removeAtIndices\n    );\n  }\n}\n\nfunction insertInContainerBefore(parentInstance, child, beforeChild) {\n  // TODO (bvaughn): Remove this check when...\n  // We create a wrapper object for the container in ReactNative render()\n  // Or we refactor to remove wrapper objects entirely.\n  // For more info on pros/cons see PR #8560 description.\n  invariant(\n    typeof parentInstance !== \"number\",\n    \"Container does not support insertBefore operation\"\n  );\n}\n\nfunction removeChild(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  var children = parentInstance._children;\n  var index = children.indexOf(child);\n\n  children.splice(index, 1);\n\n  UIManager.manageChildren(\n    parentInstance._nativeTag, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [index] // removeAtIndices\n  );\n}\n\nfunction removeChildFromContainer(parentInstance, child) {\n  recursivelyUncacheFiberNode(child);\n  UIManager.manageChildren(\n    parentInstance, // containerID\n    [], // moveFromIndices\n    [], // moveToIndices\n    [], // addChildReactTags\n    [], // addAtIndices\n    [0] // removeAtIndices\n  );\n}\n\nfunction resetTextContent(instance) {\n  // Noop\n}\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  var sourceInfo = \"\";\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, \"\");\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, \"\");\n            fileName = folderName + \"/\" + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = \" (at \" + fileName + \":\" + source.lineNumber + \")\";\n  } else if (ownerName) {\n    sourceInfo = \" (created by \" + ownerName + \")\";\n  }\n  return \"\\n    in \" + (name || \"Unknown\") + sourceInfo;\n};\n\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n    case ClassComponent:\n    case ClassComponentLazy:\n    case HostComponent:\n    case Mode:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber.type);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner.type);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nvar current = null;\nvar phase = null;\n\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n    var owner = current._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner.type);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return \"\";\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackByFiberInDevAndProd(current);\n  }\n  return \"\";\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = null;\n    current = null;\n    phase = null;\n  }\n}\n\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    phase = null;\n  }\n}\n\nfunction setCurrentPhase(lifeCyclePhase) {\n  {\n    phase = lifeCyclePhase;\n  }\n}\n\nvar debugRenderPhaseSideEffects = false;\nvar debugRenderPhaseSideEffectsForStrictMode = false;\nvar enableGetDerivedStateFromCatch = false;\nvar enableSuspense = false;\nvar enableUserTimingAPI = true;\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\nvar warnAboutDeprecatedLifecycles = false;\nvar warnAboutLegacyContextAPI = false;\nvar enableProfilerTimer = true;\nvar enableSchedulerTracking = true;\n\n// Only used in www builds.\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning) {\n  var prefix = warning ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning ? \" Warning: \" + warning : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning) {\n  var componentName = getComponentName(fiber.type) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback... will force flush in \" +\n          expirationTime +\n          \" ms)\",\n        \"(Waiting for async callback...)\",\n        warning\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy.type) || \"Unknown\";\n        warning =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot\n      ? \"(React Tree Reconciliation: Completed Root)\"\n      : \"(React Tree Reconciliation: Yielded)\";\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, \"(React Tree Reconciliation)\", warning);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Snapshot Effects)\");\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Snapshot Effects: \" + count + \" Total)\",\n      \"(Committing Snapshot Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warningWithoutStack$1(false, \"Unexpected pop.\");\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warningWithoutStack$1(false, \"Unexpected Fiber popped.\");\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warningWithoutStack$1(\n        false,\n        \"Expected an empty stack. Something was not reset properly.\"\n      );\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n{\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyContextObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(\n  workInProgress,\n  Component,\n  didPushOwnContextIfProvider\n) {\n  if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n    // If the fiber is a context provider itself, when we read its context\n    // we may have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyContextObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(type) || \"Unknown\";\n    checkPropTypes(\n      contextTypes,\n      context,\n      \"context\",\n      name,\n      getCurrentFiberStackInDev\n    );\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextProvider(type) {\n  var childContextTypes = type.childContextTypes;\n  return childContextTypes !== null && childContextTypes !== undefined;\n}\n\nfunction popContext(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  invariant(\n    contextStackCursor.current === emptyContextObject,\n    \"Unexpected context found on stack. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== \"function\") {\n    {\n      var componentName = getComponentName(type) || \"Unknown\";\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warningWithoutStack$1(\n          false,\n          \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n            \"on the instance. You can either define getChildContext() on %s or remove \" +\n            \"childContextTypes from it.\",\n          componentName,\n          componentName\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    setCurrentPhase(\"getChildContext\");\n  }\n  startPhaseTimer(fiber, \"getChildContext\");\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(type) || \"Unknown\",\n      contextKey\n    );\n  }\n  {\n    var name = getComponentName(type) || \"Unknown\";\n    checkPropTypes(\n      childContextTypes,\n      childContext,\n      \"child context\",\n      name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      getCurrentFiberStackInDev\n    );\n  }\n\n  return Object.assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext =\n    (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyContextObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(\n    didPerformWorkStackCursor,\n    didPerformWorkStackCursor.current,\n    workInProgress\n  );\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  var instance = workInProgress.stateNode;\n  invariant(\n    instance,\n    \"Expected to have an instance by this point. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(\n      workInProgress,\n      type,\n      previousContext\n    );\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) &&\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy),\n    \"Expected subtree parent to be a mounted class component. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var node = fiber;\n  do {\n    switch (node.tag) {\n      case HostRoot:\n        return node.stateNode.context;\n      case ClassComponent: {\n        var Component = node.type;\n        if (isContextProvider(Component)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var _Component = getResultFromResolvedThenable(node.type);\n        if (isContextProvider(_Component)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n        break;\n      }\n    }\n    node = node.return;\n  } while (node !== null);\n  invariant(\n    false,\n    \"Found unexpected detached subtree parent. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warningWithoutStack$1(\n          false,\n          \"React DevTools encountered an error: %s\",\n          err\n        );\n      }\n    }\n  };\n}\n\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warningWithoutStack$1(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warningWithoutStack$1(\n        false,\n        \"React DevTools encountered an error: %s.\",\n        err\n      );\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = maxSigned31BitInt;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE\n    )\n  );\n}\n\nvar LOW_PRIORITY_EXPIRATION = 5000;\nvar LOW_PRIORITY_BATCH_SIZE = 250;\n\nfunction computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE\n  );\n}\n\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\nvar HIGH_PRIORITY_EXPIRATION = 500;\nvar HIGH_PRIORITY_BATCH_SIZE = 100;\n\nfunction computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE\n  );\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.firstContextDependency = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction resolveLazyComponentTag(fiber, Component) {\n  if (typeof Component === \"function\") {\n    return shouldConstruct(Component)\n      ? ClassComponentLazy\n      : FunctionalComponentLazy;\n  } else if (\n    Component !== undefined &&\n    Component !== null &&\n    Component.$$typeof\n  ) {\n    return ForwardRefLazy;\n  }\n  return IndeterminateComponent;\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  // Don't touching the subtree's expiration time, which has not changed.\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  if (pendingProps !== current.pendingProps) {\n    // This fiber has new props.\n    workInProgress.expirationTime = expirationTime;\n  } else {\n    // This fiber's props have not changed.\n    workInProgress.expirationTime = current.expirationTime;\n  }\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.firstContextDependency = current.firstContextDependency;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === \"function\") {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === \"string\") {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key\n        );\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_PLACEHOLDER_TYPE:\n        fiberTag = PlaceholderComponent;\n        break;\n      default: {\n        if (typeof type === \"object\" && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break getTag;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break getTag;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = ForwardRef;\n              break getTag;\n            default: {\n              if (typeof type.then === \"function\") {\n                fiberTag = IndeterminateComponent;\n                break getTag;\n              }\n            }\n          }\n        }\n        var info = \"\";\n        {\n          if (\n            type === undefined ||\n            (typeof type === \"object\" &&\n              type !== null &&\n              Object.keys(type).length === 0)\n          ) {\n            info +=\n              \" You likely forgot to export your component from the file \" +\n              \"it's defined in, or you might have mixed up default and \" +\n              \"named imports.\";\n          }\n          var ownerName = owner ? getComponentName(owner.type) : null;\n          if (ownerName) {\n            info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n        }\n        invariant(\n          false,\n          \"Element type is invalid: expected a string (for built-in \" +\n            \"components) or a class/function (for composite components) \" +\n            \"but got: %s.%s\",\n          type == null ? type : typeof type,\n          info\n        );\n      }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (\n      typeof pendingProps.id !== \"string\" ||\n      typeof pendingProps.onRender !== \"function\"\n    ) {\n      warningWithoutStack$1(\n        false,\n        'Profiler must specify an \"id\" string and \"onRender\" function as props'\n      );\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.firstContextDependency = source.firstContextDependency;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n/* eslint-disable no-use-before-define */\n// TODO: This should be lifted into the renderer.\n\n// The following attributes are only used by interaction tracking builds.\n// They enable interactions to be associated with their async work,\n// And expose interaction metadata to the React DevTools Profiler plugin.\n// Note that these attributes are only defined when the enableSchedulerTracking flag is enabled.\n\n// Exported FiberRoot type includes all properties,\n// To avoid requiring potentially error-prone :any casts throughout the project.\n// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracking is true).\n// The types are defined separately within this file to ensure they stay in sync.\n// (We don't have to use an inline :any cast when enableSchedulerTracking is disabled.)\n\n/* eslint-enable no-use-before-define */\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n\n  var root = void 0;\n  if (enableSchedulerTracking) {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null,\n\n      interactionThreadID: tracking.unstable_getThreadID(),\n      memoizedInteractions: new Set(),\n      pendingInteractionMap: new Map()\n    };\n  } else {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null\n    };\n  }\n\n  uninitializedFiber.stateNode = root;\n\n  // The reason for the way the Flow types are structured in this file,\n  // Is to avoid needing :any casts everywhere interaction tracking fields are used.\n  // Unfortunately that requires an :any cast for non-interaction tracking capable builds.\n  // $FlowFixMe Remove this :any cast and replace it with something better.\n  return root;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function() {};\n\n{\n  var printWarning = function(format) {\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 1 ? _len - 1 : 0),\n        _key = 1;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message =\n      \"Warning: \" +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function(condition, format) {\n    if (format === undefined) {\n      throw new Error(\n        \"`lowPriorityWarning(condition, format, ...args)` requires a warning \" +\n          \"message argument\"\n      );\n    }\n    if (!condition) {\n      for (\n        var _len2 = arguments.length,\n          args = Array(_len2 > 2 ? _len2 - 2 : 0),\n          _key2 = 2;\n        _key2 < _len2;\n        _key2++\n      ) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function() {},\n  flushPendingDeprecationWarnings: function() {},\n  flushPendingUnsafeLifecycleWarnings: function() {},\n  recordDeprecationWarnings: function(fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n  recordLegacyContextWarning: function(fiber, instance) {},\n  flushLegacyContextWarning: function() {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: \"componentDidMount\",\n    UNSAFE_componentWillReceiveProps: \"static getDerivedStateFromProps\",\n    UNSAFE_componentWillUpdate: \"componentDidUpdate\"\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function(set) {\n    var array = [];\n    set.forEach(function(value) {\n      array.push(value);\n    });\n    return array.sort().join(\", \");\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function() {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n    pendingUnsafeLifecycleWarnings.forEach(function(\n      lifecycleWarningsMap,\n      strictRoot\n    ) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function(fiber) {\n            componentNames.add(getComponentName(fiber.type) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace(\"UNSAFE_\", \"\");\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(\n            formatted +\n              \": Please update the following components to use \" +\n              (suggestion + \" instead: \" + sortedComponentNames)\n          );\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n        warningWithoutStack$1(\n          false,\n          \"Unsafe lifecycle methods were found within a strict-mode tree:%s\" +\n            \"\\n\\n%s\" +\n            \"\\n\\nLearn more about this warning here:\" +\n            \"\\nhttps://fb.me/react-strict-mode-warnings\",\n          strictRootComponentStack,\n          lifecyclesWarningMesages.join(\"\\n\\n\")\n        );\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function(fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function() {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillMount is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidMount instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillMount.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        sortedNames\n      );\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n        _uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillReceiveProps is deprecated and will be removed in the next major version. \" +\n          \"Use static getDerivedStateFromProps instead.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames\n      );\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n        _uniqueNames2.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(\n        false,\n        \"componentWillUpdate is deprecated and will be removed in the next major version. \" +\n          \"Use componentDidUpdate instead. As a temporary workaround, \" +\n          \"you can rename to UNSAFE_componentWillUpdate.\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-async-component-lifecycle-hooks\",\n        _sortedNames2\n      );\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function(\n    fiber,\n    instance\n  ) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (\n      typeof instance.componentWillMount === \"function\" &&\n      instance.componentWillMount.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (\n      typeof instance.componentWillUpdate === \"function\" &&\n      instance.componentWillUpdate.__suppressDeprecationWarning !== true\n    ) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (\n      (typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillMount === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillMount\");\n    }\n    if (\n      (typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !==\n          true) ||\n      typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillReceiveProps\");\n    }\n    if (\n      (typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true) ||\n      typeof instance.UNSAFE_componentWillUpdate === \"function\"\n    ) {\n      unsafeLifecycles.push(\"UNSAFE_componentWillUpdate\");\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function(lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function(\n    fiber,\n    instance\n  ) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(\n        false,\n        \"Expected to find a StrictMode component in a strict mode tree. \" +\n          \"This error is likely caused by a bug in React. Please file an issue.\"\n      );\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (\n      fiber.type.contextTypes != null ||\n      fiber.type.childContextTypes != null ||\n      (instance !== null && typeof instance.getChildContext === \"function\")\n    ) {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n    pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function(fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || \"Component\");\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n      warningWithoutStack$1(\n        false,\n        \"Legacy context API has been detected within a strict-mode tree: %s\" +\n          \"\\n\\nPlease update the following components: %s\" +\n          \"\\n\\nLearn more about this warning here:\" +\n          \"\\nhttps://fb.me/react-strict-mode-warnings\",\n        strictRootComponentStack,\n        sortedNames\n      );\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates should never suspend. However, a promise that\n// suspended inside an offscreen subtree should be able to ping at the priority\n// of the outer render.\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  // If there's a gap between completing a failed root and retrying it,\n  // additional updates may be scheduled. Clear `didError`, in case the update\n  // is sufficient to fix the error.\n  root.didError = false;\n\n  // Update the latest and earliest pending times\n  var earliestPendingTime = root.earliestPendingTime;\n  if (earliestPendingTime === NoWork) {\n    // No other pending updates.\n    root.earliestPendingTime = root.latestPendingTime = expirationTime;\n  } else {\n    if (earliestPendingTime > expirationTime) {\n      // This is the earliest pending update.\n      root.earliestPendingTime = expirationTime;\n    } else {\n      var latestPendingTime = root.latestPendingTime;\n      if (latestPendingTime < expirationTime) {\n        // This is the latest pending update\n        root.latestPendingTime = expirationTime;\n      }\n    }\n  }\n  findNextExpirationTimeToWorkOn(expirationTime, root);\n}\n\nfunction markCommittedPriorityLevels(root, earliestRemainingTime) {\n  root.didError = false;\n\n  if (earliestRemainingTime === NoWork) {\n    // Fast path. There's no remaining work. Clear everything.\n    root.earliestPendingTime = NoWork;\n    root.latestPendingTime = NoWork;\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // Let's see if the previous latest known pending level was just flushed.\n  var latestPendingTime = root.latestPendingTime;\n  if (latestPendingTime !== NoWork) {\n    if (latestPendingTime < earliestRemainingTime) {\n      // We've flushed all the known pending levels.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      var earliestPendingTime = root.earliestPendingTime;\n      if (earliestPendingTime < earliestRemainingTime) {\n        // We've flushed the earliest known pending level. Set this to the\n        // latest pending time.\n        root.earliestPendingTime = root.latestPendingTime;\n      }\n    }\n  }\n\n  // Now let's handle the earliest remaining level in the whole tree. We need to\n  // decide whether to treat it as a pending level or as suspended. Check\n  // it falls within the range of known suspended levels.\n\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestRemainingTime > latestSuspendedTime) {\n    // The earliest remaining level is later than all the suspended work. That\n    // means we've flushed all the suspended work.\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  if (earliestRemainingTime < earliestSuspendedTime) {\n    // The earliest remaining time is earlier than all the suspended work.\n    // Treat it as a pending update.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // The earliest remaining time falls within the range of known suspended\n  // levels. We should treat this as suspended work.\n  findNextExpirationTimeToWorkOn(NoWork, root);\n}\n\nfunction hasLowerPriorityWork(root, erroredExpirationTime) {\n  var latestPendingTime = root.latestPendingTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var latestPingedTime = root.latestPingedTime;\n  return (\n    (latestPendingTime !== NoWork &&\n      latestPendingTime > erroredExpirationTime) ||\n    (latestSuspendedTime !== NoWork &&\n      latestSuspendedTime > erroredExpirationTime) ||\n    (latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime)\n  );\n}\n\nfunction isPriorityLevelSuspended(root, expirationTime) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  return (\n    earliestSuspendedTime !== NoWork &&\n    expirationTime >= earliestSuspendedTime &&\n    expirationTime <= latestSuspendedTime\n  );\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime) {\n  root.didError = false;\n  clearPing(root, suspendedTime);\n\n  // First, check the known pending levels and update them if needed.\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPendingTime = root.latestPendingTime;\n  if (earliestPendingTime === suspendedTime) {\n    if (latestPendingTime === suspendedTime) {\n      // Both known pending levels were suspended. Clear them.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      // The earliest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.earliestPendingTime = latestPendingTime;\n    }\n  } else if (latestPendingTime === suspendedTime) {\n    // The latest pending level was suspended. Clear by setting it to the\n    // latest pending level.\n    root.latestPendingTime = earliestPendingTime;\n  }\n\n  // Finally, update the known suspended levels.\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // No other suspended levels.\n    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n  } else {\n    if (earliestSuspendedTime > suspendedTime) {\n      // This is the earliest suspended level.\n      root.earliestSuspendedTime = suspendedTime;\n    } else if (latestSuspendedTime < suspendedTime) {\n      // This is the latest suspended level\n      root.latestSuspendedTime = suspendedTime;\n    }\n  }\n\n  findNextExpirationTimeToWorkOn(suspendedTime, root);\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  root.didError = false;\n\n  // TODO: When we add back resuming, we need to ensure the progressed work\n  // is thrown out and not reused during the restarted render. One way to\n  // invalidate the progressed work is to restart at expirationTime + 1.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n    root.latestPingedTime = pingedTime;\n  }\n  findNextExpirationTimeToWorkOn(pingedTime, root);\n}\n\nfunction clearPing(root, completedTime) {\n  // TODO: Track whether the root was pinged during the render phase. If so,\n  // we need to make sure we don't lose track of it.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {\n    root.latestPingedTime = NoWork;\n  }\n}\n\nfunction findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\n  var earliestExpirationTime = renderExpirationTime;\n\n  var earliestPendingTime = root.earliestPendingTime;\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (\n    earliestExpirationTime === NoWork ||\n    (earliestPendingTime !== NoWork &&\n      earliestPendingTime < earliestExpirationTime)\n  ) {\n    earliestExpirationTime = earliestPendingTime;\n  }\n  if (\n    earliestExpirationTime === NoWork ||\n    (earliestSuspendedTime !== NoWork &&\n      earliestSuspendedTime < earliestExpirationTime)\n  ) {\n    earliestExpirationTime = earliestSuspendedTime;\n  }\n  return earliestExpirationTime;\n}\n\nfunction didExpireAtExpirationTime(root, currentTime) {\n  var expirationTime = root.expirationTime;\n  if (expirationTime !== NoWork && currentTime >= expirationTime) {\n    // The root has expired. Flush all work up to the current time.\n    root.nextExpirationTimeToWorkOn = currentTime;\n  }\n}\n\nfunction findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPingedTime = root.latestPingedTime;\n\n  // Work on the earliest pending time. Failing that, work on the latest\n  // pinged time.\n  var nextExpirationTimeToWorkOn =\n    earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\n\n  // If there is no pending or pinged work, check if there's suspended work\n  // that's lower priority than what we just completed.\n  if (\n    nextExpirationTimeToWorkOn === NoWork &&\n    (completedExpirationTime === NoWork ||\n      latestSuspendedTime > completedExpirationTime)\n  ) {\n    // The lowest priority suspended work is the work most likely to be\n    // committed next. Let's start rendering it again, so that if it times out,\n    // it's ready to commit.\n    nextExpirationTimeToWorkOn = latestSuspendedTime;\n  }\n\n  var expirationTime = nextExpirationTimeToWorkOn;\n  if (\n    expirationTime !== NoWork &&\n    earliestSuspendedTime !== NoWork &&\n    earliestSuspendedTime < expirationTime\n  ) {\n    // Expire using the earliest known expiration time.\n    expirationTime = earliestSuspendedTime;\n  }\n\n  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n  root.expirationTime = expirationTime;\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed  a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function() {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nfunction enqueueUpdate(fiber, update) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(\n          alternate.memoizedState\n        );\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list  we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if (\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) &&\n      (currentlyProcessingQueue === queue1 ||\n        (queue2 !== null && currentlyProcessingQueue === queue2)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warningWithoutStack$1(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(\n      workInProgress.memoizedState\n    );\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(\n      workInProgress,\n      workInProgressQueue\n    );\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(\n  workInProgress,\n  queue,\n  update,\n  prevState,\n  nextProps,\n  instance\n) {\n  switch (update.tag) {\n    case ReplaceState: {\n      var _payload = update.payload;\n      if (typeof _payload === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload.call(instance, prevState, nextProps);\n          }\n        }\n        return _payload.call(instance, prevState, nextProps);\n      }\n      // State object\n      return _payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      var _payload2 = update.payload;\n      var partialState = void 0;\n      if (typeof _payload2 === \"function\") {\n        // Updater function\n        {\n          if (\n            debugRenderPhaseSideEffects ||\n            (debugRenderPhaseSideEffectsForStrictMode &&\n              workInProgress.mode & StrictMode)\n          ) {\n            _payload2.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = _payload2.call(instance, prevState, nextProps);\n      } else {\n        // Partial state object\n        partialState = _payload2;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(\n  workInProgress,\n  queue,\n  props,\n  instance,\n  renderExpirationTime\n) {\n  hasForceUpdate = false;\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > updateExpirationTime\n      ) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (\n        newExpirationTime === NoWork ||\n        newExpirationTime > _updateExpirationTime\n      ) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(\n        workInProgress,\n        queue,\n        update,\n        resultState,\n        props,\n        instance\n      );\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === \"function\",\n    \"Invalid argument passed as callback. Expected a function. Instead \" +\n      \"received: %s\",\n    callback\n  );\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(\n  finishedWork,\n  finishedQueue,\n  instance,\n  renderExpirationTime\n) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects(effect, instance) {\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function(condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (\n      var _len = arguments.length,\n        args = Array(_len > 2 ? _len - 2 : 0),\n        _key = 2;\n      _key < _len;\n      _key++\n    ) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(\n      undefined,\n      [false, format + \"%s\"].concat(args, [stack])\n    );\n  };\n}\n\nvar warning$1 = warning;\n\nvar valueCursor = createCursor(null);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastContextWithAllBitsObserved = null;\n\nfunction resetContextDependences() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n}\n\nfunction pushProvider(providerFiber, nextValue) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n\n    context._currentValue = nextValue;\n    {\n      !(\n        context._currentRenderer === undefined ||\n        context._currentRenderer === null ||\n        context._currentRenderer === rendererSigil\n      )\n        ? warningWithoutStack$1(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n\n    context._currentValue2 = nextValue;\n    {\n      !(\n        context._currentRenderer2 === undefined ||\n        context._currentRenderer2 === null ||\n        context._currentRenderer2 === rendererSigil\n      )\n        ? warningWithoutStack$1(\n            false,\n            \"Detected multiple renderers concurrently rendering the \" +\n              \"same context provider. This is currently unsupported.\"\n          )\n        : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var currentValue = valueCursor.current;\n\n  pop(valueCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n  } else {\n    context._currentValue2 = currentValue;\n  }\n}\n\nfunction calculateChangedBits(context, newValue, oldValue) {\n  // Use Object.is to compare the new context value to the old value. Inlined\n  // Object.is polyfill.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  if (\n    (oldValue === newValue &&\n      (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||\n    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare\n  ) {\n    // No change\n    return 0;\n  } else {\n    var changedBits =\n      typeof context._calculateChangedBits === \"function\"\n        ? context._calculateChangedBits(oldValue, newValue)\n        : maxSigned31BitInt;\n\n    {\n      !((changedBits & maxSigned31BitInt) === changedBits)\n        ? warning$1(\n            false,\n            \"calculateChangedBits: Expected the return value to be a \" +\n              \"31-bit integer. Instead received: %s\",\n            changedBits\n          )\n        : void 0;\n    }\n    return changedBits | 0;\n  }\n}\n\nfunction propagateContextChange(\n  workInProgress,\n  context,\n  changedBits,\n  renderExpirationTime\n) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n\n    // Visit this fiber.\n    var dependency = fiber.firstContextDependency;\n    if (dependency !== null) {\n      do {\n        // Check if the context matches.\n        if (\n          dependency.context === context &&\n          (dependency.observedBits & changedBits) !== 0\n        ) {\n          // Match! Schedule an update on this fiber.\n\n          if (\n            fiber.tag === ClassComponent ||\n            fiber.tag === ClassComponentLazy\n          ) {\n            // Schedule a force update on the work-in-progress.\n            var update = createUpdate(renderExpirationTime);\n            update.tag = ForceUpdate;\n            // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            enqueueUpdate(fiber, update);\n          }\n\n          if (\n            fiber.expirationTime === NoWork ||\n            fiber.expirationTime > renderExpirationTime\n          ) {\n            fiber.expirationTime = renderExpirationTime;\n          }\n          var alternate = fiber.alternate;\n          if (\n            alternate !== null &&\n            (alternate.expirationTime === NoWork ||\n              alternate.expirationTime > renderExpirationTime)\n          ) {\n            alternate.expirationTime = renderExpirationTime;\n          }\n          // Update the child expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber.return;\n          while (node !== null) {\n            alternate = node.alternate;\n            if (\n              node.childExpirationTime === NoWork ||\n              node.childExpirationTime > renderExpirationTime\n            ) {\n              node.childExpirationTime = renderExpirationTime;\n              if (\n                alternate !== null &&\n                (alternate.childExpirationTime === NoWork ||\n                  alternate.childExpirationTime > renderExpirationTime)\n              ) {\n                alternate.childExpirationTime = renderExpirationTime;\n              }\n            } else if (\n              alternate !== null &&\n              (alternate.childExpirationTime === NoWork ||\n                alternate.childExpirationTime > renderExpirationTime)\n            ) {\n              alternate.childExpirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n        }\n        nextFiber = fiber.child;\n        dependency = dependency.next;\n      } while (dependency !== null);\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction prepareToReadContext(workInProgress, renderExpirationTime) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n\n  // Reset the work-in-progress list\n  workInProgress.firstContextDependency = null;\n}\n\nfunction readContext(context, observedBits) {\n  if (lastContextWithAllBitsObserved === context) {\n    // Nothing to do. We already observe everything in this context.\n  } else if (observedBits === false || observedBits === 0) {\n    // Do not observe any updates.\n  } else {\n    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.\n    if (\n      typeof observedBits !== \"number\" ||\n      observedBits === maxSigned31BitInt\n    ) {\n      // Observe all updates.\n      lastContextWithAllBitsObserved = context;\n      resolvedObservedBits = maxSigned31BitInt;\n    } else {\n      resolvedObservedBits = observedBits;\n    }\n\n    var contextItem = {\n      context: context,\n      observedBits: resolvedObservedBits,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      invariant(\n        currentlyRenderingFiber !== null,\n        \"Context.unstable_read(): Context can only be read while React is \" +\n          \"rendering, e.g. inside the render method or getDerivedStateFromProps.\"\n      );\n      // This is the first dependency in the list\n      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  invariant(\n    c !== NO_CONTEXT,\n    \"Expected host context to exist. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\nvar profilerStartTime = -1;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\n/*eslint-disable no-self-compare */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== \"object\" ||\n    objA === null ||\n    typeof objB !== \"object\" ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (\n      !hasOwnProperty.call(objB, keysA[i]) ||\n      !is(objA[keysA[i]], objB[keysA[i]])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject = new React.Component().refs;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutDirectlyAssigningPropsToState = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback, callerName) {\n    if (callback === null || typeof callback === \"function\") {\n      return;\n    }\n    var key = callerName + \"_\" + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack$1(\n        false,\n        \"%s(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callerName,\n        callback\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(type) || \"Component\";\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" +\n            \"You have returned undefined.\",\n          componentName\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState: function(inst, payload, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function(inst, callback) {\n    var fiber = get$1(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextLegacyContext\n) {\n  var instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === \"function\") {\n    startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n    var shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextLegacyContext\n    );\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined)\n        ? warningWithoutStack$1(\n            false,\n            \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n              \"boolean value. Make sure to return true or false.\",\n            getComponentName(ctor) || \"Component\"\n          )\n        : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n  {\n    var name = getComponentName(ctor) || \"Component\";\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n        warningWithoutStack$1(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: did you accidentally return an object from the constructor?\",\n          name\n        );\n      } else {\n        warningWithoutStack$1(\n          false,\n          \"%s(...): No `render` method found on the returned component \" +\n            \"instance: you may have forgotten to define `render`.\",\n          name\n        );\n      }\n    }\n\n    var noGetInitialStateOnES6 =\n      !instance.getInitialState ||\n      instance.getInitialState.isReactClassApproved ||\n      instance.state;\n    !noGetInitialStateOnES6\n      ? warningWithoutStack$1(\n          false,\n          \"getInitialState was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Did you mean to define a state property instead?\",\n          name\n        )\n      : void 0;\n    var noGetDefaultPropsOnES6 =\n      !instance.getDefaultProps ||\n      instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6\n      ? warningWithoutStack$1(\n          false,\n          \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n            \"This is only supported for classes created using React.createClass. \" +\n            \"Use a static property to define defaultProps instead.\",\n          name\n        )\n      : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes\n      ? warningWithoutStack$1(\n          false,\n          \"propTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define propTypes instead.\",\n          name\n        )\n      : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes\n      ? warningWithoutStack$1(\n          false,\n          \"contextTypes was defined as an instance property on %s. Use a static \" +\n            \"property to define contextTypes instead.\",\n          name\n        )\n      : void 0;\n    var noComponentShouldUpdate =\n      typeof instance.componentShouldUpdate !== \"function\";\n    !noComponentShouldUpdate\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n            \"The name is phrased as a question because the function is \" +\n            \"expected to return a value.\",\n          name\n        )\n      : void 0;\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== \"undefined\"\n    ) {\n      warningWithoutStack$1(\n        false,\n        \"%s has a method called shouldComponentUpdate(). \" +\n          \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n          \"Please extend React.Component if shouldComponentUpdate is used.\",\n        getComponentName(ctor) || \"A pure component\"\n      );\n    }\n    var noComponentDidUnmount =\n      typeof instance.componentDidUnmount !== \"function\";\n    !noComponentDidUnmount\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentDidUnmount(). But there is no such lifecycle method. \" +\n            \"Did you mean componentWillUnmount()?\",\n          name\n        )\n      : void 0;\n    var noComponentDidReceiveProps =\n      typeof instance.componentDidReceiveProps !== \"function\";\n    !noComponentDidReceiveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n            \"If you meant to update the state in response to changing props, \" +\n            \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n            \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n          name\n        )\n      : void 0;\n    var noComponentWillRecieveProps =\n      typeof instance.componentWillRecieveProps !== \"function\";\n    !noComponentWillRecieveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var noUnsafeComponentWillRecieveProps =\n      typeof instance.UNSAFE_componentWillRecieveProps !== \"function\";\n    !noUnsafeComponentWillRecieveProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s has a method called \" +\n            \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\",\n          name\n        )\n      : void 0;\n    var hasMutatedProps = instance.props !== newProps;\n    !(instance.props === undefined || !hasMutatedProps)\n      ? warningWithoutStack$1(\n          false,\n          \"%s(...): When calling super() in `%s`, make sure to pass \" +\n            \"up the same props that your component's constructor was passed.\",\n          name,\n          name\n        )\n      : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps\n      ? warningWithoutStack$1(\n          false,\n          \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n            \" Instead, define defaultProps as a static property on %s.\",\n          name,\n          name\n        )\n      : void 0;\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === \"function\" &&\n      typeof instance.componentDidUpdate !== \"function\" &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack$1(\n        false,\n        \"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" +\n          \"This component defines getSnapshotBeforeUpdate() only.\",\n        getComponentName(ctor)\n      );\n    }\n\n    var noInstanceGetDerivedStateFromProps =\n      typeof instance.getDerivedStateFromProps !== \"function\";\n    !noInstanceGetDerivedStateFromProps\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getDerivedStateFromProps() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noInstanceGetDerivedStateFromCatch =\n      typeof instance.getDerivedStateFromCatch !== \"function\";\n    !noInstanceGetDerivedStateFromCatch\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getDerivedStateFromCatch() is defined as an instance method \" +\n            \"and will be ignored. Instead, declare it as a static method.\",\n          name\n        )\n      : void 0;\n    var noStaticGetSnapshotBeforeUpdate =\n      typeof ctor.getSnapshotBeforeUpdate !== \"function\";\n    !noStaticGetSnapshotBeforeUpdate\n      ? warningWithoutStack$1(\n          false,\n          \"%s: getSnapshotBeforeUpdate() is defined as a static method \" +\n            \"and will be ignored. Instead, declare it as an instance method.\",\n          name\n        )\n      : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n      warningWithoutStack$1(\n        false,\n        \"%s.state: must be set to an object or null\",\n        name\n      );\n    }\n    if (typeof instance.getChildContext === \"function\") {\n      !(typeof ctor.childContextTypes === \"object\")\n        ? warningWithoutStack$1(\n            false,\n            \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n              \"use getChildContext().\",\n            name\n          )\n        : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress,\n  ctor,\n  props,\n  renderExpirationTime\n) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var contextTypes = ctor.contextTypes;\n  var isContextConsumer = contextTypes !== null && contextTypes !== undefined;\n  var context = isContextConsumer\n    ? getMaskedContext(workInProgress, unmaskedContext)\n    : emptyContextObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (\n      debugRenderPhaseSideEffects ||\n      (debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode)\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n      var componentName = getComponentName(ctor) || \"Component\";\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"`%s` uses `getDerivedStateFromProps` but its initial state is \" +\n            \"%s. This is not recommended. Instead, define the initial state by \" +\n            \"assigning an object to `this.state` in the constructor of `%s`. \" +\n            \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\",\n          componentName,\n          instance.state === null ? \"null\" : \"undefined\",\n          componentName\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === \"function\" ||\n      typeof instance.getSnapshotBeforeUpdate === \"function\"\n    ) {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === \"function\" &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = \"componentWillMount\";\n      } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        foundWillMountName = \"UNSAFE_componentWillMount\";\n      }\n      if (\n        typeof instance.componentWillReceiveProps === \"function\" &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = \"componentWillReceiveProps\";\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === \"function\"\n      ) {\n        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n      }\n      if (\n        typeof instance.componentWillUpdate === \"function\" &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = \"componentWillUpdate\";\n      } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        var _componentName = getComponentName(ctor) || \"Component\";\n        var newApiName =\n          typeof ctor.getDerivedStateFromProps === \"function\"\n            ? \"getDerivedStateFromProps()\"\n            : \"getSnapshotBeforeUpdate()\";\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warningWithoutStack$1(\n            false,\n            \"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" +\n              \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" +\n              \"The above lifecycles should be removed. Learn more about this warning here:\\n\" +\n              \"https://fb.me/react-async-component-lifecycle-hooks\",\n            _componentName,\n            newApiName,\n            foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\",\n            foundWillReceivePropsName !== null\n              ? \"\\n  \" + foundWillReceivePropsName\n              : \"\",\n            foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\"\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, \"componentWillMount\");\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === \"function\") {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warningWithoutStack$1(\n        false,\n        \"%s.componentWillMount(): Assigning directly to this.state is \" +\n          \"deprecated (except inside a component's \" +\n          \"constructor). Use setState instead.\",\n        getComponentName(workInProgress.type) || \"Component\"\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextLegacyContext\n) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n  if (typeof instance.componentWillReceiveProps === \"function\") {\n    instance.componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress.type) || \"Component\";\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s.componentWillReceiveProps(): Assigning directly to \" +\n            \"this.state is deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          componentName\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentName(ctor) || \"Component\";\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack$1(\n          false,\n          \"%s: It is not recommended to assign props directly to state \" +\n            \"because updates to props won't be reflected in state. \" +\n            \"In most cases, it is better to use props directly.\",\n          componentName\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance\n      );\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(\n        workInProgress,\n        instance\n      );\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== \"function\" &&\n    typeof instance.getSnapshotBeforeUpdate !== \"function\" &&\n    (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n      typeof instance.componentWillMount === \"function\")\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(\n        workInProgress,\n        updateQueue,\n        newProps,\n        instance,\n        renderExpirationTime\n      );\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === \"function\") {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(\n    workInProgress,\n    ctor,\n    true\n  );\n  var nextLegacyContext = getMaskedContext(\n    workInProgress,\n    nextLegacyUnmaskedContext\n  );\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextLegacyContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === \"function\" ||\n        typeof instance.componentWillMount === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillMount\");\n      if (typeof instance.componentWillMount === \"function\") {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current,\n  workInProgress,\n  ctor,\n  newProps,\n  renderExpirationTime\n) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(\n    workInProgress,\n    ctor,\n    true\n  );\n  var nextLegacyContext = getMaskedContext(\n    workInProgress,\n    nextLegacyUnmaskedContext\n  );\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles =\n    typeof getDerivedStateFromProps === \"function\" ||\n    typeof instance.getSnapshotBeforeUpdate === \"function\";\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" ||\n      typeof instance.componentWillReceiveProps === \"function\")\n  ) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextLegacyContext\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = (instance.state = oldState);\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(\n      workInProgress,\n      updateQueue,\n      newProps,\n      instance,\n      renderExpirationTime\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === \"function\") {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextLegacyContext\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === \"function\" ||\n        typeof instance.componentWillUpdate === \"function\")\n    ) {\n      startPhaseTimer(workInProgress, \"componentWillUpdate\");\n      if (typeof instance.componentWillUpdate === \"function\") {\n        instance.componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n        instance.UNSAFE_componentWillUpdate(\n          newProps,\n          newState,\n          nextLegacyContext\n        );\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutGenerators = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function(child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning$1(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.\"\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current$$1, element) {\n  var mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== \"function\" &&\n    typeof mixedRef !== \"object\"\n  ) {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber.type) || \"Component\";\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warningWithoutStack$1(\n            false,\n            'A string ref, \"%s\", has been found within a strict mode tree. ' +\n              \"String refs are a source of potential bugs and should be avoided. \" +\n              \"We recommend using createRef() instead.\" +\n              \"\\n%s\" +\n              \"\\n\\nLearn more about using refs safely here:\" +\n              \"\\nhttps://fb.me/react-strict-mode-string-ref\",\n            mixedRef,\n            getStackByFiberInDevAndProd(returnFiber)\n          );\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent ||\n            ownerFiber.tag === ClassComponentLazy,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current$$1 !== null &&\n        current$$1.ref !== null &&\n        typeof current$$1.ref === \"function\" &&\n        current$$1.ref._stringRef === stringRef\n      ) {\n        return current$$1.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was set. This could happen for one of\" +\n          \" the following reasons:\\n\" +\n          \"1. You may be adding a ref to a functional component\\n\" +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          \"3. You have multiple copies of React loaded\\n\" +\n          \"See https://fb.me/react-refs-must-have-owner for more information.\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        getCurrentFiberStackInDev();\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning$1(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current$$1 = newFiber.alternate;\n    if (current$$1 !== null) {\n      var oldIndex = current$$1.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber,\n    current$$1,\n    textContent,\n    expirationTime\n  ) {\n    if (current$$1 === null || current$$1.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current$$1, element, expirationTime) {\n    if (current$$1 !== null && current$$1.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current$$1, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current$$1, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.ref = coerceRef(returnFiber, current$$1, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current$$1, portal, expirationTime) {\n    if (\n      current$$1 === null ||\n      current$$1.tag !== HostPortal ||\n      current$$1.stateNode.containerInfo !== portal.containerInfo ||\n      current$$1.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(\n        current$$1,\n        portal.children || [],\n        expirationTime\n      );\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber,\n    current$$1,\n    fragment,\n    expirationTime,\n    key\n  ) {\n    if (current$$1 === null || current$$1.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.mode,\n        expirationTime\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created.ref = coerceRef(returnFiber, null, newChild);\n          _created.return = returnFiber;\n          return _created;\n        }\n        case REACT_PORTAL_TYPE: {\n          var _created2 = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime\n          );\n          _created2.return = returnFiber;\n          return _created2;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null\n        );\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber3,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning$1(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.\",\n            key\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === \"function\" &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === \"Generator\"\n      ) {\n        !didWarnAboutGenerators\n          ? warning$1(\n              false,\n              \"Using Generators as children is unsupported and will likely yield \" +\n                \"unexpected results because enumerating a generator mutates it. \" +\n                \"You may convert it to an array with `Array.from()` or the \" +\n                \"`[...spread]` operator before rendering. Keep in mind \" +\n                \"you might need to polyfill these features for older browsers.\"\n            )\n          : void 0;\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps\n          ? warning$1(\n              false,\n              \"Using Maps as children is unsupported and will likely yield \" +\n                \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n                \"ReactElements instead.\"\n            )\n          : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(\n        element,\n        returnFiber.mode,\n        expirationTime\n      );\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment =\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\" && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n        case ClassComponentLazy: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current$$1, workInProgress) {\n  invariant(\n    current$$1 === null || workInProgress.child === current$$1.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(\n          returnFiber.stateNode.containerInfo,\n          instance\n        );\n        break;\n      case HostComponent:\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance\n        );\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        var parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostComponent:\n            var type = fiber.type;\n            var props = fiber.pendingProps;\n            didNotFindHydratableContainerInstance(parentContainer, type, props);\n            break;\n          case HostText:\n            var text = fiber.pendingProps;\n            didNotFindHydratableContainerTextInstance(parentContainer, text);\n            break;\n        }\n        break;\n      }\n      case HostComponent: {\n        var parentType = returnFiber.type;\n        var parentProps = returnFiber.memoizedProps;\n        var parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostComponent:\n            var _type = fiber.type;\n            var _props = fiber.pendingProps;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _type,\n              _props\n            );\n            break;\n          case HostText:\n            var _text = fiber.pendingProps;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              _text\n            );\n            break;\n        }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent: {\n      var type = fiber.type;\n      var props = fiber.pendingProps;\n      var instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = instance;\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      var text = fiber.pendingProps;\n      var textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = textInstance;\n        return true;\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber,\n  rootContainerInstance,\n  hostContext\n) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    rootContainerInstance,\n    hostContext,\n    fiber\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(\n      false,\n      \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot: {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(\n              parentContainer,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n          case HostComponent: {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              textInstance,\n              textContent\n            );\n            break;\n          }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (\n    fiber.tag !== HostComponent ||\n    (type !== \"head\" &&\n      type !== \"body\" &&\n      !shouldSetTextContent(type, fiber.memoizedProps))\n  ) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber\n    ? getNextHydratableSibling(fiber.stateNode)\n    : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction readLazyComponentType(thenable) {\n  var status = thenable._reactStatus;\n  switch (status) {\n    case Resolved:\n      var Component = thenable._reactResult;\n      return Component;\n    case Rejected:\n      throw thenable._reactResult;\n    case Pending:\n      throw thenable;\n    default: {\n      thenable._reactStatus = Pending;\n      thenable.then(\n        function(resolvedValue) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Resolved;\n            if (typeof resolvedValue === \"object\" && resolvedValue !== null) {\n              // If the `default` property is not empty, assume it's the result\n              // of an async import() and use that. Otherwise, use the\n              // resolved value itself.\n              var defaultExport = resolvedValue.default;\n              resolvedValue =\n                defaultExport !== undefined && defaultExport !== null\n                  ? defaultExport\n                  : resolvedValue;\n            } else {\n              resolvedValue = resolvedValue;\n            }\n            thenable._reactResult = resolvedValue;\n          }\n        },\n        function(error) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Rejected;\n            thenable._reactResult = error;\n          }\n        }\n      );\n      throw thenable;\n    }\n  }\n}\n\nvar ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nfunction reconcileChildren(\n  current$$1,\n  workInProgress,\n  nextChildren,\n  renderExpirationTime\n) {\n  if (current$$1 === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current$$1.child,\n      nextChildren,\n      renderExpirationTime\n    );\n  }\n}\n\nfunction updateForwardRef(\n  current$$1,\n  workInProgress,\n  type,\n  nextProps,\n  renderExpirationTime\n) {\n  var render = type.render;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current$$1 !== null ? current$$1.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    nextChildren = render(nextProps, ref);\n    setCurrentPhase(null);\n  }\n\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current$$1, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current$$1, workInProgress) {\n  var ref = workInProgress.ref;\n  if (\n    (current$$1 === null && ref !== null) ||\n    (current$$1 !== null && current$$1.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime\n) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    nextChildren = Component(nextProps, context);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime\n) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = void 0;\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var shouldUpdate = void 0;\n  if (current$$1 === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n      mountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(\n        workInProgress,\n        Component,\n        nextProps,\n        renderExpirationTime\n      );\n    }\n  } else {\n    shouldUpdate = updateClassInstance(\n      current$$1,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime\n    );\n  }\n  return finishClassComponent(\n    current$$1,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime\n  );\n}\n\nfunction finishClassComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  shouldUpdate,\n  hasContext,\n  renderExpirationTime\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current$$1, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner$3.current = workInProgress;\n  var nextChildren = void 0;\n  if (\n    didCaptureError &&\n    (!enableGetDerivedStateFromCatch ||\n      typeof Component.getDerivedStateFromCatch !== \"function\")\n  ) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    {\n      setCurrentPhase(\"render\");\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffects ||\n        (debugRenderPhaseSideEffectsForStrictMode &&\n          workInProgress.mode & StrictMode)\n      ) {\n        instance.render();\n      }\n      setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current$$1 !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current$$1, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  invariant(\n    updateQueue !== null,\n    \"If the root does not have an updateQueue, we should have already \" +\n      \"bailed out. This error is likely caused by a bug in React. Please \" +\n      \"file an issue.\"\n  );\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(\n    workInProgress,\n    updateQueue,\n    nextProps,\n    null,\n    renderExpirationTime\n  );\n  var nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  var nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n  var root = workInProgress.stateNode;\n  if (\n    (current$$1 === null || current$$1.child === null) &&\n    root.hydrate &&\n    enterHydrationState(workInProgress)\n  ) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    // This is a bit of a hack. We track the host root as a placement to\n    // know that we're currently in a mounting state. That way isMounted\n    // works as expected. We must reset this before committing.\n    // TODO: Delete this when we delete isMounted and findDOMNode.\n    workInProgress.effectTag |= Placement;\n\n    // Ensure that children mount into this root without tracking\n    // side-effects. This ensures that we don't store Placement effects on\n    // nodes that will be hydrated.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current$$1, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (\n    renderExpirationTime !== Never &&\n    workInProgress.mode & AsyncMode &&\n    shouldDeprioritizeSubtree(type, nextProps)\n  ) {\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = Never;\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  );\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current$$1, workInProgress) {\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = Object.assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n    return props;\n  }\n  return baseProps;\n}\n\nfunction mountIndeterminateComponent(\n  current$$1,\n  workInProgress,\n  Component,\n  renderExpirationTime\n) {\n  invariant(\n    current$$1 === null,\n    \"An indeterminate component should never have mounted. This error is \" +\n      \"likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var props = workInProgress.pendingProps;\n  if (\n    typeof Component === \"object\" &&\n    Component !== null &&\n    typeof Component.then === \"function\"\n  ) {\n    Component = readLazyComponentType(Component);\n    var resolvedTag = (workInProgress.tag = resolveLazyComponentTag(\n      workInProgress,\n      Component\n    ));\n    var resolvedProps = resolveDefaultProps(Component, props);\n    switch (resolvedTag) {\n      case FunctionalComponentLazy: {\n        return updateFunctionalComponent(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      case ClassComponentLazy: {\n        return updateClassComponent(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      case ForwardRefLazy: {\n        return updateForwardRef(\n          current$$1,\n          workInProgress,\n          Component,\n          resolvedProps,\n          renderExpirationTime\n        );\n      }\n      default: {\n        // This message intentionally doesn't metion ForwardRef because the\n        // fact that it's a separate type of work is an implementation detail.\n        invariant(\n          false,\n          \"Element type is invalid. Received a promise that resolves to: %s. \" +\n            \"Promise elements must resolve to a class or function.\",\n          Component\n        );\n      }\n    }\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var value = void 0;\n\n  {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === \"function\"\n    ) {\n      var componentName = getComponentName(Component) || \"Unknown\";\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack$1(\n          false,\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n          componentName,\n          componentName\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner$3.current = workInProgress;\n    value = Component(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    typeof value.render === \"function\" &&\n    value.$$typeof === undefined\n  ) {\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = false;\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === \"function\") {\n      applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        getDerivedStateFromProps,\n        props\n      );\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(\n      current$$1,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderExpirationTime\n    );\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      if (Component) {\n        !!Component.childContextTypes\n          ? warningWithoutStack$1(\n              false,\n              \"%s(...): childContextTypes cannot be defined on a functional component.\",\n              Component.displayName || Component.name || \"Component\"\n            )\n          : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = \"\";\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        if (ownerName) {\n          info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || \"\";\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning$1(\n            false,\n            \"Stateless function components cannot be given refs. \" +\n              \"Attempts to access this ref will fail.%s\",\n            info\n          );\n        }\n      }\n\n      if (typeof Component.getDerivedStateFromProps === \"function\") {\n        var _componentName = getComponentName(Component) || \"Unknown\";\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warningWithoutStack$1(\n            false,\n            \"%s: Stateless functional components do not support getDerivedStateFromProps.\",\n            _componentName\n          );\n          didWarnAboutGetDerivedStateOnFunctionalComponent[\n            _componentName\n          ] = true;\n        }\n      }\n    }\n    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updatePlaceholderComponent(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n\n    var nextDidTimeout = void 0;\n    if (current$$1 !== null && workInProgress.updateQueue !== null) {\n      // We're outside strict mode. Something inside this Placeholder boundary\n      // suspended during the last commit. Switch to the placholder.\n      workInProgress.updateQueue = null;\n      nextDidTimeout = true;\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n      current$$1.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    } else {\n      nextDidTimeout = !alreadyCaptured;\n    }\n\n    if ((workInProgress.mode & StrictMode) !== NoEffect) {\n      if (nextDidTimeout) {\n        // If the timed-out view commits, schedule an update effect to record\n        // the committed time.\n        workInProgress.effectTag |= Update;\n      } else {\n        // The state node points to the time at which placeholder timed out.\n        // We can clear it once we switch back to the normal children.\n        workInProgress.stateNode = null;\n      }\n    }\n\n    // If the `children` prop is a function, treat it like a render prop.\n    // TODO: This is temporary until we finalize a lower level API.\n    var children = nextProps.children;\n    var nextChildren = void 0;\n    if (typeof children === \"function\") {\n      nextChildren = children(nextDidTimeout);\n    } else {\n      nextChildren = nextDidTimeout ? nextProps.fallback : children;\n    }\n\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (current$$1 === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime\n    );\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(\n      current$$1,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(\n        providerPropTypes,\n        newProps,\n        \"prop\",\n        \"Context.Provider\",\n        getCurrentFiberStackInDev\n      );\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    var oldValue = oldProps.value;\n    var changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(\n          current$$1,\n          workInProgress,\n          renderExpirationTime\n        );\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime\n      );\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    newChildren,\n    renderExpirationTime\n  );\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    !(typeof render === \"function\")\n      ? warningWithoutStack$1(\n          false,\n          \"A context consumer was rendered with multiple children, or a child \" +\n            \"that isn't a function. A context consumer expects a single child \" +\n            \"that is a function. If you did pass a function, make sure there \" +\n            \"is no trailing or leading whitespace around it.\"\n        )\n      : void 0;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  var newValue = readContext(context, newProps.unstable_observedBits);\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase(\"render\");\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current$$1,\n    workInProgress,\n    newChildren,\n    renderExpirationTime\n  );\n  workInProgress.memoizedProps = newProps;\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(\n  current$$1,\n  workInProgress,\n  renderExpirationTime\n) {\n  cancelWorkTimer(workInProgress);\n\n  if (current$$1 !== null) {\n    // Reuse previous context list\n    workInProgress.firstContextDependency = current$$1.firstContextDependency;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  // Check if the children have any pending work.\n  var childExpirationTime = workInProgress.childExpirationTime;\n  if (\n    childExpirationTime === NoWork ||\n    childExpirationTime > renderExpirationTime\n  ) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current$$1, workInProgress);\n    return workInProgress.child;\n  }\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current$$1, workInProgress, renderExpirationTime) {\n  var updateExpirationTime = workInProgress.expirationTime;\n  if (\n    !hasContextChanged() &&\n    (updateExpirationTime === NoWork ||\n      updateExpirationTime > renderExpirationTime)\n  ) {\n    // This fiber does not have any pending work. Bailout without entering\n    // the begin phase. There's still some bookkeeping we that needs to be done\n    // in this optimized path, mostly pushing stuff onto the stack.\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        resetHydrationState();\n        break;\n      case HostComponent:\n        pushHostContext(workInProgress);\n        break;\n      case ClassComponent: {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          pushContextProvider(workInProgress);\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var thenable = workInProgress.type;\n        var _Component = getResultFromResolvedThenable(thenable);\n        if (isContextProvider(_Component)) {\n          pushContextProvider(workInProgress);\n        }\n        break;\n      }\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        break;\n      case ContextProvider: {\n        var newValue = workInProgress.memoizedProps.value;\n        pushProvider(workInProgress, newValue);\n        break;\n      }\n      case Profiler:\n        if (enableProfilerTimer) {\n          workInProgress.effectTag |= Update;\n        }\n        break;\n    }\n    return bailoutOnAlreadyFinishedWork(\n      current$$1,\n      workInProgress,\n      renderExpirationTime\n    );\n  }\n\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      var _Component3 = workInProgress.type;\n      return mountIndeterminateComponent(\n        current$$1,\n        workInProgress,\n        _Component3,\n        renderExpirationTime\n      );\n    }\n    case FunctionalComponent: {\n      var _Component4 = workInProgress.type;\n      var _unresolvedProps = workInProgress.pendingProps;\n      return updateFunctionalComponent(\n        current$$1,\n        workInProgress,\n        _Component4,\n        _unresolvedProps,\n        renderExpirationTime\n      );\n    }\n    case FunctionalComponentLazy: {\n      var _thenable2 = workInProgress.type;\n      var _Component5 = getResultFromResolvedThenable(_thenable2);\n      var _unresolvedProps2 = workInProgress.pendingProps;\n      var _child = updateFunctionalComponent(\n        current$$1,\n        workInProgress,\n        _Component5,\n        resolveDefaultProps(_Component5, _unresolvedProps2),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = _unresolvedProps2;\n      return _child;\n    }\n    case ClassComponent: {\n      var _Component6 = workInProgress.type;\n      var _unresolvedProps3 = workInProgress.pendingProps;\n      return updateClassComponent(\n        current$$1,\n        workInProgress,\n        _Component6,\n        _unresolvedProps3,\n        renderExpirationTime\n      );\n    }\n    case ClassComponentLazy: {\n      var _thenable3 = workInProgress.type;\n      var _Component7 = getResultFromResolvedThenable(_thenable3);\n      var _unresolvedProps4 = workInProgress.pendingProps;\n      var _child2 = updateClassComponent(\n        current$$1,\n        workInProgress,\n        _Component7,\n        resolveDefaultProps(_Component7, _unresolvedProps4),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = _unresolvedProps4;\n      return _child2;\n    }\n    case HostRoot:\n      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostText:\n      return updateHostText(current$$1, workInProgress);\n    case PlaceholderComponent:\n      return updatePlaceholderComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ForwardRef: {\n      var type = workInProgress.type;\n      return updateForwardRef(\n        current$$1,\n        workInProgress,\n        type,\n        workInProgress.pendingProps,\n        renderExpirationTime\n      );\n    }\n    case ForwardRefLazy:\n      var _thenable = workInProgress.type;\n      var _Component2 = getResultFromResolvedThenable(_thenable);\n      var unresolvedProps = workInProgress.pendingProps;\n      var child = updateForwardRef(\n        current$$1,\n        workInProgress,\n        _Component2,\n        resolveDefaultProps(_Component2, unresolvedProps),\n        renderExpirationTime\n      );\n      workInProgress.memoizedProps = unresolvedProps;\n      return child;\n    case Fragment:\n      return updateFragment(current$$1, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current$$1, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current$$1, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current$$1,\n        workInProgress,\n        renderExpirationTime\n      );\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    var updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function(\n    containerChildSet,\n    workInProgress\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance\n    );\n    if (\n      finalizeInitialChildren(\n        newInstance,\n        type,\n        newProps,\n        rootContainerInstance,\n        currentHostContext\n      )\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress);\n    }\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  ) {\n    // Noop\n  };\n  updateHostText$1 = function(current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n      break;\n    case ClassComponent: {\n      var Component = workInProgress.type;\n      if (isContextProvider(Component)) {\n        popContext(workInProgress);\n      }\n      break;\n    }\n    case ClassComponentLazy: {\n      var _Component = getResultFromResolvedThenable(workInProgress.type);\n      if (isContextProvider(_Component)) {\n        popContext(workInProgress);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var fiberRoot = workInProgress.stateNode;\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        popHydrationState(workInProgress);\n        // This resets the hacky state to fix isMounted before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag &= ~Placement;\n      }\n      updateHostContainer(workInProgress);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      var rootContainerInstance = getRootHostContainer();\n      var type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent$1(\n          current,\n          workInProgress,\n          type,\n          newProps,\n          rootContainerInstance\n        );\n\n        if (current.ref !== workInProgress.ref) {\n          markRef$1(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n          break;\n        }\n\n        var currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on we want to add then top->down or\n        // bottom->up. Top->down is faster in IE11.\n        var wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(\n              workInProgress,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            // If changes to the hydrated node needs to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          var instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress\n          );\n\n          appendAllChildren(instance, workInProgress);\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = instance;\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef$1(workInProgress);\n        }\n      }\n      break;\n    }\n    case HostText: {\n      var newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        var oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText$1(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== \"string\") {\n          invariant(\n            workInProgress.stateNode !== null,\n            \"We must have new props for new mounts. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          // This can happen when we abort work.\n        }\n        var _rootContainerInstance = getRootHostContainer();\n        var _currentHostContext = getHostContext();\n        var _wasHydrated = popHydrationState(workInProgress);\n        if (_wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            _rootContainerInstance,\n            _currentHostContext,\n            workInProgress\n          );\n        }\n      }\n      break;\n    }\n    case ForwardRef:\n    case ForwardRefLazy:\n      break;\n    case PlaceholderComponent:\n      break;\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(\n        false,\n        \"An indeterminate component should have become determinate before \" +\n          \"completing. This error is likely caused by a bug in React. Please \" +\n          \"file an issue.\"\n      );\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(\n        false,\n        \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n          \"React. Please file an issue.\"\n      );\n  }\n\n  return null;\n}\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showErrorDialog(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    // Browsers support silencing uncaught errors by calling\n    // `preventDefault()` in window `error` handler.\n    // We record this information as an expando on the error.\n\n    if (error != null && error._suppressLogging) {\n      if (errorBoundaryFound && willRetry) {\n        // The error is recoverable and was silenced.\n        // Ignore it and don't print the stack addendum.\n        // This is handy for testing error boundaries without noise.\n        return;\n      }\n      // The error is fatal. Since the silencing might have\n      // been accidental, we'll surface it anyway.\n      // However, the browser would have silenced the original error\n      // so we'll print it first, and then print the stack addendum.\n      console.error(error);\n      // For a more detailed description of this block, see:\n      // https://github.com/facebook/react/pull/13384\n    }\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar emptyObject$1 = {};\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : \"\",\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function() {\n      throw e;\n    });\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function(current$$1, instance) {\n  startPhaseTimer(current$$1, \"componentWillUnmount\");\n  instance.props = current$$1.memoizedProps;\n  instance.state = current$$1.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current$$1, instance) {\n  {\n    invokeGuardedCallback(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current$$1,\n      instance\n    );\n    if (hasCaughtError()) {\n      var unmountError = clearCaughtError();\n      captureCommitPhaseError(current$$1, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current$$1) {\n  var ref = current$$1.ref;\n  if (ref !== null) {\n    if (typeof ref === \"function\") {\n      {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          var refError = clearCaughtError();\n          captureCommitPhaseError(current$$1, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current$$1, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current$$1 !== null) {\n          var prevProps = current$$1.memoizedProps;\n          var prevState = current$$1.memoizedState;\n          startPhaseTimer(finishedWork, \"getSnapshotBeforeUpdate\");\n          var instance = finishedWork.stateNode;\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n          {\n            var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              warningWithoutStack$1(\n                false,\n                \"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" +\n                  \"must be returned. You have returned undefined.\",\n                getComponentName(finishedWork.type)\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitLifeCycles(\n  finishedRoot,\n  current$$1,\n  finishedWork,\n  committedExpirationTime\n) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      var instance = finishedWork.stateNode;\n      if (finishedWork.effectTag & Update) {\n        if (current$$1 === null) {\n          startPhaseTimer(finishedWork, \"componentDidMount\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          var prevProps = current$$1.memoizedProps;\n          var prevState = current$$1.memoizedState;\n          startPhaseTimer(finishedWork, \"componentDidUpdate\");\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate\n          );\n          stopPhaseTimer();\n        }\n      }\n      var updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        instance.props = finishedWork.memoizedProps;\n        instance.state = finishedWork.memoizedState;\n        commitUpdateQueue(\n          finishedWork,\n          updateQueue,\n          instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostRoot: {\n      var _updateQueue = finishedWork.updateQueue;\n      if (_updateQueue !== null) {\n        var _instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              _instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n            case ClassComponentLazy:\n              _instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(\n          finishedWork,\n          _updateQueue,\n          _instance,\n          committedExpirationTime\n        );\n      }\n      return;\n    }\n    case HostComponent: {\n      var _instance2 = finishedWork.stateNode;\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current$$1 === null && finishedWork.effectTag & Update) {\n        var type = finishedWork.type;\n        var props = finishedWork.memoizedProps;\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        var onRender = finishedWork.memoizedProps.onRender;\n\n        if (enableSchedulerTracking) {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current$$1 === null ? \"mount\" : \"update\",\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime(),\n            finishedRoot.memoizedInteractions\n          );\n        } else {\n          onRender(\n            finishedWork.memoizedProps.id,\n            current$$1 === null ? \"mount\" : \"update\",\n            finishedWork.actualDuration,\n            finishedWork.treeBaseDuration,\n            finishedWork.actualStartTime,\n            getCommitTime()\n          );\n        }\n      }\n      return;\n    }\n    case PlaceholderComponent: {\n      if (enableSuspense) {\n        if ((finishedWork.mode & StrictMode) === NoEffect) {\n          // In loose mode, a placeholder times out by scheduling a synchronous\n          // update in the commit phase. Use `updateQueue` field to signal that\n          // the Timeout needs to switch to the placeholder. We don't need an\n          // entire queue. Any non-null value works.\n          // $FlowFixMe - Intentionally using a value other than an UpdateQueue.\n          finishedWork.updateQueue = emptyObject$1;\n          scheduleWork(finishedWork, Sync);\n        } else {\n          // In strict mode, the Update effect is used to record the time at\n          // which the placeholder timed out.\n          var currentTime = requestCurrentTime();\n          finishedWork.stateNode = { timedOutAt: currentTime };\n        }\n      }\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === \"function\") {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty(\"current\")) {\n          warningWithoutStack$1(\n            false,\n            \"Unexpected ref object provided for %s. \" +\n              \"Use either a ref-setter function or React.createRef().%s\",\n            getComponentName(finishedWork.type),\n            getStackByFiberInDevAndProd(finishedWork)\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current$$1) {\n  var currentRef = current$$1.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === \"function\") {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current$$1) {\n  onCommitUnmount(current$$1);\n\n  switch (current$$1.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      safelyDetachRef(current$$1);\n      var instance = current$$1.stateNode;\n      if (typeof instance.componentWillUnmount === \"function\") {\n        safelyCallComponentWillUnmount(current$$1, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      safelyDetachRef(current$$1);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(current$$1);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current$$1);\n      }\n      return;\n    }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current$$1) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current$$1.return = null;\n  current$$1.child = null;\n  if (current$$1.alternate) {\n    current$$1.alternate.child = null;\n    current$$1.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current$$1) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current$$1.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      return;\n    }\n    case HostComponent: {\n      return;\n    }\n    case HostText: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      var portalOrRoot = finishedWork.stateNode;\n      var containerInfo = portalOrRoot.containerInfo,\n        _pendingChildren = portalOrRoot.pendingChildren;\n\n      replaceContainerChildren(containerInfo, _pendingChildren);\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    \"Expected to find a host parent. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n}\n\nfunction isHostParent(fiber) {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  var parent = void 0;\n  var isContainer = void 0;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(\n        false,\n        \"Invalid host parent fiber. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current$$1) {\n  // We only have the top Fiber that was deleted but we need recurse down its\n  var node = current$$1;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          \"Expected to find a host parent. This error is likely caused by \" +\n            \"a bug in React. Please file an issue.\"\n        );\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      currentParentIsContainer = true;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current$$1) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current$$1) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current$$1) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current$$1);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current$$1);\n  }\n  detachFiber(current$$1);\n}\n\nfunction commitWork(current$$1, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy: {\n      return;\n    }\n    case HostComponent: {\n      var instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        var newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldProps =\n          current$$1 !== null ? current$$1.memoizedProps : newProps;\n        var type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        var updatePayload = finishedWork.updateQueue;\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        \"This should have a text node initialized. This error is likely \" +\n          \"caused by a bug in React. Please file an issue.\"\n      );\n      var textInstance = finishedWork.stateNode;\n      var newText = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case PlaceholderComponent: {\n      return;\n    }\n    default: {\n      invariant(\n        false,\n        \"This unit of work tag should not have side-effects. This error is \" +\n          \"likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n}\n\nfunction commitResetTextContent(current$$1) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current$$1.stateNode);\n}\n\nfunction NoopComponent() {\n  return null;\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function() {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (\n    enableGetDerivedStateFromCatch &&\n    typeof getDerivedStateFromCatch === \"function\"\n  ) {\n    var error = errorInfo.value;\n    update.payload = function() {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n    update.callback = function callback() {\n      if (\n        !enableGetDerivedStateFromCatch ||\n        getDerivedStateFromCatch !== \"function\"\n      ) {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : \"\"\n      });\n    };\n  }\n  return update;\n}\n\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  renderExpirationTime\n) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (\n    enableSuspense &&\n    value !== null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\"\n  ) {\n    // This is a thenable.\n    var thenable = value;\n\n    // Find the earliest timeout threshold of all the placeholders in the\n    // ancestor path. We could avoid this traversal by storing the thresholds on\n    // the stack, but we choose not to because we only hit this path if we're\n    // IO-bound (i.e. if something suspends). Whereas the stack is used even in\n    // the non-IO- bound case.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    var startTimeMs = -1;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var current = _workInProgress.alternate;\n        if (\n          current !== null &&\n          current.memoizedState === true &&\n          current.stateNode !== null\n        ) {\n          // Reached a placeholder that already timed out. Each timed out\n          // placeholder acts as the root of a new suspense boundary.\n\n          // Use the time at which the placeholder timed out as the start time\n          // for the current render.\n          var timedOutAt = current.stateNode.timedOutAt;\n          startTimeMs = expirationTimeToMs(timedOutAt);\n\n          // Do not search any further.\n          break;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.delayMs;\n        if (typeof timeoutPropMs === \"number\") {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n          } else if (\n            earliestTimeoutMs === -1 ||\n            timeoutPropMs < earliestTimeoutMs\n          ) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Schedule the nearest Placeholder to re-render the timed out view.\n    _workInProgress = returnFiber;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var didTimeout = _workInProgress.memoizedState;\n        if (!didTimeout) {\n          // Found the nearest boundary.\n\n          // If the boundary is not in async mode, we should not suspend, and\n          // likewise, when the promise resolves, we should ping synchronously.\n          var pingTime =\n            (_workInProgress.mode & AsyncMode) === NoEffect\n              ? Sync\n              : renderExpirationTime;\n\n          // Attach a listener to the promise to \"ping\" the root and retry.\n          var onResolveOrReject = retrySuspendedRoot.bind(\n            null,\n            root,\n            _workInProgress,\n            pingTime\n          );\n          thenable.then(onResolveOrReject, onResolveOrReject);\n\n          // If the boundary is outside of strict mode, we should *not* suspend\n          // the commit. Pretend as if the suspended component rendered null and\n          // keep rendering. In the commit phase, we'll schedule a subsequent\n          // synchronous update to re-render the Placeholder.\n          //\n          // Note: It doesn't matter whether the component that suspended was\n          // inside a strict mode tree. If the Placeholder is outside of it, we\n          // should *not* suspend the commit.\n          if ((_workInProgress.mode & StrictMode) === NoEffect) {\n            _workInProgress.effectTag |= Update;\n\n            // Unmount the source fiber's children\n            var nextChildren = null;\n            reconcileChildren(\n              sourceFiber.alternate,\n              sourceFiber,\n              nextChildren,\n              renderExpirationTime\n            );\n            sourceFiber.effectTag &= ~Incomplete;\n            if (sourceFiber.tag === IndeterminateComponent) {\n              // Let's just assume it's a functional component. This fiber will\n              // be unmounted in the immediate next commit, anyway.\n              sourceFiber.tag = FunctionalComponent;\n            }\n\n            if (\n              sourceFiber.tag === ClassComponent ||\n              sourceFiber.tag === ClassComponentLazy\n            ) {\n              // We're going to commit this fiber even though it didn't\n              // complete. But we shouldn't call any lifecycle methods or\n              // callbacks. Remove all lifecycle effect tags.\n              sourceFiber.effectTag &= ~LifecycleEffectMask;\n              if (sourceFiber.alternate === null) {\n                // We're about to mount a class component that doesn't have an\n                // instance. Turn this into a dummy functional component instead,\n                // to prevent type errors. This is a bit weird but it's an edge\n                // case and we're about to synchronously delete this\n                // component, anyway.\n                sourceFiber.tag = FunctionalComponent;\n                sourceFiber.type = NoopComponent;\n              }\n            }\n\n            // Exit without suspending.\n            return;\n          }\n\n          // Confirmed that the boundary is in a strict mode tree. Continue with\n          // the normal suspend path.\n\n          var absoluteTimeoutMs = void 0;\n          if (earliestTimeoutMs === -1) {\n            // If no explicit threshold is given, default to an abitrarily large\n            // value. The actual size doesn't matter because the threshold for the\n            // whole tree will be clamped to the expiration time.\n            absoluteTimeoutMs = maxSigned31BitInt;\n          } else {\n            if (startTimeMs === -1) {\n              // This suspend happened outside of any already timed-out\n              // placeholders. We don't know exactly when the update was scheduled,\n              // but we can infer an approximate start time from the expiration\n              // time. First, find the earliest uncommitted expiration time in the\n              // tree, including work that is suspended. Then subtract the offset\n              // used to compute an async update's expiration time. This will cause\n              // high priority (interactive) work to expire earlier than necessary,\n              // but we can account for this by adjusting for the Just Noticeable\n              // Difference.\n              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n                root,\n                renderExpirationTime\n              );\n              var earliestExpirationTimeMs = expirationTimeToMs(\n                earliestExpirationTime\n              );\n              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n            }\n            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n          }\n\n          // Mark the earliest timeout in the suspended fiber's ancestor path.\n          // After completing the root, we'll take the largest of all the\n          // suspended fiber's timeouts and use it to compute a timeout for the\n          // whole tree.\n          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n\n          _workInProgress.effectTag |= ShouldCapture;\n          _workInProgress.expirationTime = renderExpirationTime;\n          return;\n        }\n        // This boundary already captured during this render. Continue to the\n        // next boundary.\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    value = new Error(\n      \"An update was suspended, but no placeholder UI was provided.\"\n    );\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        var _errorInfo = value;\n        workInProgress.effectTag |= ShouldCapture;\n        workInProgress.expirationTime = renderExpirationTime;\n        var update = createRootErrorUpdate(\n          workInProgress,\n          _errorInfo,\n          renderExpirationTime\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n      case ClassComponentLazy:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if (\n          (workInProgress.effectTag & DidCapture) === NoEffect &&\n          ((typeof ctor.getDerivedStateFromCatch === \"function\" &&\n            enableGetDerivedStateFromCatch) ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === \"function\" &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            renderExpirationTime\n          );\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderExpirationTime) {\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      var Component = workInProgress.type;\n      if (isContextProvider(Component)) {\n        popContext(workInProgress);\n      }\n      var effectTag = workInProgress.effectTag;\n      if (effectTag & ShouldCapture) {\n        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case ClassComponentLazy: {\n      var _Component = workInProgress.type._reactResult;\n      if (isContextProvider(_Component)) {\n        popContext(workInProgress);\n      }\n      var _effectTag = workInProgress.effectTag;\n      if (_effectTag & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      popHostContainer(workInProgress);\n      popTopLevelContextObject(workInProgress);\n      var _effectTag2 = workInProgress.effectTag;\n      invariant(\n        (_effectTag2 & DidCapture) === NoEffect,\n        \"The root failed to unmount after an error. This is likely a bug in \" +\n          \"React. Please file an issue.\"\n      );\n      workInProgress.effectTag = (_effectTag2 & ~ShouldCapture) | DidCapture;\n      return workInProgress;\n    }\n    case HostComponent: {\n      popHostContext(workInProgress);\n      return null;\n    }\n    case PlaceholderComponent: {\n      var _effectTag3 = workInProgress.effectTag;\n      if (_effectTag3 & ShouldCapture) {\n        workInProgress.effectTag = (_effectTag3 & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      var childContextTypes = interruptedWork.type.childContextTypes;\n      if (childContextTypes !== null && childContextTypes !== undefined) {\n        popContext(interruptedWork);\n      }\n      break;\n    }\n    case ClassComponentLazy: {\n      var _childContextTypes =\n        interruptedWork.type._reactResult.childContextTypes;\n      if (_childContextTypes !== null && _childContextTypes !== undefined) {\n        popContext(interruptedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      popHostContainer(interruptedWork);\n      popTopLevelContextObject(interruptedWork);\n      break;\n    }\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar Dispatcher = {\n  readContext: readContext\n};\n\nvar ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\nif (enableSchedulerTracking) {\n  // Provide explicit error message when production+profiling bundle of e.g. react-dom\n  // is used with production (non-profiling) bundle of schedule/tracking\n  invariant(\n    tracking.__interactionsRef != null &&\n      tracking.__interactionsRef.current != null,\n    \"It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) \" +\n      \"without also replacing the `schedule/tracking` module with `schedule/tracking-profiling`. \" +\n      \"Your bundler might have a setting for aliasing both modules. \" +\n      \"Learn more at http://fb.me/react-profiling\"\n  );\n}\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function(fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber.type) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warningWithoutStack$1(\n      false,\n      \"Can't call setState (or forceUpdate) on an unmounted component. This \" +\n        \"is a no-op, but it indicates a memory leak in your application. To \" +\n        \"fix, cancel all subscriptions and asynchronous tasks in the \" +\n        \"componentWillUnmount method.%s\",\n      getStackByFiberInDevAndProd(fiber)\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function(instance) {\n    switch (phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warningWithoutStack$1(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warningWithoutStack$1(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render`). Render methods should be a pure function of props and state.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestAbsoluteTimeoutMs = -1;\nvar nextRenderDidError = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\n// Do not decrement interaction counts in the event of suspense timeouts.\n// This would lead to prematurely calling the interaction-complete hook.\nvar suspenseDidTimeout = false;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function(failedUnitOfWork, thrownValue, isYieldy) {\n    if (\n      thrownValue !== null &&\n      typeof thrownValue === \"object\" &&\n      typeof thrownValue.then === \"function\"\n    ) {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warningWithoutStack$1(\n        false,\n        \"Could not replay rendering after an error. This is likely a bug in React. \" +\n          \"Please file an issue.\"\n      );\n      return;\n    }\n    assignFiberPropertiesInDEV(\n      failedUnitOfWork,\n      stashedWorkInProgressProperties\n    );\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent: {\n        var Component = failedUnitOfWork.type;\n        if (isContextProvider(Component)) {\n          popContext(failedUnitOfWork);\n        }\n        break;\n      }\n      case ClassComponentLazy: {\n        var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);\n        if (isContextProvider(_Component)) {\n          popContext(failedUnitOfWork);\n        }\n        break;\n      }\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      var replayError = clearCaughtError();\n      if (replayError != null && thrownValue != null) {\n        try {\n          // Reading the expando property is intentionally\n          // inside `try` because it might be a getter or Proxy.\n          if (replayError._suppressLogging) {\n            // Also suppress logging for the original error.\n            thrownValue._suppressLogging = true;\n          }\n        } catch (inner) {\n          // Ignore.\n        }\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function() {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestAbsoluteTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current$$1 = nextEffect.alternate;\n      if (current$$1 !== null) {\n        commitDetachRef(current$$1);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted\n        // does and isMounted is deprecated anyway so we should be able\n        // to kill this.\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n        // any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // Update\n        var _current = nextEffect.alternate;\n        commitWork(_current, nextEffect);\n        break;\n      }\n      case Update: {\n        var _current2 = nextEffect.alternate;\n        commitWork(_current2, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(nextEffect);\n        break;\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n\n    var effectTag = nextEffect.effectTag;\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current$$1, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitAllLifeCycles(finishedRoot, committedExpirationTime) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitLifeCycles(\n        finishedRoot,\n        current$$1,\n        nextEffect,\n        committedExpirationTime\n      );\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(root, finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  invariant(\n    root.current !== finishedWork,\n    \"Cannot commit the same tree as before. This is probably a bug \" +\n      \"related to the return field. This error is likely caused by a bug \" +\n      \"in React. Please file an issue.\"\n  );\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  invariant(\n    committedExpirationTime !== NoWork,\n    \"Cannot commit an incomplete root. This error is likely caused by a \" +\n      \"bug in React. Please file an issue.\"\n  );\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeBeforeCommit =\n    updateExpirationTimeBeforeCommit === NoWork ||\n    (childExpirationTimeBeforeCommit !== NoWork &&\n      childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit)\n      ? childExpirationTimeBeforeCommit\n      : updateExpirationTimeBeforeCommit;\n  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n\n  var prevInteractions = null;\n  var committedInteractions = enableSchedulerTracking ? [] : null;\n  if (enableSchedulerTracking) {\n    // Restore any pending interactions at this point,\n    // So that cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n\n    // We are potentially finished with the current batch of interactions.\n    // So we should clear them out of the pending interaction map.\n    // We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.\n    // In that event, interaction data may be added back into the pending map for a future commit.\n    // We also store the interactions we are about to commit so that we can notify subscribers after we're done.\n    // These are stored as an Array rather than a Set,\n    // Because the same interaction may be pending for multiple expiration times,\n    // In which case it's important that we decrement the count the right number of times after finishing.\n    root.pendingInteractionMap.forEach(function(\n      scheduledInteractions,\n      scheduledExpirationTime\n    ) {\n      if (scheduledExpirationTime <= committedExpirationTime) {\n        committedInteractions.push.apply(\n          committedInteractions,\n          Array.from(scheduledInteractions)\n        );\n        root.pendingInteractionMap.delete(scheduledExpirationTime);\n      }\n    });\n  }\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner$2.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback(\n        null,\n        commitAllLifeCycles,\n        null,\n        root,\n        committedExpirationTime\n      );\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      invariant(\n        nextEffect !== null,\n        \"Should have next effect. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  onCommitRoot(finishedWork.stateNode);\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeAfterCommit =\n    updateExpirationTimeAfterCommit === NoWork ||\n    (childExpirationTimeAfterCommit !== NoWork &&\n      childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit)\n      ? childExpirationTimeAfterCommit\n      : updateExpirationTimeAfterCommit;\n  if (earliestRemainingTimeAfterCommit === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, earliestRemainingTimeAfterCommit);\n\n  if (enableSchedulerTracking) {\n    tracking.__interactionsRef.current = prevInteractions;\n\n    var subscriber = void 0;\n\n    try {\n      subscriber = tracking.__subscriberRef.current;\n      if (subscriber !== null && root.memoizedInteractions.size > 0) {\n        var threadID = computeThreadID(\n          committedExpirationTime,\n          root.interactionThreadID\n        );\n        subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n      }\n    } catch (error) {\n      // It's not safe for commitRoot() to throw.\n      // Store the error for now and we'll re-throw in finishRendering().\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    } finally {\n      // Don't update interaction counts if we're frozen due to suspense.\n      // In this case, we can skip the completed-work check entirely.\n      if (!suspenseDidTimeout) {\n        // Now that we're done, check the completed batch of interactions.\n        // If no more work is outstanding for a given interaction,\n        // We need to notify the subscribers that it's finished.\n        committedInteractions.forEach(function(interaction) {\n          interaction.__count--;\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // It's not safe for commitRoot() to throw.\n              // Store the error for now and we'll re-throw in finishRendering().\n              if (!hasUnhandledError) {\n                hasUnhandledError = true;\n                unhandledError = error;\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction resetChildExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  var newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    // We're in profiling mode.\n    // Let's use this same traversal to update the render durations.\n    var actualDuration = workInProgress.actualDuration;\n    var treeBaseDuration = workInProgress.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0.\n    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration.\n    // If the fiber has not been cloned though, (meaning no work was done),\n    // Then this value will reflect the amount of time spent working on a previous render.\n    // In that case it should not bubble.\n    // We determine whether it was cloned by comparing the child pointer.\n    var shouldBubbleActualDurations =\n      workInProgress.alternate === null ||\n      workInProgress.child !== workInProgress.alternate.child;\n\n    var child = workInProgress.child;\n    while (child !== null) {\n      var childUpdateExpirationTime = child.expirationTime;\n      var childChildExpirationTime = child.childExpirationTime;\n      if (\n        newChildExpirationTime === NoWork ||\n        (childUpdateExpirationTime !== NoWork &&\n          childUpdateExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (\n        newChildExpirationTime === NoWork ||\n        (childChildExpirationTime !== NoWork &&\n          childChildExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    workInProgress.actualDuration = actualDuration;\n    workInProgress.treeBaseDuration = treeBaseDuration;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      var _childUpdateExpirationTime = _child.expirationTime;\n      var _childChildExpirationTime = _child.childExpirationTime;\n      if (\n        newChildExpirationTime === NoWork ||\n        (_childUpdateExpirationTime !== NoWork &&\n          _childUpdateExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = _childUpdateExpirationTime;\n      }\n      if (\n        newChildExpirationTime === NoWork ||\n        (_childChildExpirationTime !== NoWork &&\n          _childChildExpirationTime < newChildExpirationTime)\n      ) {\n        newChildExpirationTime = _childChildExpirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.childExpirationTime = newChildExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current$$1 = workInProgress.alternate;\n    {\n      setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n\n        nextUnitOfWork = completeWork(\n          current$$1,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n\n        if (workInProgress.mode & ProfileMode) {\n          // Update render duration assuming we didn't error.\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n        }\n      } else {\n        nextUnitOfWork = completeWork(\n          current$$1,\n          workInProgress,\n          nextRenderExpirationTime\n        );\n      }\n      var next = nextUnitOfWork;\n      stopWorkTimer(workInProgress);\n      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      if (workInProgress.mode & ProfileMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (enableProfilerTimer) {\n          // Include the time spent working on failed children before continuing.\n          if (_next.mode & ProfileMode) {\n            var actualDuration = _next.actualDuration;\n            var child = _next.child;\n            while (child !== null) {\n              actualDuration += child.actualDuration;\n              child = child.sibling;\n            }\n            _next.actualDuration = actualDuration;\n          }\n        }\n\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current$$1 = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(\n      stashedWorkInProgressProperties,\n      workInProgress\n    );\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startProfilerTimer(workInProgress);\n    }\n\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Record the render duration assuming we didn't bailout (or error).\n      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n    }\n  } else {\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner$2.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\nfunction renderRoot(root, isYieldy, isExpired) {\n  invariant(\n    !isWorking,\n    \"renderRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n  isWorking = true;\n  ReactCurrentOwner$2.currentDispatcher = Dispatcher;\n\n  var expirationTime = root.nextExpirationTimeToWorkOn;\n\n  var prevInteractions = null;\n  if (enableSchedulerTracking) {\n    // We're about to start new tracked work.\n    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracking.__interactionsRef.current;\n    tracking.__interactionsRef.current = root.memoizedInteractions;\n  }\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (\n    expirationTime !== nextRenderExpirationTime ||\n    root !== nextRoot ||\n    nextUnitOfWork === null\n  ) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextUnitOfWork = createWorkInProgress(\n      nextRoot.current,\n      null,\n      nextRenderExpirationTime\n    );\n    root.pendingCommitExpirationTime = NoWork;\n\n    if (enableSchedulerTracking) {\n      // Determine which interactions this batch of work currently includes,\n      // So that we can accurately attribute time spent working on it,\n      var interactions = new Set();\n      root.pendingInteractionMap.forEach(function(\n        scheduledInteractions,\n        scheduledExpirationTime\n      ) {\n        if (scheduledExpirationTime <= expirationTime) {\n          scheduledInteractions.forEach(function(interaction) {\n            return interactions.add(interaction);\n          });\n        }\n      });\n\n      // Store the current set of interactions on the FiberRoot for a few reasons:\n      // We can re-use it in hot functions like renderRoot() without having to recalculate it.\n      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.\n      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.\n      root.memoizedInteractions = interactions;\n\n      if (interactions.size > 0) {\n        var subscriber = tracking.__subscriberRef.current;\n        if (subscriber !== null) {\n          var threadID = computeThreadID(\n            expirationTime,\n            root.interactionThreadID\n          );\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            // Work thrown by an interaction tracking subscriber should be rethrown,\n            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).\n            // Store the error for now and we'll re-throw in finishRendering().\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        invariant(\n          nextUnitOfWork !== null,\n          \"Failed to replay rendering after an error. This \" +\n            \"is likely caused by a bug in React. Please file an issue \" +\n            \"with a reproducing case to help us find it.\"\n        );\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n        } else {\n          throwException(\n            root,\n            returnFiber,\n            sourceFiber,\n            thrownValue,\n            nextRenderExpirationTime\n          );\n          nextUnitOfWork = completeUnitOfWork(sourceFiber);\n          continue;\n        }\n      }\n    }\n    break;\n  } while (true);\n\n  if (enableSchedulerTracking) {\n    // Tracked work is done for now; restore the previous interactions.\n    tracking.__interactionsRef.current = prevInteractions;\n  }\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n  ReactCurrentOwner$2.currentDispatcher = null;\n  resetContextDependences();\n\n  // Yield back to main thread.\n  if (didFatal) {\n    var _didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    // `nextRoot` points to the in-progress root. A non-null value indicates\n    // that we're in the middle of an async render. Set it to null to indicate\n    // there's no more work to be done in the current batch.\n    nextRoot = null;\n    onFatal(root);\n    return;\n  }\n\n  if (nextUnitOfWork !== null) {\n    // There's still remaining async work in this tree, but we ran out of time\n    // in the current frame. Yield back to the renderer. Unless we're\n    // interrupted by a higher priority update, we'll continue later from where\n    // we left off.\n    var _didCompleteRoot2 = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n    interruptedBy = null;\n    onYield(root);\n    return;\n  }\n\n  // We completed the whole tree.\n  var didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  var rootWorkInProgress = root.current.alternate;\n  invariant(\n    rootWorkInProgress !== null,\n    \"Finished root should have a work-in-progress. This error is likely \" +\n      \"caused by a bug in React. Please file an issue.\"\n  );\n\n  // `nextRoot` points to the in-progress root. A non-null value indicates\n  // that we're in the middle of an async render. Set it to null to indicate\n  // there's no more work to be done in the current batch.\n  nextRoot = null;\n  interruptedBy = null;\n\n  if (nextRenderDidError) {\n    // There was an error\n    if (hasLowerPriorityWork(root, expirationTime)) {\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown. Exit without committing. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve. React will restart at the lower\n      // priority level.\n      markSuspendedPriorityLevel(root, expirationTime);\n      var suspendedExpirationTime = expirationTime;\n      var rootExpirationTime = root.expirationTime;\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        suspendedExpirationTime,\n        rootExpirationTime,\n        -1 // Indicates no timeout\n      );\n      return;\n    } else if (\n      // There's no lower priority work, but we're rendering asynchronously.\n      // Synchronsouly attempt to render the same level one more time. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve.\n      !root.didError &&\n      !isExpired\n    ) {\n      root.didError = true;\n      var _suspendedExpirationTime = (root.nextExpirationTimeToWorkOn = expirationTime);\n      var _rootExpirationTime = (root.expirationTime = Sync);\n      onSuspend(\n        root,\n        rootWorkInProgress,\n        _suspendedExpirationTime,\n        _rootExpirationTime,\n        -1 // Indicates no timeout\n      );\n      return;\n    }\n  }\n\n  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {\n    // The tree was suspended.\n    var _suspendedExpirationTime2 = expirationTime;\n    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);\n\n    // Find the earliest uncommitted expiration time in the tree, including\n    // work that is suspended. The timeout threshold cannot be longer than\n    // the overall expiration.\n    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(\n      root,\n      expirationTime\n    );\n    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n    }\n\n    // Subtract the current time from the absolute timeout to get the number\n    // of milliseconds until the timeout. In other words, convert an absolute\n    // timestamp to a relative time. This is the value that is passed\n    // to `setTimeout`.\n    var currentTimeMs = expirationTimeToMs(requestCurrentTime());\n    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n\n    // TODO: Account for the Just Noticeable Difference\n\n    var _rootExpirationTime2 = root.expirationTime;\n    onSuspend(\n      root,\n      rootWorkInProgress,\n      _suspendedExpirationTime2,\n      _rootExpirationTime2,\n      msUntilTimeout\n    );\n    return;\n  }\n\n  // Ready to commit.\n  onComplete(root, rootWorkInProgress, expirationTime);\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  invariant(\n    !isWorking || isCommitting$1,\n    \"dispatch: Cannot dispatch during the render phase.\"\n  );\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n      case ClassComponentLazy:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (\n          typeof ctor.getDerivedStateFromCatch === \"function\" ||\n          (typeof instance.componentDidCatch === \"function\" &&\n            !isAlreadyFailedLegacyErrorBoundary(instance))\n        ) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot: {\n        var _errorInfo = createCapturedValue(value, sourceFiber);\n        var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n        enqueueUpdate(fiber, _update);\n        scheduleWork(fiber, expirationTime);\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(\n      rootFiber,\n      _errorInfo2,\n      expirationTime\n    );\n    enqueueUpdate(rootFiber, _update2);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeThreadID(expirationTime, interactionThreadID) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + interactionThreadID;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // If we're in the middle of rendering a tree, do not update at the same\n      // expiration time that is already rendering.\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime += 1;\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (\n      lowestPriorityPendingInteractiveExpirationTime === NoWork ||\n      expirationTime > lowestPriorityPendingInteractiveExpirationTime\n    ) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (\n    absoluteTimeoutMs >= 0 &&\n    nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs\n  ) {\n    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n  }\n}\n\nfunction renderDidError() {\n  nextRenderDidError = true;\n}\n\nfunction retrySuspendedRoot(root, fiber, suspendedTime) {\n  if (enableSuspense) {\n    var retryTime = void 0;\n\n    if (isPriorityLevelSuspended(root, suspendedTime)) {\n      // Ping at the original level\n      retryTime = suspendedTime;\n      markPingedPriorityLevel(root, retryTime);\n    } else {\n      // Placeholder already timed out. Compute a new expiration time\n      var currentTime = requestCurrentTime();\n      retryTime = computeExpirationForFiber(currentTime, fiber);\n      markPendingPriorityLevel(root, retryTime);\n    }\n\n    scheduleWorkToRoot(fiber, retryTime);\n    var rootExpirationTime = root.expirationTime;\n    if (rootExpirationTime !== NoWork) {\n      if (enableSchedulerTracking) {\n        // Restore previous interactions so that new work is associated with them.\n        var prevInteractions = tracking.__interactionsRef.current;\n        tracking.__interactionsRef.current = root.memoizedInteractions;\n        // Because suspense timeouts do not decrement the interaction count,\n        // Continued suspense work should also not increment the count.\n        storeInteractionsForExpirationTime(root, rootExpirationTime, false);\n        requestWork(root, rootExpirationTime);\n        tracking.__interactionsRef.current = prevInteractions;\n      } else {\n        requestWork(root, rootExpirationTime);\n      }\n    }\n  }\n}\n\nfunction scheduleWorkToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (\n    fiber.expirationTime === NoWork ||\n    fiber.expirationTime > expirationTime\n  ) {\n    fiber.expirationTime = expirationTime;\n  }\n  var alternate = fiber.alternate;\n  if (\n    alternate !== null &&\n    (alternate.expirationTime === NoWork ||\n      alternate.expirationTime > expirationTime)\n  ) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  var node = fiber.return;\n  if (node === null && fiber.tag === HostRoot) {\n    return fiber.stateNode;\n  }\n  while (node !== null) {\n    alternate = node.alternate;\n    if (\n      node.childExpirationTime === NoWork ||\n      node.childExpirationTime > expirationTime\n    ) {\n      node.childExpirationTime = expirationTime;\n      if (\n        alternate !== null &&\n        (alternate.childExpirationTime === NoWork ||\n          alternate.childExpirationTime > expirationTime)\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n    } else if (\n      alternate !== null &&\n      (alternate.childExpirationTime === NoWork ||\n        alternate.childExpirationTime > expirationTime)\n    ) {\n      alternate.childExpirationTime = expirationTime;\n    }\n    if (node.return === null && node.tag === HostRoot) {\n      return node.stateNode;\n    }\n    node = node.return;\n  }\n  return null;\n}\n\nfunction storeInteractionsForExpirationTime(\n  root,\n  expirationTime,\n  updateInteractionCounts\n) {\n  if (!enableSchedulerTracking) {\n    return;\n  }\n\n  var interactions = tracking.__interactionsRef.current;\n  if (interactions.size > 0) {\n    var pendingInteractions = root.pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(function(interaction) {\n        if (updateInteractionCounts && !pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      root.pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      if (updateInteractionCounts) {\n        interactions.forEach(function(interaction) {\n          interaction.__count++;\n        });\n      }\n    }\n\n    var subscriber = tracking.__subscriberRef.current;\n    if (subscriber !== null) {\n      var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction scheduleWork(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    if (\n      true &&\n      (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)\n    ) {\n      warnAboutUpdateOnUnmounted(fiber);\n    }\n    return;\n  }\n\n  if (enableSchedulerTracking) {\n    storeInteractionsForExpirationTime(root, expirationTime, true);\n  }\n\n  if (\n    !isWorking &&\n    nextRenderExpirationTime !== NoWork &&\n    expirationTime < nextRenderExpirationTime\n  ) {\n    // This is an interruption. (Used for performance tracking.)\n    interruptedBy = fiber;\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n    // If we're in the render phase, we don't need to schedule this root\n    // for an update, because we'll do it before we exit...\n    !isWorking ||\n    isCommitting$1 ||\n    // ...unless this is a different root than the one we're rendering.\n    nextRoot !== root\n  ) {\n    var rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n    invariant(\n      false,\n      \"Maximum update depth exceeded. This can happen when a \" +\n        \"component repeatedly calls setState inside \" +\n        \"componentWillUpdate or componentDidUpdate. React limits \" +\n        \"the number of nested updates to prevent infinite loops.\"\n    );\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPriorityPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\nvar originalStartTimeMs = now();\nvar currentRendererTime = msToExpirationTime(originalStartTimeMs);\nvar currentSchedulerTime = currentRendererTime;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar lastCommittedRootDuringThisBatch = null;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction recomputeCurrentRendererTime() {\n  var currentTimeMs = now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n\nfunction scheduleCallbackWithExpirationTime(root, expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  var currentMs = now() - originalStartTimeMs;\n  var expirationTimeMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationTimeMs - currentMs;\n  callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(root, finishedWork, expirationTime) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(\n  root,\n  finishedWork,\n  suspendedExpirationTime,\n  rootExpirationTime,\n  msUntilTimeout\n) {\n  root.expirationTime = rootExpirationTime;\n  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {\n    // Don't wait an additional tick. Commit the tree immediately.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n  } else if (msUntilTimeout > 0) {\n    // Wait `msUntilTimeout` milliseconds before committing.\n    root.timeoutHandle = scheduleTimeout(\n      onTimeout.bind(null, root, finishedWork, suspendedExpirationTime),\n      msUntilTimeout\n    );\n  }\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onTimeout(root, finishedWork, suspendedExpirationTime) {\n  if (enableSuspense) {\n    // The root timed out. Commit it.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n    // Read the current time before entering the commit phase. We can be\n    // certain this won't cause tearing related to batching of event updates\n    // because we're at the top of a timer event.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableSchedulerTracking) {\n      // Don't update pending interaction counts for suspense timeouts,\n      // Because we know we still need to do more work in this case.\n      suspenseDidTimeout = true;\n      flushRoot(root, suspendedExpirationTime);\n      suspenseDidTimeout = false;\n    } else {\n      flushRoot(root, suspendedExpirationTime);\n    }\n  }\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\nfunction requestCurrentTime() {\n  // requestCurrentTime is called by the scheduler to compute an expiration\n  // time.\n  //\n  // Expiration times are computed by adding to the current time (the start\n  // time). However, if two updates are scheduled within the same event, we\n  // should treat their start times as simultaneous, even if the actual clock\n  // time has advanced between the first and second call.\n\n  // In other words, because expiration times determine how updates are batched,\n  // we want all updates of like priority that occur within the same event to\n  // receive the same expiration time. Otherwise we get tearing.\n  //\n  // We keep track of two separate times: the current \"renderer\" time and the\n  // current \"scheduler\" time. The renderer time can be updated whenever; it\n  // only exists to minimize the calls performance.now.\n  //\n  // But the scheduler time can only be updated if there's no pending work, or\n  // if we know for certain that we're not in the middle of an event.\n\n  if (isRendering) {\n    // We're already rendering. Return the most recently read time.\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (\n    nextFlushedExpirationTime === NoWork ||\n    nextFlushedExpirationTime === Never\n  ) {\n    // If there's no pending work, or if the pending work is offscreen, we can\n    // read the current time without risk of tearing.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // There's already pending work. We might be in the middle of a browser\n  // event. If we were to read the current time, it could cause multiple updates\n  // within the same event to receive different expiration times, leading to\n  // tearing. Return the last read time. During the next idle callback, the\n  // time will be updated.\n  return currentSchedulerTime;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, true);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.expirationTime;\n    if (\n      remainingExpirationTime === NoWork ||\n      expirationTime < remainingExpirationTime\n    ) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        invariant(\n          previousScheduledRoot !== null && lastScheduledRoot !== null,\n          \"Should have a previous and last root. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (\n          highestPriorityWork === NoWork ||\n          remainingExpirationTime < highestPriorityWork\n        ) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        if (highestPriorityWork === Sync) {\n          // Sync is highest priority by definition so\n          // we can stop searching.\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  if (dl.didTimeout) {\n    // The callback timed out. That means at least one update has expired.\n    // Iterate through the root schedule. If they contain expired work, set\n    // the next render expiration time to the current time. This has the effect\n    // of flushing all expired work in a single batch, instead of flushing each\n    // level one at a time.\n    if (firstScheduledRoot !== null) {\n      recomputeCurrentRendererTime();\n      var root = firstScheduledRoot;\n      do {\n        didExpireAtExpirationTime(root, currentRendererTime);\n        // The root schedule is circular, so this is never null.\n        root = root.nextScheduledRoot;\n      } while (root !== firstScheduledRoot);\n    }\n  }\n  performWork(NoWork, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, null);\n}\n\nfunction performWork(minExpirationTime, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (deadline !== null) {\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableUserTimingAPI) {\n      var didExpire = nextFlushedExpirationTime < currentRendererTime;\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime) &&\n      (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(\n        nextFlushedRoot,\n        nextFlushedExpirationTime,\n        currentRendererTime >= nextFlushedExpirationTime\n      );\n      findHighestPriorityRoot();\n      recomputeCurrentRendererTime();\n      currentSchedulerTime = currentRendererTime;\n    }\n  } else {\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        minExpirationTime >= nextFlushedExpirationTime)\n    ) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(\n      nextFlushedRoot,\n      nextFlushedExpirationTime\n    );\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  invariant(\n    !isRendering,\n    \"work.commit(): Cannot commit while already rendering. This likely \" +\n      \"means you attempted to commit from inside a lifecycle method.\"\n  );\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, true);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n  lastCommittedRootDuringThisBatch = null;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isExpired) {\n  invariant(\n    !isRendering,\n    \"performWorkOnRoot was called recursively. This error is likely caused \" +\n      \"by a bug in React. Please file an issue.\"\n  );\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (deadline === null || isExpired) {\n    // Flush work without yielding.\n    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer\n    // may want to perform some work without yielding, but also without\n    // requiring the root to complete (by triggering placeholders).\n\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      var isYieldy = false;\n      renderRoot(root, isYieldy, isExpired);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var _timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && _timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(_timeoutHandle);\n      }\n      var _isYieldy = true;\n      renderRoot(root, _isYieldy, isExpired);\n      _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n\n  // Check if this is a nested update (a sync update scheduled during the\n  // commit phase).\n  if (root === lastCommittedRootDuringThisBatch) {\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    lastCommittedRootDuringThisBatch = root;\n    nestedUpdateCount = 0;\n  }\n  commitRoot(root, finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadlineDidExpire) {\n    return true;\n  }\n  if (\n    deadline === null ||\n    deadline.timeRemaining() > timeHeuristicForUnitOfWork\n  ) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  invariant(\n    nextFlushedRoot !== null,\n    \"Should be working on a root. This error is likely caused by a bug in \" +\n      \"React. Please file an issue.\"\n  );\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (\n    !isBatchingUpdates &&\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (\n    !isRendering &&\n    lowestPriorityPendingInteractiveExpirationTime !== NoWork\n  ) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get$1(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  } else if (fiber.tag === ClassComponentLazy) {\n    var _Component = getResultFromResolvedThenable(fiber.type);\n    if (isContextProvider(_Component)) {\n      return processChildContext(fiber, _Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction scheduleRootUpdate(current$$1, element, expirationTime, callback) {\n  {\n    if (phase === \"render\" && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack$1(\n        false,\n        \"Render methods should be a pure function of props and state; \" +\n          \"triggering nested component updates from render is not allowed. \" +\n          \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n          \"Check the render method of %s.\",\n        getComponentName(current.type) || \"Unknown\"\n      );\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === \"function\")\n      ? warningWithoutStack$1(\n          false,\n          \"render(...): Expected the last optional `callback` argument to be a \" +\n            \"function. Instead received: %s.\",\n          callback\n        )\n      : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current$$1, update);\n\n  scheduleWork(current$$1, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(\n  element,\n  container,\n  parentComponent,\n  expirationTime,\n  callback\n) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current$$1 = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current$$1.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current$$1, element, expirationTime, callback);\n}\n\nfunction findHostInstance$1(component) {\n  var fiber = get$1(component);\n  if (fiber === undefined) {\n    if (typeof component.render === \"function\") {\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    } else {\n      invariant(\n        false,\n        \"Argument appears to not be a ReactComponent. Keys: %s\",\n        Object.keys(component)\n      );\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current$$1 = container.current;\n  var currentTime = requestCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current$$1);\n  return updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback\n  );\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(\n    Object.assign({}, devToolsConfig, {\n      findHostInstanceByFiber: function(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n        if (hostFiber === null) {\n          return null;\n        }\n        return hostFiber.stateNode;\n      },\n      findFiberByHostInstance: function(instance) {\n        if (!findFiberByHostInstance) {\n          // Might not be implemented by the renderer.\n          return null;\n        }\n        return findFiberByHostInstance(instance);\n      }\n    })\n  );\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.5.0\";\n\n// Modules provided by RN:\nvar NativeMethodsMixin = function(findNodeHandle, findHostInstance) {\n  /**\n   * `NativeMethodsMixin` provides methods to access the underlying native\n   * component directly. This can be useful in cases when you want to focus\n   * a view or measure its on-screen dimensions, for example.\n   *\n   * The methods described here are available on most of the default components\n   * provided by React Native. Note, however, that they are *not* available on\n   * composite components that aren't directly backed by a native view. This will\n   * generally include most components that you define in your own app. For more\n   * information, see [Direct\n   * Manipulation](docs/direct-manipulation.html).\n   *\n   * Note the Flow $Exact<> syntax is required to support mixins.\n   * React createClass mixins can only be used with exact types.\n   */\n  var NativeMethodsMixin = {\n    /**\n     * Determines the location on screen, width, and height of the given view and\n     * returns the values via an async callback. If successful, the callback will\n     * be called with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native. If you need the measurements as soon as\n     * possible, consider using the [`onLayout`\n     * prop](docs/view.html#onlayout) instead.\n     */\n    measure: function(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    },\n\n    /**\n     * Determines the location of the given view in the window and returns the\n     * values via an async callback. If the React root view is embedded in\n     * another native view, this will give you the absolute coordinates. If\n     * successful, the callback will be called with the following\n     * arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * Note that these measurements are not available until after the rendering\n     * has been completed in native.\n     */\n    measureInWindow: function(callback) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    },\n\n    /**\n     * Like [`measure()`](#measure), but measures the view relative an ancestor,\n     * specified as `relativeToNativeNode`. This means that the returned x, y\n     * are relative to the origin x, y of the ancestor view.\n     *\n     * As always, to obtain a native node handle for a component, you can use\n     * `findNodeHandle(component)`.\n     */\n    measureLayout: function(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n      );\n    },\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n    setNativeProps: function(nativeProps) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig = maybeInstance.viewConfig;\n\n      {\n        warnForStyleProps(nativeProps, viewConfig.validAttributes);\n      }\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    },\n\n    /**\n     * Requests focus for the given input or view. The exact behavior triggered\n     * will depend on the platform and type of view.\n     */\n    focus: function() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    },\n\n    /**\n     * Removes focus from an input or view. This is the opposite of `focus()`.\n     */\n    blur: function() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    }\n  };\n\n  {\n    // hide this from Flow since we can't define these properties outside of\n    // true without actually implementing them (setting them to undefined\n    // isn't allowed by ReactClass)\n    var NativeMethodsMixin_DEV = NativeMethodsMixin;\n    invariant(\n      !NativeMethodsMixin_DEV.componentWillMount &&\n        !NativeMethodsMixin_DEV.componentWillReceiveProps &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillMount &&\n        !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps,\n      \"Do not override existing functions.\"\n    );\n    // TODO (bvaughn) Remove cWM and cWRP in a future version of React Native,\n    // Once these lifecycles have been remove from the reconciler.\n    NativeMethodsMixin_DEV.componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n      throwOnStylesProp(this, newProps);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function() {\n      throwOnStylesProp(this, this.props);\n    };\n    NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function(\n      newProps\n    ) {\n      throwOnStylesProp(this, newProps);\n    };\n\n    // React may warn about cWM/cWRP/cWU methods being deprecated.\n    // Add a flag to suppress these warnings for this special case.\n    // TODO (bvaughn) Remove this flag once the above methods have been removed.\n    NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;\n    NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;\n  }\n\n  return NativeMethodsMixin;\n};\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\nvar ReactNativeComponent = function(findNodeHandle, findHostInstance) {\n  /**\n   * Superclass that provides methods to access the underlying native component.\n   * This can be useful when you want to focus a view or measure its dimensions.\n   *\n   * Methods implemented by this class are available on most default components\n   * provided by React Native. However, they are *not* available on composite\n   * components that are not directly backed by a native view. For more\n   * information, see [Direct Manipulation](docs/direct-manipulation.html).\n   *\n   * @abstract\n   */\n  var ReactNativeComponent = (function(_React$Component) {\n    _inherits(ReactNativeComponent, _React$Component);\n\n    function ReactNativeComponent() {\n      _classCallCheck$1(this, ReactNativeComponent);\n\n      return _possibleConstructorReturn(\n        this,\n        _React$Component.apply(this, arguments)\n      );\n    }\n\n    /**\n     * Removes focus. This is the opposite of `focus()`.\n     */\n\n    /**\n     * Due to bugs in Flow's handling of React.createClass, some fields already\n     * declared in the base class need to be redeclared below.\n     */\n    ReactNativeComponent.prototype.blur = function blur() {\n      TextInputState.blurTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Requests focus. The exact behavior depends on the platform and view.\n     */\n\n    ReactNativeComponent.prototype.focus = function focus() {\n      TextInputState.focusTextInput(findNodeHandle(this));\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. If successful, the callback\n     * will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *  - pageX\n     *  - pageY\n     *\n     * These values are not available until after natives rendering completes. If\n     * you need the measurements as soon as possible, consider using the\n     * [`onLayout` prop](docs/view.html#onlayout) instead.\n     */\n\n    ReactNativeComponent.prototype.measure = function measure(callback) {\n      UIManager.measure(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    };\n\n    /**\n     * Measures the on-screen location and dimensions. Even if the React Native\n     * root view is embedded within another native view, this method will give you\n     * the absolute coordinates measured from the window. If successful, the\n     * callback will be called asynchronously with the following arguments:\n     *\n     *  - x\n     *  - y\n     *  - width\n     *  - height\n     *\n     * These values are not available until after natives rendering completes.\n     */\n\n    ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n      callback\n    ) {\n      UIManager.measureInWindow(\n        findNodeHandle(this),\n        mountSafeCallback_NOT_REALLY_SAFE(this, callback)\n      );\n    };\n\n    /**\n     * Similar to [`measure()`](#measure), but the resulting location will be\n     * relative to the supplied ancestor's location.\n     *\n     * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n     */\n\n    ReactNativeComponent.prototype.measureLayout = function measureLayout(\n      relativeToNativeNode,\n      onSuccess,\n      onFail /* currently unused */\n    ) {\n      UIManager.measureLayout(\n        findNodeHandle(this),\n        relativeToNativeNode,\n        mountSafeCallback_NOT_REALLY_SAFE(this, onFail),\n        mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess)\n      );\n    };\n\n    /**\n     * This function sends props straight to native. They will not participate in\n     * future diff process - this means that if you do not include them in the\n     * next render, they will remain active (see [Direct\n     * Manipulation](docs/direct-manipulation.html)).\n     */\n\n    ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n      nativeProps\n    ) {\n      // Class components don't have viewConfig -> validateAttributes.\n      // Nor does it make sense to set native props on a non-native component.\n      // Instead, find the nearest host component and set props on it.\n      // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n      // We want the instance/wrapper (not the native tag).\n      var maybeInstance = void 0;\n\n      // Fiber errors if findNodeHandle is called for an umounted component.\n      // Tests using ReactTestRenderer will trigger this case indirectly.\n      // Mimicking stack behavior, we should silently ignore this case.\n      // TODO Fix ReactTestRenderer so we can remove this try/catch.\n      try {\n        maybeInstance = findHostInstance(this);\n      } catch (error) {}\n\n      // If there is no host component beneath this we should fail silently.\n      // This is not an error; it could mean a class component rendered null.\n      if (maybeInstance == null) {\n        return;\n      }\n\n      var viewConfig =\n        maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;\n\n      var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          maybeInstance._nativeTag,\n          viewConfig.uiViewClassName,\n          updatePayload\n        );\n      }\n    };\n\n    return ReactNativeComponent;\n  })(React.Component);\n\n  // eslint-disable-next-line no-unused-expressions\n\n  return ReactNativeComponent;\n};\n\n// Module provided by RN:\nvar emptyObject$2 = {};\n{\n  Object.freeze(emptyObject$2);\n}\n\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject$2;\n    }\n    return emptyObject$2;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber.type),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject$2,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\n// Module provided by RN:\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar findHostInstance = findHostInstance$1;\n\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      !owner.stateNode._warnedAboutRefsInRender\n        ? warningWithoutStack$1(\n            false,\n            \"%s is accessing findNodeHandle inside its render(). \" +\n              \"render() should be a pure function of props and state. It should \" +\n              \"never access something that requires stale data from the previous \" +\n              \"render, such as refs. Move this logic to componentDidMount and \" +\n              \"componentDidUpdate instead.\",\n            getComponentName(owner.type) || \"A component\"\n          )\n        : void 0;\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n  if (componentOrHandle._nativeTag) {\n    return componentOrHandle._nativeTag;\n  }\n  if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {\n    return componentOrHandle.canonical._nativeTag;\n  }\n  var hostInstance = findHostInstance(componentOrHandle);\n  if (hostInstance == null) {\n    return hostInstance;\n  }\n  if (hostInstance.canonical) {\n    // Fabric\n    return hostInstance.canonical._nativeTag;\n  }\n  return hostInstance._nativeTag;\n}\n\nsetBatchingImplementation(\n  batchedUpdates$1,\n  interactiveUpdates$1,\n  flushInteractiveUpdates$1\n);\n\nfunction computeComponentStackForErrorReporting(reactTag) {\n  var fiber = getInstanceFromTag(reactTag);\n  if (!fiber) {\n    return \"\";\n  }\n  return getStackByFiberInDevAndProd(fiber);\n}\n\nvar roots = new Map();\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),\n\n  findNodeHandle: findNodeHandle,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = createContainer(containerTag, false, false);\n      roots.set(containerTag, root);\n    }\n    updateContainer(element, root, null, callback);\n\n    return getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      updateContainer(null, root, null, function() {\n        roots.delete(containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),\n    computeComponentStackForErrorReporting: computeComponentStackForErrorReporting\n  }\n};\n\ninjectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer =\n  ReactNativeRenderer$3.default || ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}