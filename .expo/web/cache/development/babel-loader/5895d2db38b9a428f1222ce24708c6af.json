{"ast":null,"code":"'use strict';\n\nvar EventTarget = require('event-target-shim');\n\nvar RCTNetworking = require(\"./RCTNetworking\");\n\nvar base64 = require('base64-js');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar warning = require('fbjs/lib/warning');\n\nvar BlobManager = require(\"../Blob/BlobManager\");\n\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\n\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\nvar SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true\n};\nvar REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];\nvar XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\n\nclass XMLHttpRequestEventTarget extends EventTarget(...REQUEST_EVENTS) {}\n\nclass XMLHttpRequest extends EventTarget(...XHR_EVENTS) {\n  static setInterceptor(interceptor) {\n    XMLHttpRequest._interceptor = interceptor;\n  }\n\n  constructor() {\n    super();\n    this.UNSENT = UNSENT;\n    this.OPENED = OPENED;\n    this.HEADERS_RECEIVED = HEADERS_RECEIVED;\n    this.LOADING = LOADING;\n    this.DONE = DONE;\n    this.readyState = UNSENT;\n    this.status = 0;\n    this.timeout = 0;\n    this.withCredentials = true;\n    this.upload = new XMLHttpRequestEventTarget();\n    this._aborted = false;\n    this._hasError = false;\n    this._method = null;\n    this._response = '';\n    this._url = null;\n    this._timedOut = false;\n    this._trackingName = 'unknown';\n    this._incrementalEvents = false;\n\n    this._reset();\n  }\n\n  _reset() {\n    this.readyState = this.UNSENT;\n    this.responseHeaders = undefined;\n    this.status = 0;\n    delete this.responseURL;\n    this._requestId = null;\n    this._cachedResponse = undefined;\n    this._hasError = false;\n    this._headers = {};\n    this._response = '';\n    this._responseType = '';\n    this._sent = false;\n    this._lowerCaseResponseHeaders = {};\n\n    this._clearSubscriptions();\n\n    this._timedOut = false;\n  }\n\n  get responseType() {\n    return this._responseType;\n  }\n\n  set responseType(responseType) {\n    if (this._sent) {\n      throw new Error(\"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" + 'response type cannot be set after the request has been sent.');\n    }\n\n    if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n      warning(false, \"The provided value '\".concat(responseType, \"' is not a valid 'responseType'.\"));\n      return;\n    }\n\n    invariant(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', \"The provided value '\".concat(responseType, \"' is unsupported in this environment.\"));\n\n    if (responseType === 'blob') {\n      invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');\n    }\n\n    this._responseType = responseType;\n  }\n\n  get responseText() {\n    if (this._responseType !== '' && this._responseType !== 'text') {\n      throw new Error(\"The 'responseText' property is only available if 'responseType' \" + \"is set to '' or 'text', but it is '\".concat(this._responseType, \"'.\"));\n    }\n\n    if (this.readyState < LOADING) {\n      return '';\n    }\n\n    return this._response;\n  }\n\n  get response() {\n    var {\n      responseType\n    } = this;\n\n    if (responseType === '' || responseType === 'text') {\n      return this.readyState < LOADING || this._hasError ? '' : this._response;\n    }\n\n    if (this.readyState !== DONE) {\n      return null;\n    }\n\n    if (this._cachedResponse !== undefined) {\n      return this._cachedResponse;\n    }\n\n    switch (responseType) {\n      case 'document':\n        this._cachedResponse = null;\n        break;\n\n      case 'arraybuffer':\n        this._cachedResponse = base64.toByteArray(this._response).buffer;\n        break;\n\n      case 'blob':\n        if (typeof this._response === 'object' && this._response) {\n          this._cachedResponse = BlobManager.createFromOptions(this._response);\n        } else {\n          throw new Error(\"Invalid response for blob: \".concat(this._response));\n        }\n\n        break;\n\n      case 'json':\n        try {\n          this._cachedResponse = JSON.parse(this._response);\n        } catch (_) {\n          this._cachedResponse = null;\n        }\n\n        break;\n\n      default:\n        this._cachedResponse = null;\n    }\n\n    return this._cachedResponse;\n  }\n\n  __didCreateRequest(requestId) {\n    this._requestId = requestId;\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);\n  }\n\n  __didUploadProgress(requestId, progress, total) {\n    if (requestId === this._requestId) {\n      this.upload.dispatchEvent({\n        type: 'progress',\n        lengthComputable: true,\n        loaded: progress,\n        total\n      });\n    }\n  }\n\n  __didReceiveResponse(requestId, status, responseHeaders, responseURL) {\n    if (requestId === this._requestId) {\n      this.status = status;\n      this.setResponseHeaders(responseHeaders);\n      this.setReadyState(this.HEADERS_RECEIVED);\n\n      if (responseURL || responseURL === '') {\n        this.responseURL = responseURL;\n      } else {\n        delete this.responseURL;\n      }\n\n      XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});\n    }\n  }\n\n  __didReceiveData(requestId, response) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n\n    this._response = response;\n    this._cachedResponse = undefined;\n    this.setReadyState(this.LOADING);\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);\n  }\n\n  __didReceiveIncrementalData(requestId, responseText, progress, total) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n\n    if (!this._response) {\n      this._response = responseText;\n    } else {\n      this._response += responseText;\n    }\n\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n    this.setReadyState(this.LOADING);\n\n    this.__didReceiveDataProgress(requestId, progress, total);\n  }\n\n  __didReceiveDataProgress(requestId, loaded, total) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n\n    this.dispatchEvent({\n      type: 'progress',\n      lengthComputable: total >= 0,\n      loaded,\n      total\n    });\n  }\n\n  __didCompleteResponse(requestId, error, timeOutError) {\n    if (requestId === this._requestId) {\n      if (error) {\n        if (this._responseType === '' || this._responseType === 'text') {\n          this._response = error;\n        }\n\n        this._hasError = true;\n\n        if (timeOutError) {\n          this._timedOut = true;\n        }\n      }\n\n      this._clearSubscriptions();\n\n      this._requestId = null;\n      this.setReadyState(this.DONE);\n\n      if (error) {\n        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n      } else {\n        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);\n      }\n    }\n  }\n\n  _clearSubscriptions() {\n    (this._subscriptions || []).forEach(sub => {\n      if (sub) {\n        sub.remove();\n      }\n    });\n    this._subscriptions = [];\n  }\n\n  getAllResponseHeaders() {\n    if (!this.responseHeaders) {\n      return null;\n    }\n\n    var headers = this.responseHeaders || {};\n    return Object.keys(headers).map(headerName => {\n      return headerName + ': ' + headers[headerName];\n    }).join('\\r\\n');\n  }\n\n  getResponseHeader(header) {\n    var value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n\n    return value !== undefined ? value : null;\n  }\n\n  setRequestHeader(header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n\n    this._headers[header.toLowerCase()] = String(value);\n  }\n\n  setTrackingName(trackingName) {\n    this._trackingName = trackingName;\n    return this;\n  }\n\n  open(method, url, async) {\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n\n    if (async !== undefined && !async) {\n      throw new Error('Synchronous http requests are not supported');\n    }\n\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n\n  send(data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n\n    this._sent = true;\n    var incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n    this._subscriptions.push(RCTNetworking.addListener('didSendNetworkData', args => this.__didUploadProgress(...args)));\n\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkResponse', args => this.__didReceiveResponse(...args)));\n\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkData', args => this.__didReceiveData(...args)));\n\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkIncrementalData', args => this.__didReceiveIncrementalData(...args)));\n\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkDataProgress', args => this.__didReceiveDataProgress(...args)));\n\n    this._subscriptions.push(RCTNetworking.addListener('didCompleteNetworkResponse', args => this.__didCompleteResponse(...args)));\n\n    var nativeResponseType = 'text';\n\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n\n    invariant(this._method, 'Request method needs to be defined.');\n    invariant(this._url, 'Request URL needs to be defined.');\n    RCTNetworking.sendRequest(this._method, this._trackingName, this._url, this._headers, data, nativeResponseType, incrementalEvents, this.timeout, this.__didCreateRequest.bind(this), this.withCredentials);\n  }\n\n  abort() {\n    this._aborted = true;\n\n    if (this._requestId) {\n      RCTNetworking.abortRequest(this._requestId);\n    }\n\n    if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {\n      this._reset();\n\n      this.setReadyState(this.DONE);\n    }\n\n    this._reset();\n  }\n\n  setResponseHeaders(responseHeaders) {\n    this.responseHeaders = responseHeaders || null;\n    var headers = responseHeaders || {};\n    this._lowerCaseResponseHeaders = Object.keys(headers).reduce((lcaseHeaders, headerName) => {\n      lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n      return lcaseHeaders;\n    }, {});\n  }\n\n  setReadyState(newState) {\n    this.readyState = newState;\n    this.dispatchEvent({\n      type: 'readystatechange'\n    });\n\n    if (newState === this.DONE) {\n      if (this._aborted) {\n        this.dispatchEvent({\n          type: 'abort'\n        });\n      } else if (this._hasError) {\n        if (this._timedOut) {\n          this.dispatchEvent({\n            type: 'timeout'\n          });\n        } else {\n          this.dispatchEvent({\n            type: 'error'\n          });\n        }\n      } else {\n        this.dispatchEvent({\n          type: 'load'\n        });\n      }\n\n      this.dispatchEvent({\n        type: 'loadend'\n      });\n    }\n  }\n\n  addEventListener(type, listener) {\n    if (type === 'readystatechange' || type === 'progress') {\n      this._incrementalEvents = true;\n    }\n\n    super.addEventListener(type, listener);\n  }\n\n}\n\nXMLHttpRequest.UNSENT = UNSENT;\nXMLHttpRequest.OPENED = OPENED;\nXMLHttpRequest.HEADERS_RECEIVED = HEADERS_RECEIVED;\nXMLHttpRequest.LOADING = LOADING;\nXMLHttpRequest.DONE = DONE;\nXMLHttpRequest._interceptor = null;\nmodule.exports = XMLHttpRequest;","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/Network/XMLHttpRequest.js"],"names":["EventTarget","require","RCTNetworking","base64","invariant","warning","BlobManager","isAvailable","addNetworkingHandler","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","SUPPORTED_RESPONSE_TYPES","arraybuffer","global","ArrayBuffer","blob","Blob","document","json","text","REQUEST_EVENTS","XHR_EVENTS","concat","XMLHttpRequestEventTarget","XMLHttpRequest","setInterceptor","interceptor","_interceptor","constructor","readyState","status","timeout","withCredentials","upload","_aborted","_hasError","_method","_response","_url","_timedOut","_trackingName","_incrementalEvents","_reset","responseHeaders","undefined","responseURL","_requestId","_cachedResponse","_headers","_responseType","_sent","_lowerCaseResponseHeaders","_clearSubscriptions","responseType","Error","hasOwnProperty","responseText","response","toByteArray","buffer","createFromOptions","JSON","parse","_","__didCreateRequest","requestId","requestSent","__didUploadProgress","progress","total","dispatchEvent","type","lengthComputable","loaded","__didReceiveResponse","setResponseHeaders","setReadyState","responseReceived","__didReceiveData","dataReceived","__didReceiveIncrementalData","__didReceiveDataProgress","__didCompleteResponse","error","timeOutError","loadingFailed","loadingFinished","length","_subscriptions","forEach","sub","remove","getAllResponseHeaders","headers","Object","keys","map","headerName","join","getResponseHeader","header","value","toLowerCase","setRequestHeader","String","setTrackingName","trackingName","open","method","url","async","toUpperCase","send","data","incrementalEvents","onreadystatechange","onprogress","push","addListener","args","nativeResponseType","sendRequest","bind","abort","abortRequest","reduce","lcaseHeaders","newState","addEventListener","listener","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst EventTarget = require('event-target-shim');\nconst RCTNetworking = require('./RCTNetworking');\n\n/* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an error\n * found when Flow v0.54 was deployed. To see the error delete this comment and\n * run Flow. */\nconst base64 = require('base64-js');\nconst invariant = require('fbjs/lib/invariant');\n/* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an error\n * found when Flow v0.54 was deployed. To see the error delete this comment and\n * run Flow. */\nconst warning = require('fbjs/lib/warning');\nconst BlobManager = require('../Blob/BlobManager');\n\nexport type NativeResponseType = 'base64' | 'blob' | 'text';\nexport type ResponseType =\n  | ''\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text';\nexport type Response = ?Object | string;\n\ntype XHRInterceptor = {\n  requestSent(id: number, url: string, method: string, headers: Object): void,\n  responseReceived(\n    id: number,\n    url: string,\n    status: number,\n    headers: Object,\n  ): void,\n  dataReceived(id: number, data: string): void,\n  loadingFinished(id: number, encodedDataLength: number): void,\n  loadingFailed(id: number, error: string): void,\n};\n\n// The native blob module is optional so inject it here if available.\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\n\nconst UNSENT = 0;\nconst OPENED = 1;\nconst HEADERS_RECEIVED = 2;\nconst LOADING = 3;\nconst DONE = 4;\n\nconst SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true,\n};\n\nconst REQUEST_EVENTS = [\n  'abort',\n  'error',\n  'load',\n  'loadstart',\n  'progress',\n  'timeout',\n  'loadend',\n];\n\nconst XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\n\nclass XMLHttpRequestEventTarget extends EventTarget(...REQUEST_EVENTS) {\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n}\n\n/**\n * Shared base for platform-specific XMLHttpRequest implementations.\n */\nclass XMLHttpRequest extends EventTarget(...XHR_EVENTS) {\n  static UNSENT: number = UNSENT;\n  static OPENED: number = OPENED;\n  static HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  static LOADING: number = LOADING;\n  static DONE: number = DONE;\n\n  static _interceptor: ?XHRInterceptor = null;\n\n  UNSENT: number = UNSENT;\n  OPENED: number = OPENED;\n  HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  LOADING: number = LOADING;\n  DONE: number = DONE;\n\n  // EventTarget automatically initializes these to `null`.\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n  onreadystatechange: ?Function;\n\n  readyState: number = UNSENT;\n  responseHeaders: ?Object;\n  status: number = 0;\n  timeout: number = 0;\n  responseURL: ?string;\n  withCredentials: boolean = true;\n\n  upload: XMLHttpRequestEventTarget = new XMLHttpRequestEventTarget();\n\n  _requestId: ?number;\n  _subscriptions: Array<*>;\n\n  _aborted: boolean = false;\n  _cachedResponse: Response;\n  _hasError: boolean = false;\n  _headers: Object;\n  _lowerCaseResponseHeaders: Object;\n  _method: ?string = null;\n  _response: string | ?Object;\n  _responseType: ResponseType;\n  _response: string = '';\n  _sent: boolean;\n  _url: ?string = null;\n  _timedOut: boolean = false;\n  _trackingName: string = 'unknown';\n  _incrementalEvents: boolean = false;\n\n  static setInterceptor(interceptor: ?XHRInterceptor) {\n    XMLHttpRequest._interceptor = interceptor;\n  }\n\n  constructor() {\n    super();\n    this._reset();\n  }\n\n  _reset(): void {\n    this.readyState = this.UNSENT;\n    this.responseHeaders = undefined;\n    this.status = 0;\n    delete this.responseURL;\n\n    this._requestId = null;\n\n    this._cachedResponse = undefined;\n    this._hasError = false;\n    this._headers = {};\n    this._response = '';\n    this._responseType = '';\n    this._sent = false;\n    this._lowerCaseResponseHeaders = {};\n\n    this._clearSubscriptions();\n    this._timedOut = false;\n  }\n\n  get responseType(): ResponseType {\n    return this._responseType;\n  }\n\n  set responseType(responseType: ResponseType): void {\n    if (this._sent) {\n      throw new Error(\n        \"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" +\n          'response type cannot be set after the request has been sent.',\n      );\n    }\n    if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n      warning(\n        false,\n        `The provided value '${responseType}' is not a valid 'responseType'.`,\n      );\n      return;\n    }\n\n    // redboxes early, e.g. for 'arraybuffer' on ios 7\n    invariant(\n      SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document',\n      `The provided value '${responseType}' is unsupported in this environment.`,\n    );\n\n    if (responseType === 'blob') {\n      invariant(\n        BlobManager.isAvailable,\n        'Native module BlobModule is required for blob support',\n      );\n    }\n    this._responseType = responseType;\n  }\n\n  get responseText(): string {\n    if (this._responseType !== '' && this._responseType !== 'text') {\n      throw new Error(\n        \"The 'responseText' property is only available if 'responseType' \" +\n          `is set to '' or 'text', but it is '${this._responseType}'.`,\n      );\n    }\n    if (this.readyState < LOADING) {\n      return '';\n    }\n    return this._response;\n  }\n\n  get response(): Response {\n    const {responseType} = this;\n    if (responseType === '' || responseType === 'text') {\n      return this.readyState < LOADING || this._hasError ? '' : this._response;\n    }\n\n    if (this.readyState !== DONE) {\n      return null;\n    }\n\n    if (this._cachedResponse !== undefined) {\n      return this._cachedResponse;\n    }\n\n    switch (responseType) {\n      case 'document':\n        this._cachedResponse = null;\n        break;\n\n      case 'arraybuffer':\n        this._cachedResponse = base64.toByteArray(this._response).buffer;\n        break;\n\n      case 'blob':\n        if (typeof this._response === 'object' && this._response) {\n          this._cachedResponse = BlobManager.createFromOptions(this._response);\n        } else {\n          throw new Error(`Invalid response for blob: ${this._response}`);\n        }\n        break;\n\n      case 'json':\n        try {\n          this._cachedResponse = JSON.parse(this._response);\n        } catch (_) {\n          this._cachedResponse = null;\n        }\n        break;\n\n      default:\n        this._cachedResponse = null;\n    }\n\n    return this._cachedResponse;\n  }\n\n  // exposed for testing\n  __didCreateRequest(requestId: number): void {\n    this._requestId = requestId;\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.requestSent(\n        requestId,\n        this._url || '',\n        this._method || 'GET',\n        this._headers,\n      );\n  }\n\n  // exposed for testing\n  __didUploadProgress(\n    requestId: number,\n    progress: number,\n    total: number,\n  ): void {\n    if (requestId === this._requestId) {\n      this.upload.dispatchEvent({\n        type: 'progress',\n        lengthComputable: true,\n        loaded: progress,\n        total,\n      });\n    }\n  }\n\n  __didReceiveResponse(\n    requestId: number,\n    status: number,\n    responseHeaders: ?Object,\n    responseURL: ?string,\n  ): void {\n    if (requestId === this._requestId) {\n      this.status = status;\n      this.setResponseHeaders(responseHeaders);\n      this.setReadyState(this.HEADERS_RECEIVED);\n      if (responseURL || responseURL === '') {\n        this.responseURL = responseURL;\n      } else {\n        delete this.responseURL;\n      }\n\n      XMLHttpRequest._interceptor &&\n        XMLHttpRequest._interceptor.responseReceived(\n          requestId,\n          responseURL || this._url || '',\n          status,\n          responseHeaders || {},\n        );\n    }\n  }\n\n  __didReceiveData(requestId: number, response: string): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this._response = response;\n    this._cachedResponse = undefined; // force lazy recomputation\n    this.setReadyState(this.LOADING);\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, response);\n  }\n\n  __didReceiveIncrementalData(\n    requestId: number,\n    responseText: string,\n    progress: number,\n    total: number,\n  ) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    if (!this._response) {\n      this._response = responseText;\n    } else {\n      this._response += responseText;\n    }\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n\n    this.setReadyState(this.LOADING);\n    this.__didReceiveDataProgress(requestId, progress, total);\n  }\n\n  __didReceiveDataProgress(\n    requestId: number,\n    loaded: number,\n    total: number,\n  ): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this.dispatchEvent({\n      type: 'progress',\n      lengthComputable: total >= 0,\n      loaded,\n      total,\n    });\n  }\n\n  // exposed for testing\n  __didCompleteResponse(\n    requestId: number,\n    error: string,\n    timeOutError: boolean,\n  ): void {\n    if (requestId === this._requestId) {\n      if (error) {\n        if (this._responseType === '' || this._responseType === 'text') {\n          this._response = error;\n        }\n        this._hasError = true;\n        if (timeOutError) {\n          this._timedOut = true;\n        }\n      }\n      this._clearSubscriptions();\n      this._requestId = null;\n      this.setReadyState(this.DONE);\n\n      if (error) {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n      } else {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFinished(\n            requestId,\n            this._response.length,\n          );\n      }\n    }\n  }\n\n  _clearSubscriptions(): void {\n    (this._subscriptions || []).forEach(sub => {\n      if (sub) {\n        sub.remove();\n      }\n    });\n    this._subscriptions = [];\n  }\n\n  getAllResponseHeaders(): ?string {\n    if (!this.responseHeaders) {\n      // according to the spec, return null if no response has been received\n      return null;\n    }\n    const headers = this.responseHeaders || {};\n    return Object.keys(headers)\n      .map(headerName => {\n        return headerName + ': ' + headers[headerName];\n      })\n      .join('\\r\\n');\n  }\n\n  getResponseHeader(header: string): ?string {\n    const value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n    return value !== undefined ? value : null;\n  }\n\n  setRequestHeader(header: string, value: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    this._headers[header.toLowerCase()] = String(value);\n  }\n\n  /**\n   * Custom extension for tracking origins of request.\n   */\n  setTrackingName(trackingName: string): XMLHttpRequest {\n    this._trackingName = trackingName;\n    return this;\n  }\n\n  open(method: string, url: string, async: ?boolean): void {\n    /* Other optional arguments are not supported yet */\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n    if (async !== undefined && !async) {\n      // async is default\n      throw new Error('Synchronous http requests are not supported');\n    }\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n\n  send(data: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n    this._sent = true;\n    const incrementalEvents =\n      this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n    this._subscriptions.push(\n      RCTNetworking.addListener('didSendNetworkData', args =>\n        this.__didUploadProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkResponse', args =>\n        this.__didReceiveResponse(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkData', args =>\n        this.__didReceiveData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkIncrementalData', args =>\n        this.__didReceiveIncrementalData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkDataProgress', args =>\n        this.__didReceiveDataProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didCompleteNetworkResponse', args =>\n        this.__didCompleteResponse(...args),\n      ),\n    );\n\n    let nativeResponseType: NativeResponseType = 'text';\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n\n    invariant(this._method, 'Request method needs to be defined.');\n    invariant(this._url, 'Request URL needs to be defined.');\n    RCTNetworking.sendRequest(\n      this._method,\n      this._trackingName,\n      this._url,\n      this._headers,\n      data,\n      /* $FlowFixMe(>=0.78.0 site=react_native_android_fb) This issue was found\n       * when making Flow check .android.js files. */\n      nativeResponseType,\n      incrementalEvents,\n      this.timeout,\n      this.__didCreateRequest.bind(this),\n      this.withCredentials,\n    );\n  }\n\n  abort(): void {\n    this._aborted = true;\n    if (this._requestId) {\n      RCTNetworking.abortRequest(this._requestId);\n    }\n    // only call onreadystatechange if there is something to abort,\n    // below logic is per spec\n    if (\n      !(\n        this.readyState === this.UNSENT ||\n        (this.readyState === this.OPENED && !this._sent) ||\n        this.readyState === this.DONE\n      )\n    ) {\n      this._reset();\n      this.setReadyState(this.DONE);\n    }\n    // Reset again after, in case modified in handler\n    this._reset();\n  }\n\n  setResponseHeaders(responseHeaders: ?Object): void {\n    this.responseHeaders = responseHeaders || null;\n    const headers = responseHeaders || {};\n    this._lowerCaseResponseHeaders = Object.keys(headers).reduce(\n      (lcaseHeaders, headerName) => {\n        lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n        return lcaseHeaders;\n      },\n      {},\n    );\n  }\n\n  setReadyState(newState: number): void {\n    this.readyState = newState;\n    this.dispatchEvent({type: 'readystatechange'});\n    if (newState === this.DONE) {\n      if (this._aborted) {\n        this.dispatchEvent({type: 'abort'});\n      } else if (this._hasError) {\n        if (this._timedOut) {\n          this.dispatchEvent({type: 'timeout'});\n        } else {\n          this.dispatchEvent({type: 'error'});\n        }\n      } else {\n        this.dispatchEvent({type: 'load'});\n      }\n      this.dispatchEvent({type: 'loadend'});\n    }\n  }\n\n  /* global EventListener */\n  addEventListener(type: string, listener: EventListener): void {\n    // If we dont' have a 'readystatechange' event handler, we don't\n    // have to send repeated LOADING events with incremental updates\n    // to responseText, which will avoid a bunch of native -> JS\n    // bridge traffic.\n    if (type === 'readystatechange' || type === 'progress') {\n      this._incrementalEvents = true;\n    }\n    super.addEventListener(type, listener);\n  }\n}\n\nmodule.exports = XMLHttpRequest;\n"]},"metadata":{},"sourceType":"script"}