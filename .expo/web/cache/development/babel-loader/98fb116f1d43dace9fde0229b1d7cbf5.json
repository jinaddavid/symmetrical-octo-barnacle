{"ast":null,"code":"'use strict';\n\nvar _excluded = [\"message\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar BatchedBridge = require(\"./BatchedBridge\");\n\nvar invariant = require('fbjs/lib/invariant');\n\nfunction genModule(config, moduleID) {\n  if (!config) {\n    return null;\n  }\n\n  var [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  invariant(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), \"Module name prefixes should've been stripped by the native side \" + \"but wasn't for \" + moduleName);\n\n  if (!constants && !methods) {\n    return {\n      name: moduleName\n    };\n  }\n\n  var module = {};\n  methods && methods.forEach((methodName, methodID) => {\n    var isPromise = promiseMethods && arrayContains(promiseMethods, methodID);\n    var isSync = syncMethods && arrayContains(syncMethods, methodID);\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n\n  _extends(module, constants);\n\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n\n  return {\n    name: moduleName,\n    module\n  };\n}\n\nglobal.__fbGenNativeModule = genModule;\n\nfunction loadModule(name, moduleID) {\n  invariant(global.nativeRequireModuleConfig, \"Can't lazily create module without nativeRequireModuleConfig\");\n  var config = global.nativeRequireModuleConfig(name);\n  var info = genModule(config, moduleID);\n  return info && info.module;\n}\n\nfunction genMethod(moduleID, methodID, type) {\n  var fn = null;\n\n  if (type === 'promise') {\n    fn = function fn() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return new Promise((resolve, reject) => {\n        BatchedBridge.enqueueNativeCall(moduleID, methodID, args, data => resolve(data), errorData => reject(createErrorFromErrorData(errorData)));\n      });\n    };\n  } else if (type === 'sync') {\n    fn = function fn() {\n      if (__DEV__) {\n        invariant(global.nativeCallSyncHook, 'Calling synchronous methods on native ' + 'modules is not supported in Chrome.\\n\\n Consider providing alternative ' + 'methods to expose this method in debug mode, e.g. by exposing constants ' + 'ahead-of-time.');\n      }\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return global.nativeCallSyncHook(moduleID, methodID, args);\n    };\n  } else {\n    fn = function fn() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var lastArg = args.length > 0 ? args[args.length - 1] : null;\n      var secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      var hasSuccessCallback = typeof lastArg === 'function';\n      var hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback && invariant(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');\n      var onSuccess = hasSuccessCallback ? lastArg : null;\n      var onFail = hasErrorCallback ? secondLastArg : null;\n      var callbackCount = hasSuccessCallback + hasErrorCallback;\n      args = args.slice(0, args.length - callbackCount);\n      BatchedBridge.enqueueNativeCall(moduleID, methodID, args, onFail, onSuccess);\n    };\n  }\n\n  fn.type = type;\n  return fn;\n}\n\nfunction arrayContains(array, value) {\n  return array.indexOf(value) !== -1;\n}\n\nfunction createErrorFromErrorData(errorData) {\n  var _ref = errorData || {},\n      {\n    message\n  } = _ref,\n      extraErrorInfo = _objectWithoutProperties(_ref, _excluded);\n\n  var error = new Error(message);\n  error.framesToPop = 1;\n  return _extends(error, extraErrorInfo);\n}\n\nvar NativeModules = {};\n\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else if (!global.nativeExtensions) {\n  var bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');\n\n  var defineLazyObjectProperty = require(\"../Utilities/defineLazyObjectProperty\");\n\n  (bridgeConfig.remoteModuleConfig || []).forEach((config, moduleID) => {\n    var info = genModule(config, moduleID);\n\n    if (!info) {\n      return;\n    }\n\n    if (info.module) {\n      NativeModules[info.name] = info.module;\n    } else {\n        defineLazyObjectProperty(NativeModules, info.name, {\n          get: () => loadModule(info.name, moduleID)\n        });\n      }\n  });\n}\n\nmodule.exports = NativeModules;","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/BatchedBridge/NativeModules.js"],"names":["BatchedBridge","require","invariant","genModule","config","moduleID","moduleName","constants","methods","promiseMethods","syncMethods","startsWith","name","module","forEach","methodName","methodID","isPromise","arrayContains","isSync","methodType","genMethod","__DEV__","createDebugLookup","global","__fbGenNativeModule","loadModule","nativeRequireModuleConfig","info","type","fn","args","Promise","resolve","reject","enqueueNativeCall","data","errorData","createErrorFromErrorData","nativeCallSyncHook","lastArg","length","secondLastArg","hasSuccessCallback","hasErrorCallback","onSuccess","onFail","callbackCount","slice","array","value","indexOf","message","extraErrorInfo","error","Error","framesToPop","NativeModules","nativeModuleProxy","nativeExtensions","bridgeConfig","__fbBatchedBridgeConfig","defineLazyObjectProperty","remoteModuleConfig","get","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst BatchedBridge = require('./BatchedBridge');\n\nconst invariant = require('fbjs/lib/invariant');\n\nimport type {ExtendedError} from '../Core/Devtools/parseErrorStack';\n\ntype ModuleConfig = [\n  string /* name */,\n  ?Object /* constants */,\n  Array<string> /* functions */,\n  Array<number> /* promise method IDs */,\n  Array<number> /* sync method IDs */,\n];\n\nexport type MethodType = 'async' | 'promise' | 'sync';\n\nfunction genModule(\n  config: ?ModuleConfig,\n  moduleID: number,\n): ?{name: string, module?: Object} {\n  if (!config) {\n    return null;\n  }\n\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  invariant(\n    !moduleName.startsWith('RCT') && !moduleName.startsWith('RK'),\n    \"Module name prefixes should've been stripped by the native side \" +\n      \"but wasn't for \" +\n      moduleName,\n  );\n\n  if (!constants && !methods) {\n    // Module contents will be filled in lazily later\n    return {name: moduleName};\n  }\n\n  const module = {};\n  methods &&\n    methods.forEach((methodName, methodID) => {\n      const isPromise =\n        promiseMethods && arrayContains(promiseMethods, methodID);\n      const isSync = syncMethods && arrayContains(syncMethods, methodID);\n      invariant(\n        !isPromise || !isSync,\n        'Cannot have a method that is both async and a sync hook',\n      );\n      const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n      module[methodName] = genMethod(moduleID, methodID, methodType);\n    });\n  Object.assign(module, constants);\n\n  if (__DEV__) {\n    BatchedBridge.createDebugLookup(moduleID, moduleName, methods);\n  }\n\n  return {name: moduleName, module};\n}\n\n// export this method as a global so we can call it from native\nglobal.__fbGenNativeModule = genModule;\n\nfunction loadModule(name: string, moduleID: number): ?Object {\n  invariant(\n    global.nativeRequireModuleConfig,\n    \"Can't lazily create module without nativeRequireModuleConfig\",\n  );\n  const config = global.nativeRequireModuleConfig(name);\n  const info = genModule(config, moduleID);\n  return info && info.module;\n}\n\nfunction genMethod(moduleID: number, methodID: number, type: MethodType) {\n  let fn = null;\n  if (type === 'promise') {\n    fn = function(...args: Array<any>) {\n      return new Promise((resolve, reject) => {\n        BatchedBridge.enqueueNativeCall(\n          moduleID,\n          methodID,\n          args,\n          data => resolve(data),\n          errorData => reject(createErrorFromErrorData(errorData)),\n        );\n      });\n    };\n  } else if (type === 'sync') {\n    fn = function(...args: Array<any>) {\n      if (__DEV__) {\n        invariant(\n          global.nativeCallSyncHook,\n          'Calling synchronous methods on native ' +\n            'modules is not supported in Chrome.\\n\\n Consider providing alternative ' +\n            'methods to expose this method in debug mode, e.g. by exposing constants ' +\n            'ahead-of-time.',\n        );\n      }\n      return global.nativeCallSyncHook(moduleID, methodID, args);\n    };\n  } else {\n    fn = function(...args: Array<any>) {\n      const lastArg = args.length > 0 ? args[args.length - 1] : null;\n      const secondLastArg = args.length > 1 ? args[args.length - 2] : null;\n      const hasSuccessCallback = typeof lastArg === 'function';\n      const hasErrorCallback = typeof secondLastArg === 'function';\n      hasErrorCallback &&\n        invariant(\n          hasSuccessCallback,\n          'Cannot have a non-function arg after a function arg.',\n        );\n      const onSuccess = hasSuccessCallback ? lastArg : null;\n      const onFail = hasErrorCallback ? secondLastArg : null;\n      const callbackCount = hasSuccessCallback + hasErrorCallback;\n      args = args.slice(0, args.length - callbackCount);\n      BatchedBridge.enqueueNativeCall(\n        moduleID,\n        methodID,\n        args,\n        onFail,\n        onSuccess,\n      );\n    };\n  }\n  fn.type = type;\n  return fn;\n}\n\nfunction arrayContains<T>(array: Array<T>, value: T): boolean {\n  return array.indexOf(value) !== -1;\n}\n\nfunction createErrorFromErrorData(errorData: {message: string}): ExtendedError {\n  const {message, ...extraErrorInfo} = errorData || {};\n  const error: ExtendedError = new Error(message);\n  error.framesToPop = 1;\n  return Object.assign(error, extraErrorInfo);\n}\n\nlet NativeModules: {[moduleName: string]: Object} = {};\nif (global.nativeModuleProxy) {\n  NativeModules = global.nativeModuleProxy;\n} else if (!global.nativeExtensions) {\n  const bridgeConfig = global.__fbBatchedBridgeConfig;\n  invariant(\n    bridgeConfig,\n    '__fbBatchedBridgeConfig is not set, cannot invoke native modules',\n  );\n\n  const defineLazyObjectProperty = require('../Utilities/defineLazyObjectProperty');\n  (bridgeConfig.remoteModuleConfig || []).forEach(\n    (config: ModuleConfig, moduleID: number) => {\n      // Initially this config will only contain the module name when running in JSC. The actual\n      // configuration of the module will be lazily loaded.\n      const info = genModule(config, moduleID);\n      if (!info) {\n        return;\n      }\n\n      if (info.module) {\n        NativeModules[info.name] = info.module;\n      }\n      // If there's no module config, define a lazy getter\n      else {\n        defineLazyObjectProperty(NativeModules, info.name, {\n          get: () => loadModule(info.name, moduleID),\n        });\n      }\n    },\n  );\n}\n\nmodule.exports = NativeModules;\n"]},"metadata":{},"sourceType":"script"}