{"ast":null,"code":"'use strict';\n\nvar _shouldPolyfillES6Collection = require(\"./_shouldPolyfillES6Collection\");\n\nvar guid = require(\"./guid\");\n\nvar isNode = require('fbjs/lib/isNode');\n\nvar toIterator = require(\"./toIterator\");\n\nmodule.exports = function (global, undefined) {\n  if (!_shouldPolyfillES6Collection('Map')) {\n    return global.Map;\n  }\n\n  var KIND_KEY = 'key';\n  var KIND_VALUE = 'value';\n  var KIND_KEY_VALUE = 'key+value';\n  var KEY_PREFIX = '$map_';\n  var SECRET_SIZE_PROP;\n\n  if (__DEV__) {\n    SECRET_SIZE_PROP = '$size' + guid();\n  }\n\n  var OLD_IE_HASH_PREFIX = 'IE_HASH_';\n\n  class Map {\n    constructor(iterable) {\n      if (!isObject(this)) {\n        throw new TypeError('Wrong map object type.');\n      }\n\n      initMap(this);\n\n      if (iterable != null) {\n        var it = toIterator(iterable);\n        var next;\n\n        while (!(next = it.next()).done) {\n          if (!isObject(next.value)) {\n            throw new TypeError('Expected iterable items to be pair objects.');\n          }\n\n          this.set(next.value[0], next.value[1]);\n        }\n      }\n    }\n\n    clear() {\n      initMap(this);\n    }\n\n    has(key) {\n      var index = getIndex(this, key);\n      return !!(index != null && this._mapData[index]);\n    }\n\n    set(key, value) {\n      var index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        this._mapData[index][1] = value;\n      } else {\n        index = this._mapData.push([key, value]) - 1;\n        setIndex(this, key, index);\n\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] += 1;\n        } else {\n          this.size += 1;\n        }\n      }\n\n      return this;\n    }\n\n    get(key) {\n      var index = getIndex(this, key);\n\n      if (index == null) {\n        return undefined;\n      } else {\n        return this._mapData[index][1];\n      }\n    }\n\n    delete(key) {\n      var index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        setIndex(this, key, undefined);\n        this._mapData[index] = undefined;\n\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] -= 1;\n        } else {\n          this.size -= 1;\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    entries() {\n      return new MapIterator(this, KIND_KEY_VALUE);\n    }\n\n    keys() {\n      return new MapIterator(this, KIND_KEY);\n    }\n\n    values() {\n      return new MapIterator(this, KIND_VALUE);\n    }\n\n    forEach(callback, thisArg) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be callable.');\n      }\n\n      var boundCallback = callback.bind(thisArg || undefined);\n      var mapData = this._mapData;\n\n      for (var i = 0; i < mapData.length; i++) {\n        var entry = mapData[i];\n\n        if (entry != null) {\n          boundCallback(entry[1], entry[0], this);\n        }\n      }\n    }\n\n  }\n\n  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;\n\n  class MapIterator {\n    constructor(map, kind) {\n      if (!(isObject(map) && map._mapData)) {\n        throw new TypeError('Object is not a map.');\n      }\n\n      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {\n        throw new Error('Invalid iteration kind.');\n      }\n\n      this._map = map;\n      this._nextIndex = 0;\n      this._kind = kind;\n    }\n\n    next() {\n      if (!this instanceof Map) {\n        throw new TypeError('Expected to be called on a MapIterator.');\n      }\n\n      var map = this._map;\n      var index = this._nextIndex;\n      var kind = this._kind;\n\n      if (map == null) {\n        return createIterResultObject(undefined, true);\n      }\n\n      var entries = map._mapData;\n\n      while (index < entries.length) {\n        var record = entries[index];\n        index += 1;\n        this._nextIndex = index;\n\n        if (record) {\n          if (kind === KIND_KEY) {\n            return createIterResultObject(record[0], false);\n          } else if (kind === KIND_VALUE) {\n            return createIterResultObject(record[1], false);\n          } else if (kind) {\n            return createIterResultObject(record, false);\n          }\n        }\n      }\n\n      this._map = undefined;\n      return createIterResultObject(undefined, true);\n    }\n\n  }\n\n  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function getIndex(map, key) {\n    if (isObject(key)) {\n      var hash = getHash(key);\n      return map._objectIndex[hash];\n    } else {\n      var prefixedKey = KEY_PREFIX + key;\n\n      if (typeof key === 'string') {\n        return map._stringIndex[prefixedKey];\n      } else {\n        return map._otherIndex[prefixedKey];\n      }\n    }\n  }\n\n  function setIndex(map, key, index) {\n    var shouldDelete = index == null;\n\n    if (isObject(key)) {\n      var hash = getHash(key);\n\n      if (shouldDelete) {\n        delete map._objectIndex[hash];\n      } else {\n        map._objectIndex[hash] = index;\n      }\n    } else {\n      var prefixedKey = KEY_PREFIX + key;\n\n      if (typeof key === 'string') {\n        if (shouldDelete) {\n          delete map._stringIndex[prefixedKey];\n        } else {\n          map._stringIndex[prefixedKey] = index;\n        }\n      } else {\n        if (shouldDelete) {\n          delete map._otherIndex[prefixedKey];\n        } else {\n          map._otherIndex[prefixedKey] = index;\n        }\n      }\n    }\n  }\n\n  function initMap(map) {\n    map._mapData = [];\n    map._objectIndex = {};\n    map._stringIndex = {};\n    map._otherIndex = {};\n\n    if (__DEV__) {\n      if (isES5) {\n        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {\n          map[SECRET_SIZE_PROP] = 0;\n        } else {\n          Object.defineProperty(map, SECRET_SIZE_PROP, {\n            value: 0,\n            writable: true\n          });\n          Object.defineProperty(map, 'size', {\n            set: v => {\n              console.error('PLEASE FIX ME: You are changing the map size property which ' + 'should not be writable and will break in production.');\n              throw new Error('The map size property is not writable.');\n            },\n            get: () => map[SECRET_SIZE_PROP]\n          });\n        }\n\n        return;\n      }\n    }\n\n    map.size = 0;\n  }\n\n  function isObject(o) {\n    return o != null && (typeof o === 'object' || typeof o === 'function');\n  }\n\n  function createIterResultObject(value, done) {\n    return {\n      value,\n      done\n    };\n  }\n\n  var isES5 = function () {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }();\n\n  function isExtensible(o) {\n    if (!isES5) {\n      return true;\n    } else {\n      return Object.isExtensible(o);\n    }\n  }\n\n  function getIENodeHash(node) {\n    var uniqueID;\n\n    switch (node.nodeType) {\n      case 1:\n        uniqueID = node.uniqueID;\n        break;\n\n      case 9:\n        uniqueID = node.documentElement.uniqueID;\n        break;\n\n      default:\n        return null;\n    }\n\n    if (uniqueID) {\n      return OLD_IE_HASH_PREFIX + uniqueID;\n    } else {\n      return null;\n    }\n  }\n\n  var getHash = function () {\n    var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    var hashProperty = guid();\n    var hashCounter = 0;\n    return function getHash(o) {\n      if (o[hashProperty]) {\n        return o[hashProperty];\n      } else if (!isES5 && o.propertyIsEnumerable && o.propertyIsEnumerable[hashProperty]) {\n        return o.propertyIsEnumerable[hashProperty];\n      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {\n        return getIENodeHash(o);\n      } else if (!isES5 && o[hashProperty]) {\n        return o[hashProperty];\n      }\n\n      if (isExtensible(o)) {\n        hashCounter += 1;\n\n        if (isES5) {\n          Object.defineProperty(o, hashProperty, {\n            enumerable: false,\n            writable: false,\n            configurable: false,\n            value: hashCounter\n          });\n        } else if (o.propertyIsEnumerable) {\n          o.propertyIsEnumerable = function () {\n            return propIsEnumerable.apply(this, arguments);\n          };\n\n          o.propertyIsEnumerable[hashProperty] = hashCounter;\n        } else if (isNode(o)) {\n          o[hashProperty] = hashCounter;\n        } else {\n          throw new Error('Unable to set a non-enumerable property on object.');\n        }\n\n        return hashCounter;\n      } else {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      }\n    };\n  }();\n\n  return Map;\n}(Function('return this')());","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/vendor/core/Map.js"],"names":["_shouldPolyfillES6Collection","require","guid","isNode","toIterator","module","exports","global","undefined","Map","KIND_KEY","KIND_VALUE","KIND_KEY_VALUE","KEY_PREFIX","SECRET_SIZE_PROP","__DEV__","OLD_IE_HASH_PREFIX","constructor","iterable","isObject","TypeError","initMap","it","next","done","value","set","clear","has","key","index","getIndex","_mapData","push","setIndex","size","get","delete","entries","MapIterator","keys","values","forEach","callback","thisArg","boundCallback","bind","mapData","i","length","entry","prototype","ITERATOR_SYMBOL","map","kind","indexOf","Error","_map","_nextIndex","_kind","createIterResultObject","record","hash","getHash","_objectIndex","prefixedKey","_stringIndex","_otherIndex","shouldDelete","isES5","hasOwnProperty","Object","defineProperty","writable","v","console","error","o","e","isExtensible","getIENodeHash","node","uniqueID","nodeType","documentElement","propIsEnumerable","propertyIsEnumerable","hashProperty","hashCounter","enumerable","configurable","apply","arguments","Function"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @preventMunge\n * @typechecks\n */\n\n/* eslint-disable no-extend-native, no-shadow-restricted-names */\n\n'use strict';\n\nconst _shouldPolyfillES6Collection = require('./_shouldPolyfillES6Collection');\nconst guid = require('./guid');\nconst isNode = require('fbjs/lib/isNode');\nconst toIterator = require('./toIterator');\n\nmodule.exports = (function(global, undefined) {\n  // Since our implementation is spec-compliant for the most part we can safely\n  // delegate to a built-in version if exists and is implemented correctly.\n  // Firefox had gotten a few implementation details wrong across different\n  // versions so we guard against that.\n  if (!_shouldPolyfillES6Collection('Map')) {\n    return global.Map;\n  }\n\n  /**\n   * == ES6 Map Collection ==\n   *\n   * This module is meant to implement a Map collection as described in chapter\n   * 23.1 of the ES6 specification.\n   *\n   * Map objects are collections of key/value pairs where both the keys and\n   * values may be arbitrary ECMAScript language values. A distinct key value\n   * may only occur in one key/value pair within the Map's collection.\n   *\n   * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-map-objects\n   *\n   * There only two -- rather small -- diviations from the spec:\n   *\n   * 1. The use of frozen objects as keys.\n   *    We decided not to allow and simply throw an error. The reason being is\n   *    we store a \"hash\" on the object for fast access to it's place in the\n   *    internal map entries.\n   *    If this turns out to be a popular use case it's possible to implement by\n   *    overiding `Object.freeze` to store a \"hash\" property on the object\n   *    for later use with the map.\n   *\n   * 2. The `size` property on a map object is a regular property and not a\n   *    computed property on the prototype as described by the spec.\n   *    The reason being is that we simply want to support ES3 environments\n   *    which doesn't implement computed properties.\n   *\n   * == Usage ==\n   *\n   * var map = new Map(iterable);\n   *\n   * map.set(key, value);\n   * map.get(key); // value\n   * map.has(key); // true\n   * map.delete(key); // true\n   *\n   * var iterator = map.keys();\n   * iterator.next(); // {value: key, done: false}\n   *\n   * var iterator = map.values();\n   * iterator.next(); // {value: value, done: false}\n   *\n   * var iterator = map.entries();\n   * iterator.next(); // {value: [key, value], done: false}\n   *\n   * map.forEach(function(value, key){ this === thisArg }, thisArg);\n   *\n   * map.clear(); // resets map.\n   */\n\n  /**\n   * Constants\n   */\n\n  // Kinds of map iterations 23.1.5.3\n  const KIND_KEY = 'key';\n  const KIND_VALUE = 'value';\n  const KIND_KEY_VALUE = 'key+value';\n\n  // In older browsers we can't create a null-prototype object so we have to\n  // defend against key collisions with built-in methods.\n  const KEY_PREFIX = '$map_';\n\n  // This property will be used as the internal size variable to disallow\n  // writing and to issue warnings for writings in development.\n  let SECRET_SIZE_PROP;\n  if (__DEV__) {\n    SECRET_SIZE_PROP = '$size' + guid();\n  }\n\n  // In oldIE we use the DOM Node `uniqueID` property to get create the hash.\n  const OLD_IE_HASH_PREFIX = 'IE_HASH_';\n\n  class Map {\n    /**\n     * 23.1.1.1\n     * Takes an `iterable` which is basically any object that implements a\n     * Symbol.iterator (@@iterator) method. The iterable is expected to be a\n     * collection of pairs. Each pair is a key/value pair that will be used\n     * to instantiate the map.\n     *\n     * @param {*} iterable\n     */\n    constructor(iterable) {\n      if (!isObject(this)) {\n        throw new TypeError('Wrong map object type.');\n      }\n\n      initMap(this);\n\n      if (iterable != null) {\n        const it = toIterator(iterable);\n        let next;\n        while (!(next = it.next()).done) {\n          if (!isObject(next.value)) {\n            throw new TypeError('Expected iterable items to be pair objects.');\n          }\n          this.set(next.value[0], next.value[1]);\n        }\n      }\n    }\n\n    /**\n     * 23.1.3.1\n     * Clears the map from all keys and values.\n     */\n    clear() {\n      initMap(this);\n    }\n\n    /**\n     * 23.1.3.7\n     * Check if a key exists in the collection.\n     *\n     * @param {*} key\n     * @return {boolean}\n     */\n    has(key) {\n      const index = getIndex(this, key);\n      return !!(index != null && this._mapData[index]);\n    }\n\n    /**\n     * 23.1.3.9\n     * Adds a key/value pair to the collection.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {map}\n     */\n    set(key, value) {\n      let index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        this._mapData[index][1] = value;\n      } else {\n        index = this._mapData.push([key, value]) - 1;\n        setIndex(this, key, index);\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] += 1;\n        } else {\n          this.size += 1;\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * 23.1.3.6\n     * Gets a value associated with a key in the collection.\n     *\n     * @param {*} key\n     * @return {*}\n     */\n    get(key) {\n      const index = getIndex(this, key);\n      if (index == null) {\n        return undefined;\n      } else {\n        return this._mapData[index][1];\n      }\n    }\n\n    /**\n     * 23.1.3.3\n     * Delete a key/value from the collection.\n     *\n     * @param {*} key\n     * @return {boolean} Whether the key was found and deleted.\n     */\n    delete(key) {\n      const index = getIndex(this, key);\n      if (index != null && this._mapData[index]) {\n        setIndex(this, key, undefined);\n        this._mapData[index] = undefined;\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] -= 1;\n        } else {\n          this.size -= 1;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * 23.1.3.4\n     * Returns an iterator over the key/value pairs (in the form of an Array) in\n     * the collection.\n     *\n     * @return {MapIterator}\n     */\n    entries() {\n      return new MapIterator(this, KIND_KEY_VALUE);\n    }\n\n    /**\n     * 23.1.3.8\n     * Returns an iterator over the keys in the collection.\n     *\n     * @return {MapIterator}\n     */\n    keys() {\n      return new MapIterator(this, KIND_KEY);\n    }\n\n    /**\n     * 23.1.3.11\n     * Returns an iterator over the values pairs in the collection.\n     *\n     * @return {MapIterator}\n     */\n    values() {\n      return new MapIterator(this, KIND_VALUE);\n    }\n\n    /**\n     * 23.1.3.5\n     * Iterates over the key/value pairs in the collection calling `callback`\n     * with [value, key, map]. An optional `thisArg` can be passed to set the\n     * context when `callback` is called.\n     *\n     * @param {function} callback\n     * @param {?object} thisArg\n     */\n    forEach(callback, thisArg) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be callable.');\n      }\n\n      const boundCallback = callback.bind(thisArg || undefined);\n      const mapData = this._mapData;\n\n      // Note that `mapData.length` should be computed on each iteration to\n      // support iterating over new items in the map that were added after the\n      // start of the iteration.\n      for (let i = 0; i < mapData.length; i++) {\n        const entry = mapData[i];\n        if (entry != null) {\n          boundCallback(entry[1], entry[0], this);\n        }\n      }\n    }\n  }\n\n  // 23.1.3.12\n  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;\n\n  class MapIterator {\n    /**\n     * 23.1.5.1\n     * Create a `MapIterator` for a given `map`. While this class is private it\n     * will create objects that will be passed around publicily.\n     *\n     * @param {map} map\n     * @param {string} kind\n     */\n    constructor(map, kind) {\n      if (!(isObject(map) && map._mapData)) {\n        throw new TypeError('Object is not a map.');\n      }\n\n      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {\n        throw new Error('Invalid iteration kind.');\n      }\n\n      this._map = map;\n      this._nextIndex = 0;\n      this._kind = kind;\n    }\n\n    /**\n     * 23.1.5.2.1\n     * Get the next iteration.\n     *\n     * @return {object}\n     */\n    next() {\n      if (!this instanceof Map) {\n        throw new TypeError('Expected to be called on a MapIterator.');\n      }\n\n      const map = this._map;\n      let index = this._nextIndex;\n      const kind = this._kind;\n\n      if (map == null) {\n        return createIterResultObject(undefined, true);\n      }\n\n      const entries = map._mapData;\n\n      while (index < entries.length) {\n        const record = entries[index];\n\n        index += 1;\n        this._nextIndex = index;\n\n        if (record) {\n          if (kind === KIND_KEY) {\n            return createIterResultObject(record[0], false);\n          } else if (kind === KIND_VALUE) {\n            return createIterResultObject(record[1], false);\n          } else if (kind) {\n            return createIterResultObject(record, false);\n          }\n        }\n      }\n\n      this._map = undefined;\n\n      return createIterResultObject(undefined, true);\n    }\n  }\n\n  // We can put this in the class definition once we have computed props\n  // transform.\n  // 23.1.5.2.2\n  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function() {\n    return this;\n  };\n\n  /**\n   * Helper Functions.\n   */\n\n  /**\n   * Return an index to map.[[MapData]] array for a given Key.\n   *\n   * @param {map} map\n   * @param {*} key\n   * @return {?number}\n   */\n  function getIndex(map, key) {\n    if (isObject(key)) {\n      const hash = getHash(key);\n      return map._objectIndex[hash];\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        return map._stringIndex[prefixedKey];\n      } else {\n        return map._otherIndex[prefixedKey];\n      }\n    }\n  }\n\n  /**\n   * Setup an index that refer to the key's location in map.[[MapData]].\n   *\n   * @param {map} map\n   * @param {*} key\n   */\n  function setIndex(map, key, index) {\n    const shouldDelete = index == null;\n\n    if (isObject(key)) {\n      const hash = getHash(key);\n      if (shouldDelete) {\n        delete map._objectIndex[hash];\n      } else {\n        map._objectIndex[hash] = index;\n      }\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        if (shouldDelete) {\n          delete map._stringIndex[prefixedKey];\n        } else {\n          map._stringIndex[prefixedKey] = index;\n        }\n      } else {\n        if (shouldDelete) {\n          delete map._otherIndex[prefixedKey];\n        } else {\n          map._otherIndex[prefixedKey] = index;\n        }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a map with internal slots.\n   *\n   * @param {map} map\n   */\n  function initMap(map) {\n    // Data structure design inspired by Traceur's Map implementation.\n    // We maintain an internal array for all the entries. The array is needed\n    // to remember order. However, to have a reasonable HashMap performance\n    // i.e. O(1) for insertion, deletion, and retrieval. We maintain indices\n    // in objects for fast look ups. Indices are split up according to data\n    // types to avoid collisions.\n    map._mapData = [];\n\n    // Object index maps from an object \"hash\" to index. The hash being a unique\n    // property of our choosing that we associate with the object. Association\n    // is done by ways of keeping a non-enumerable property on the object.\n    // Ideally these would be `Object.create(null)` objects but since we're\n    // trying to support ES3 we'll have to guard against collisions using\n    // prefixes on the keys rather than rely on null prototype objects.\n    map._objectIndex = {};\n\n    // String index maps from strings to index.\n    map._stringIndex = {};\n\n    // Numbers, booleans, undefined, and null.\n    map._otherIndex = {};\n\n    // Unfortunately we have to support ES3 and cannot have `Map.prototype.size`\n    // be a getter method but just a regular method. The biggest problem with\n    // this is safety. Clients can change the size property easily and possibly\n    // without noticing (e.g. `if (map.size = 1) {..}` kind of typo). What we\n    // can do to mitigate use getters and setters in development to disallow\n    // and issue a warning for changing the `size` property.\n    if (__DEV__) {\n      if (isES5) {\n        // If the `SECRET_SIZE_PROP` property is already defined then we're not\n        // in the first call to `initMap` (e.g. coming from `map.clear()`) so\n        // all we need to do is reset the size without defining the properties.\n        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {\n          map[SECRET_SIZE_PROP] = 0;\n        } else {\n          Object.defineProperty(map, SECRET_SIZE_PROP, {\n            value: 0,\n            writable: true,\n          });\n          Object.defineProperty(map, 'size', {\n            set: v => {\n              console.error(\n                'PLEASE FIX ME: You are changing the map size property which ' +\n                  'should not be writable and will break in production.',\n              );\n              throw new Error('The map size property is not writable.');\n            },\n            get: () => map[SECRET_SIZE_PROP],\n          });\n        }\n\n        // NOTE: Early return to implement immutable `.size` in DEV.\n        return;\n      }\n    }\n\n    // This is a diviation from the spec. `size` should be a getter on\n    // `Map.prototype`. However, we have to support IE8.\n    map.size = 0;\n  }\n\n  /**\n   * Check if something is an object.\n   *\n   * @param {*} o\n   * @return {boolean}\n   */\n  function isObject(o) {\n    return o != null && (typeof o === 'object' || typeof o === 'function');\n  }\n\n  /**\n   * Create an iteration object.\n   *\n   * @param {*} value\n   * @param {boolean} done\n   * @return {object}\n   */\n  function createIterResultObject(value, done) {\n    return {value, done};\n  }\n\n  // Are we in a legit ES5 environment. Spoiler alert: that doesn't include IE8.\n  const isES5 = (function() {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  /**\n   * Check if an object can be extended.\n   *\n   * @param {object|array|function|regexp} o\n   * @return {boolean}\n   */\n  function isExtensible(o) {\n    if (!isES5) {\n      return true;\n    } else {\n      return Object.isExtensible(o);\n    }\n  }\n\n  /**\n   * IE has a `uniqueID` set on every DOM node. So we construct the hash from\n   * this uniqueID to avoid memory leaks and the IE cloneNode bug where it\n   * clones properties in addition to the attributes.\n   *\n   * @param {object} node\n   * @return {?string}\n   */\n  function getIENodeHash(node) {\n    let uniqueID;\n    switch (node.nodeType) {\n      case 1: // Element\n        uniqueID = node.uniqueID;\n        break;\n      case 9: // Document\n        uniqueID = node.documentElement.uniqueID;\n        break;\n      default:\n        return null;\n    }\n\n    if (uniqueID) {\n      return OLD_IE_HASH_PREFIX + uniqueID;\n    } else {\n      return null;\n    }\n  }\n\n  const getHash = (function() {\n    const propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    const hashProperty = guid();\n    let hashCounter = 0;\n\n    /**\n     * Get the \"hash\" associated with an object.\n     *\n     * @param {object|array|function|regexp} o\n     * @return {number}\n     */\n    return function getHash(o) {\n      // eslint-disable-line no-shadow\n      if (o[hashProperty]) {\n        return o[hashProperty];\n      } else if (\n        !isES5 &&\n        o.propertyIsEnumerable &&\n        o.propertyIsEnumerable[hashProperty]\n      ) {\n        return o.propertyIsEnumerable[hashProperty];\n      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {\n        return getIENodeHash(o);\n      } else if (!isES5 && o[hashProperty]) {\n        return o[hashProperty];\n      }\n\n      if (isExtensible(o)) {\n        hashCounter += 1;\n        if (isES5) {\n          Object.defineProperty(o, hashProperty, {\n            enumerable: false,\n            writable: false,\n            configurable: false,\n            value: hashCounter,\n          });\n        } else if (o.propertyIsEnumerable) {\n          // Since we can't define a non-enumerable property on the object\n          // we'll hijack one of the less-used non-enumerable properties to\n          // save our hash on it. Addiotionally, since this is a function it\n          // will not show up in `JSON.stringify` which is what we want.\n          o.propertyIsEnumerable = function() {\n            return propIsEnumerable.apply(this, arguments);\n          };\n          o.propertyIsEnumerable[hashProperty] = hashCounter;\n        } else if (isNode(o)) {\n          // At this point we couldn't get the IE `uniqueID` to use as a hash\n          // and we couldn't use a non-enumerable property to exploit the\n          // dontEnum bug so we simply add the `hashProperty` on the node\n          // itself.\n          o[hashProperty] = hashCounter;\n        } else {\n          throw new Error('Unable to set a non-enumerable property on object.');\n        }\n        return hashCounter;\n      } else {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      }\n    };\n  })();\n\n  return Map;\n})(Function('return this')()); // eslint-disable-line no-new-func\n"]},"metadata":{},"sourceType":"script"}