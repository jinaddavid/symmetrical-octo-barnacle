{"ast":null,"code":"'use strict';\n\nvar BatchedBridge = require(\"../BatchedBridge/BatchedBridge\");\n\nvar EventEmitter = require(\"../vendor/emitter/EventEmitter\");\n\nvar Set = require(\"../vendor/core/Set\");\n\nvar TaskQueue = require(\"./TaskQueue\");\n\nvar infoLog = require(\"../Utilities/infoLog\");\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar keyMirror = require('fbjs/lib/keyMirror');\n\nvar _emitter = new EventEmitter();\n\nvar DEBUG_DELAY = 0;\nvar DEBUG = false;\nvar InteractionManager = {\n  Events: keyMirror({\n    interactionStart: true,\n    interactionComplete: true\n  }),\n\n  runAfterInteractions(task) {\n    var tasks = [];\n    var promise = new Promise(resolve => {\n      _scheduleUpdate();\n\n      if (task) {\n        tasks.push(task);\n      }\n\n      tasks.push({\n        run: resolve,\n        name: 'resolve ' + (task && task.name || '?')\n      });\n\n      _taskQueue.enqueueTasks(tasks);\n    });\n    return {\n      then: promise.then.bind(promise),\n      done: function done() {\n        if (promise.done) {\n          return promise.done(...arguments);\n        } else {\n          console.warn('Tried to call done when not supported by current Promise implementation.');\n        }\n      },\n      cancel: function cancel() {\n        _taskQueue.cancelTasks(tasks);\n      }\n    };\n  },\n\n  createInteractionHandle() {\n    DEBUG && infoLog('create interaction handle');\n\n    _scheduleUpdate();\n\n    var handle = ++_inc;\n\n    _addInteractionSet.add(handle);\n\n    return handle;\n  },\n\n  clearInteractionHandle(handle) {\n    DEBUG && infoLog('clear interaction handle');\n    invariant(!!handle, 'Must provide a handle to clear.');\n\n    _scheduleUpdate();\n\n    _addInteractionSet.delete(handle);\n\n    _deleteInteractionSet.add(handle);\n  },\n\n  addListener: _emitter.addListener.bind(_emitter),\n\n  setDeadline(deadline) {\n    _deadline = deadline;\n  }\n\n};\n\nvar _interactionSet = new Set();\n\nvar _addInteractionSet = new Set();\n\nvar _deleteInteractionSet = new Set();\n\nvar _taskQueue = new TaskQueue({\n  onMoreTasks: _scheduleUpdate\n});\n\nvar _nextUpdateHandle = 0;\nvar _inc = 0;\n\nvar _deadline = -1;\n\nfunction _scheduleUpdate() {\n  if (!_nextUpdateHandle) {\n    if (_deadline > 0) {\n      _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);\n    } else {\n      _nextUpdateHandle = setImmediate(_processUpdate);\n    }\n  }\n}\n\nfunction _processUpdate() {\n  _nextUpdateHandle = 0;\n  var interactionCount = _interactionSet.size;\n\n  _addInteractionSet.forEach(handle => _interactionSet.add(handle));\n\n  _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));\n\n  var nextInteractionCount = _interactionSet.size;\n\n  if (interactionCount !== 0 && nextInteractionCount === 0) {\n    _emitter.emit(InteractionManager.Events.interactionComplete);\n  } else if (interactionCount === 0 && nextInteractionCount !== 0) {\n    _emitter.emit(InteractionManager.Events.interactionStart);\n  }\n\n  if (nextInteractionCount === 0) {\n    while (_taskQueue.hasTasksToProcess()) {\n      _taskQueue.processNext();\n\n      if (_deadline > 0 && BatchedBridge.getEventLoopRunningTime() >= _deadline) {\n        _scheduleUpdate();\n\n        break;\n      }\n    }\n  }\n\n  _addInteractionSet.clear();\n\n  _deleteInteractionSet.clear();\n}\n\nmodule.exports = InteractionManager;","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/Interaction/InteractionManager.js"],"names":["BatchedBridge","require","EventEmitter","Set","TaskQueue","infoLog","invariant","keyMirror","_emitter","DEBUG_DELAY","DEBUG","InteractionManager","Events","interactionStart","interactionComplete","runAfterInteractions","task","tasks","promise","Promise","resolve","_scheduleUpdate","push","run","name","_taskQueue","enqueueTasks","then","bind","done","console","warn","cancel","cancelTasks","createInteractionHandle","handle","_inc","_addInteractionSet","add","clearInteractionHandle","delete","_deleteInteractionSet","addListener","setDeadline","deadline","_deadline","_interactionSet","onMoreTasks","_nextUpdateHandle","setTimeout","_processUpdate","setImmediate","interactionCount","size","forEach","nextInteractionCount","emit","hasTasksToProcess","processNext","getEventLoopRunningTime","clear","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst BatchedBridge = require('../BatchedBridge/BatchedBridge');\nconst EventEmitter = require('../vendor/emitter/EventEmitter');\nconst Set = require('../vendor/core/Set');\nconst TaskQueue = require('./TaskQueue');\n\nconst infoLog = require('../Utilities/infoLog');\nconst invariant = require('fbjs/lib/invariant');\n/* $FlowFixMe(>=0.54.0 site=react_native_oss) This comment suppresses an error\n * found when Flow v0.54 was deployed. To see the error delete this comment and\n * run Flow. */\nconst keyMirror = require('fbjs/lib/keyMirror');\n\ntype Handle = number;\nimport type {Task} from './TaskQueue';\n\nconst _emitter = new EventEmitter();\n\nconst DEBUG_DELAY = 0;\nconst DEBUG = false;\n\n/**\n * InteractionManager allows long-running work to be scheduled after any\n * interactions/animations have completed. In particular, this allows JavaScript\n * animations to run smoothly.\n *\n * Applications can schedule tasks to run after interactions with the following:\n *\n * ```\n * InteractionManager.runAfterInteractions(() => {\n *   // ...long-running synchronous task...\n * });\n * ```\n *\n * Compare this to other scheduling alternatives:\n *\n * - requestAnimationFrame(): for code that animates a view over time.\n * - setImmediate/setTimeout(): run code later, note this may delay animations.\n * - runAfterInteractions(): run code later, without delaying active animations.\n *\n * The touch handling system considers one or more active touches to be an\n * 'interaction' and will delay `runAfterInteractions()` callbacks until all\n * touches have ended or been cancelled.\n *\n * InteractionManager also allows applications to register animations by\n * creating an interaction 'handle' on animation start, and clearing it upon\n * completion:\n *\n * ```\n * var handle = InteractionManager.createInteractionHandle();\n * // run animation... (`runAfterInteractions` tasks are queued)\n * // later, on animation completion:\n * InteractionManager.clearInteractionHandle(handle);\n * // queued tasks run if all handles were cleared\n * ```\n *\n * `runAfterInteractions` takes either a plain callback function, or a\n * `PromiseTask` object with a `gen` method that returns a `Promise`.  If a\n * `PromiseTask` is supplied, then it is fully resolved (including asynchronous\n * dependencies that also schedule more tasks via `runAfterInteractions`) before\n * starting on the next task that might have been queued up synchronously\n * earlier.\n *\n * By default, queued tasks are executed together in a loop in one\n * `setImmediate` batch. If `setDeadline` is called with a positive number, then\n * tasks will only be executed until the deadline (in terms of js event loop run\n * time) approaches, at which point execution will yield via setTimeout,\n * allowing events such as touches to start interactions and block queued tasks\n * from executing, making apps more responsive.\n */\nconst InteractionManager = {\n  Events: keyMirror({\n    interactionStart: true,\n    interactionComplete: true,\n  }),\n\n  /**\n   * Schedule a function to run after all interactions have completed. Returns a cancellable\n   * \"promise\".\n   */\n  runAfterInteractions(\n    task: ?Task,\n  ): {then: Function, done: Function, cancel: Function} {\n    const tasks = [];\n    const promise = new Promise(resolve => {\n      _scheduleUpdate();\n      if (task) {\n        tasks.push(task);\n      }\n      tasks.push({\n        run: resolve,\n        name: 'resolve ' + ((task && task.name) || '?'),\n      });\n      _taskQueue.enqueueTasks(tasks);\n    });\n    return {\n      then: promise.then.bind(promise),\n      done: (...args) => {\n        if (promise.done) {\n          return promise.done(...args);\n        } else {\n          console.warn(\n            'Tried to call done when not supported by current Promise implementation.',\n          );\n        }\n      },\n      cancel: function() {\n        _taskQueue.cancelTasks(tasks);\n      },\n    };\n  },\n\n  /**\n   * Notify manager that an interaction has started.\n   */\n  createInteractionHandle(): Handle {\n    DEBUG && infoLog('create interaction handle');\n    _scheduleUpdate();\n    const handle = ++_inc;\n    _addInteractionSet.add(handle);\n    return handle;\n  },\n\n  /**\n   * Notify manager that an interaction has completed.\n   */\n  clearInteractionHandle(handle: Handle) {\n    DEBUG && infoLog('clear interaction handle');\n    invariant(!!handle, 'Must provide a handle to clear.');\n    _scheduleUpdate();\n    _addInteractionSet.delete(handle);\n    _deleteInteractionSet.add(handle);\n  },\n\n  addListener: _emitter.addListener.bind(_emitter),\n\n  /**\n   * A positive number will use setTimeout to schedule any tasks after the\n   * eventLoopRunningTime hits the deadline value, otherwise all tasks will be\n   * executed in one setImmediate batch (default).\n   */\n  setDeadline(deadline: number) {\n    _deadline = deadline;\n  },\n};\n\nconst _interactionSet = new Set();\nconst _addInteractionSet = new Set();\nconst _deleteInteractionSet = new Set();\nconst _taskQueue = new TaskQueue({onMoreTasks: _scheduleUpdate});\nlet _nextUpdateHandle = 0;\nlet _inc = 0;\nlet _deadline = -1;\n\ndeclare function setImmediate(callback: any, ...args: Array<any>): number;\n\n/**\n * Schedule an asynchronous update to the interaction state.\n */\nfunction _scheduleUpdate() {\n  if (!_nextUpdateHandle) {\n    if (_deadline > 0) {\n      /* $FlowFixMe(>=0.63.0 site=react_native_fb) This comment suppresses an\n       * error found when Flow v0.63 was deployed. To see the error delete this\n       * comment and run Flow. */\n      _nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);\n    } else {\n      _nextUpdateHandle = setImmediate(_processUpdate);\n    }\n  }\n}\n\n/**\n * Notify listeners, process queue, etc\n */\nfunction _processUpdate() {\n  _nextUpdateHandle = 0;\n\n  const interactionCount = _interactionSet.size;\n  _addInteractionSet.forEach(handle => _interactionSet.add(handle));\n  _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));\n  const nextInteractionCount = _interactionSet.size;\n\n  if (interactionCount !== 0 && nextInteractionCount === 0) {\n    // transition from 1+ --> 0 interactions\n    _emitter.emit(InteractionManager.Events.interactionComplete);\n  } else if (interactionCount === 0 && nextInteractionCount !== 0) {\n    // transition from 0 --> 1+ interactions\n    _emitter.emit(InteractionManager.Events.interactionStart);\n  }\n\n  // process the queue regardless of a transition\n  if (nextInteractionCount === 0) {\n    while (_taskQueue.hasTasksToProcess()) {\n      _taskQueue.processNext();\n      if (\n        _deadline > 0 &&\n        BatchedBridge.getEventLoopRunningTime() >= _deadline\n      ) {\n        // Hit deadline before processing all tasks, so process more later.\n        _scheduleUpdate();\n        break;\n      }\n    }\n  }\n  _addInteractionSet.clear();\n  _deleteInteractionSet.clear();\n}\n\nmodule.exports = InteractionManager;\n"]},"metadata":{},"sourceType":"script"}