{"ast":null,"code":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar defineLazyObjectProperty = require(\"./defineLazyObjectProperty\");\n\nfunction polyfillObjectProperty(object, name, getValue) {\n  var descriptor = Object.getOwnPropertyDescriptor(object, name);\n\n  if (__DEV__ && descriptor) {\n    var backupName = \"original\".concat(name[0].toUpperCase()).concat(name.substr(1));\n    Object.defineProperty(object, backupName, _objectSpread(_objectSpread({}, descriptor), {}, {\n      value: object[name]\n    }));\n  }\n\n  var {\n    enumerable,\n    writable,\n    configurable\n  } = descriptor || {};\n\n  if (descriptor && !configurable) {\n    console.error('Failed to set polyfill. ' + name + ' is not configurable.');\n    return;\n  }\n\n  defineLazyObjectProperty(object, name, {\n    get: getValue,\n    enumerable: enumerable !== false,\n    writable: writable !== false\n  });\n}\n\nfunction polyfillGlobal(name, getValue) {\n  polyfillObjectProperty(global, name, getValue);\n}\n\nmodule.exports = {\n  polyfillObjectProperty,\n  polyfillGlobal\n};","map":{"version":3,"sources":["/Users/ash/Documents/DevSpace/MobileProject/ReactNative/InProgres/InterView/symmetrical-octo-barnacle/node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js"],"names":["defineLazyObjectProperty","require","polyfillObjectProperty","object","name","getValue","descriptor","Object","getOwnPropertyDescriptor","__DEV__","backupName","toUpperCase","substr","defineProperty","value","enumerable","writable","configurable","console","error","get","polyfillGlobal","global","module","exports"],"mappings":"AAUA;;;;;;;;AAEA,IAAMA,wBAAwB,GAAGC,OAAO,8BAAxC;;AAeA,SAASC,sBAAT,CACEC,MADF,EAEEC,IAFF,EAGEC,QAHF,EAIQ;AACN,MAAMC,UAAU,GAAGC,MAAM,CAACC,wBAAP,CAAgCL,MAAhC,EAAwCC,IAAxC,CAAnB;;AACA,MAAIK,OAAO,IAAIH,UAAf,EAA2B;AACzB,QAAMI,UAAU,qBAAcN,IAAI,CAAC,CAAD,CAAJ,CAAQO,WAAR,EAAd,SAAsCP,IAAI,CAACQ,MAAL,CAAY,CAAZ,CAAtC,CAAhB;AACAL,IAAAA,MAAM,CAACM,cAAP,CAAsBV,MAAtB,EAA8BO,UAA9B,kCACKJ,UADL;AAEEQ,MAAAA,KAAK,EAAEX,MAAM,CAACC,IAAD;AAFf;AAID;;AAED,MAAM;AAACW,IAAAA,UAAD;AAAaC,IAAAA,QAAb;AAAuBC,IAAAA;AAAvB,MAAuCX,UAAU,IAAI,EAA3D;;AACA,MAAIA,UAAU,IAAI,CAACW,YAAnB,EAAiC;AAC/BC,IAAAA,OAAO,CAACC,KAAR,CAAc,6BAA6Bf,IAA7B,GAAoC,uBAAlD;AACA;AACD;;AAEDJ,EAAAA,wBAAwB,CAACG,MAAD,EAASC,IAAT,EAAe;AACrCgB,IAAAA,GAAG,EAAEf,QADgC;AAErCU,IAAAA,UAAU,EAAEA,UAAU,KAAK,KAFU;AAGrCC,IAAAA,QAAQ,EAAEA,QAAQ,KAAK;AAHc,GAAf,CAAxB;AAKD;;AAED,SAASK,cAAT,CAA2BjB,IAA3B,EAAyCC,QAAzC,EAAkE;AAChEH,EAAAA,sBAAsB,CAACoB,MAAD,EAASlB,IAAT,EAAeC,QAAf,CAAtB;AACD;;AAEDkB,MAAM,CAACC,OAAP,GAAiB;AAACtB,EAAAA,sBAAD;AAAyBmB,EAAAA;AAAzB,CAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nconst defineLazyObjectProperty = require('./defineLazyObjectProperty');\n\n/**\n * Sets an object's property. If a property with the same name exists, this will\n * replace it but maintain its descriptor configuration. The property will be\n * replaced with a lazy getter.\n *\n * In DEV mode the original property value will be preserved as `original[PropertyName]`\n * so that, if necessary, it can be restored. For example, if you want to route\n * network requests through DevTools (to trace them):\n *\n *   global.XMLHttpRequest = global.originalXMLHttpRequest;\n *\n * @see https://github.com/facebook/react-native/issues/934\n */\nfunction polyfillObjectProperty<T>(\n  object: Object,\n  name: string,\n  getValue: () => T,\n): void {\n  const descriptor = Object.getOwnPropertyDescriptor(object, name);\n  if (__DEV__ && descriptor) {\n    const backupName = `original${name[0].toUpperCase()}${name.substr(1)}`;\n    Object.defineProperty(object, backupName, {\n      ...descriptor,\n      value: object[name],\n    });\n  }\n\n  const {enumerable, writable, configurable} = descriptor || {};\n  if (descriptor && !configurable) {\n    console.error('Failed to set polyfill. ' + name + ' is not configurable.');\n    return;\n  }\n\n  defineLazyObjectProperty(object, name, {\n    get: getValue,\n    enumerable: enumerable !== false,\n    writable: writable !== false,\n  });\n}\n\nfunction polyfillGlobal<T>(name: string, getValue: () => T): void {\n  polyfillObjectProperty(global, name, getValue);\n}\n\nmodule.exports = {polyfillObjectProperty, polyfillGlobal};\n"]},"metadata":{},"sourceType":"script"}